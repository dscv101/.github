name: reusable-codegen-agentos

on:
  workflow_call:
    inputs:
      prompt:
        type: string
        required: false
        default: ""
      spec_path:
        type: string
        required: false
        default: ""
      wait:
        type: boolean
        required: false
        default: true
      python_version:
        type: string
        required: false
        default: "3.12"
      specs_glob:
        type: string
        required: false
        default: ""     # if empty, auto-detect (.agent-os/specs or .specify/specs)
      require_agentos:
        type: boolean
        required: false
        default: true   # set false for "seeding" runs (no .agent-os committed yet)
    secrets:
      CODEGEN_ORG_ID:
        required: true
      CODEGEN_TOKEN:
        required: true

jobs:
  run-codegen:
    runs-on: ubuntu-latest
    concurrency:
      group: codegen-${{ github.repository }}-${{ github.ref }}
      cancel-in-progress: false
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python_version }}

      - name: Install Codegen SDK
        run: pip install --upgrade codegen

      - name: Verify Agent OS presence
        if: ${{ inputs.require_agentos }}
        run: |
          if [ ! -d .agent-os ]; then
            echo "::error::Missing .agent-os (commit Agent OS or run seeding job with require_agentos=false)"; exit 1;
          fi
          ls -R .agent-os | head -100

      - name: Proceeding without .agent-os (seeding expected)
        if: ${{ !inputs.require_agentos }}
        run: echo "::notice::.agent-os not found, but require_agentos=false; continuing (sandbox will seed)."

      - name: Trigger Codegen (spec- or prompt-driven)
        env:
          CODEGEN_ORG_ID: ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_TOKEN:  ${{ secrets.CODEGEN_TOKEN }}
          PROMPT_INPUT:   ${{ inputs.prompt }}
          SPEC_PATH:      ${{ inputs.spec_path }}
          SPECS_GLOB:     ${{ inputs.specs_glob }}
          REQUIRE_AGENTOS: ${{ inputs.require_agentos }}
          WAIT:           ${{ inputs.wait }}
          TARGET_REPO:    ${{ github.repository }}
        run: |
          python - <<'PY'
          import os, time
          from pathlib import Path

          # SDK import (works across versions)
          try:
              from codegen.agents.agent import Agent
          except Exception:
              from codegen import Agent  # type: ignore

          org_id = os.environ["CODEGEN_ORG_ID"]
          token  = os.environ["CODEGEN_TOKEN"]
          repo   = os.environ.get("TARGET_REPO")
          prompt = (os.environ.get("PROMPT_INPUT") or "").strip()
          spec_path  = (os.environ.get("SPEC_PATH") or "").strip()
          specs_glob = (os.environ.get("SPECS_GLOB") or "").strip()
          require_agentos = (os.environ.get("REQUIRE_AGENTOS","true").lower() in ("1","true","yes","on"))

          def newest(glob_pat: str):
              paths = sorted(Path().glob(glob_pat))
              return paths[-1] if paths else None

          # Build a prompt from newest spec if none provided
          if not prompt:
              if spec_path:
                  spec_dir = Path(spec_path)
              else:
                  spec_dir = None
                  if specs_glob:
                      spec_dir = newest(specs_glob)
                  if spec_dir is None:
                      # Auto-detect Agent OS or Spec Kit layouts
                      spec_dir = newest(".agent-os/specs/*") or newest(".specify/specs/*")

              if not spec_dir or not spec_dir.exists():
                  raise SystemExit("No prompt provided and no spec found (.agent-os/specs or .specify/specs).")

              has_standards = Path(".agent-os/standards").exists()
              standards_hint = " and our standards in .agent-os/standards" if has_standards else ""

              prompt = f"""
              In repo {repo}, implement the tasks in {spec_dir}/tasks.md,
              following the spec in {spec_dir}{standards_hint}.
              Create a feature branch and open a PR with tests passing.
              """

          print("=== Prompt ===\n" + prompt.strip() + "\n==============")

          agent = Agent(org_id=org_id, token=token)
          task = agent.run(prompt=prompt)
          print(f"Task started -> {task.status}")

          wait_flag = (str(os.environ.get("WAIT","true")).lower() in ("1","true","yes","on"))
          if wait_flag:
              for i in range(120):  # ~30 minutes @15s
                  task.refresh()
                  print(f"[{i+1}] status={task.status}")
                  if task.status in {"completed","failed","canceled"}:
                      break
                  time.sleep(15)
              print("Final status:", task.status)
              try:
                  print("Result:", task.result)
              except Exception:
                  pass
          else:
              print("Not waiting for completion.")
          PY