name: reusable-codegen-agents (hardened)

on:
  workflow_call:
    inputs:
      prompt:
        description: "Optional explicit prompt. If empty, a prompt is built from the newest spec."
        type: string
        required: false
        default: ""
      spec_path:
        description: "Path to a specific spec folder (e.g., .agent-os/specs/2025-10-01-feature-x)"
        type: string
        required: false
        default: ""
      specs_glob:
        description: "Glob for spec discovery; if empty, auto-detects .agent-os/specs/* or .specify/specs/*"
        type: string
        required: false
        default: ""
      require_agentos:
        description: "Require .agent-os/ to be present in the repo (set false for first-time seeding runs)"
        type: boolean
        required: false
        default: true
      wait:
        description: "Wait for Codegen to complete (poll & validate PR link)"
        type: boolean
        required: false
        default: true
      python_version:
        description: "Python version for the runner"
        type: string
        required: false
        default: "3.12"
      target_repo:
        description: "Owner/name of the repository to operate on; defaults to the calling repo"
        type: string
        required: false
        default: ""
    secrets:
      CODEGEN_ORG_ID:
        description: "Codegen organization ID"
        required: true
      CODEGEN_TOKEN:
        description: "Codegen API token"
        required: true
      CODEGEN_REPO_ID:
        description: "Codegen repository ID (pins the correct repo on the backend)"
        required: true

jobs:
  run-codegen:
    # Avoid overlapping runs per repo+ref
    concurrency:
      group: codegen-${{ github.repository }}-${{ github.ref }}
      cancel-in-progress: false

    runs-on: ubuntu-latest
    permissions:
      contents: read   # required for actions/checkout

    env:
      # Resolve the intended repo slug once (owner/name). Callers can override via input.
      TARGET_REPO: ${{ inputs.target_repo != '' && inputs.target_repo || github.repository }}

    steps:
      - name: Guard: no secrets in forked PRs
        if: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}
        run: |
          echo "::error:: This workflow is running on a forked PR; GitHub does not pass repository secrets to forks."
          exit 1

      - name: Checkout caller repo
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python_version }}

      - name: Install Codegen SDK
        run: pip install --upgrade codegen

      - name: Preflight: verify required secrets and compute repo slug
        id: preflight
        shell: bash
        env:
          CODEGEN_ORG_ID: ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_TOKEN:  ${{ secrets.CODEGEN_TOKEN }}
          CODEGEN_REPO_ID: ${{ secrets.CODEGEN_REPO_ID }}
          TARGET_REPO: ${{ env.TARGET_REPO }}
        run: |
          set -euo pipefail

          # Verify secrets present (do not print values)
          [ -n "${CODEGEN_ORG_ID}" ] || { echo "::error:: Missing secret CODEGEN_ORG_ID"; exit 1; }
          [ -n "${CODEGEN_TOKEN}" ]  || { echo "::error:: Missing secret CODEGEN_TOKEN"; exit 1; }
          [ -n "${CODEGEN_REPO_ID}" ] || { echo "::error:: Missing secret CODEGEN_REPO_ID"; exit 1; }

          # Determine checked-out repo slug from git remote
          REPO_SLUG="$(git config --get remote.origin.url | sed -E 's#.*github.com[:/](.+?)(\.git)?$#\1#')"
          echo "repo_slug=${REPO_SLUG}" >> "$GITHUB_OUTPUT"

          # Must match the job's TARGET_REPO (owner/name)
          if [ "${REPO_SLUG}" != "${TARGET_REPO}" ]; then
            echo "::error:: Repo mismatch. Expected ${TARGET_REPO}, got ${REPO_SLUG}."
            exit 1
          fi

          echo "::notice:: Preflight OK. TARGET_REPO=${TARGET_REPO}  (CODEGEN_REPO_ID is set; value hidden)"

      - name: Verify Agent OS presence (non-seeding runs)
        if: ${{ inputs.require_agentos }}
        run: |
          if [ ! -d ".agent-os" ]; then
            echo "::error::.agent-os/ not found. For first-time seeding runs, call this reusable with require_agentos=false."
            exit 1
          fi
          echo "::notice::.agent-os/ detected:"
          ls -R .agent-os | head -100

      - name: Proceeding without .agent-os (seeding expected)
        if: ${{ !inputs.require_agentos }}
        run: echo "::notice::.agent-os not found, but require_agentos=false; continuing (sandbox will seed)."

      - name: Build prompt or use provided
        id: prompt
        shell: python
        env:
          PROMPT_INPUT:  ${{ inputs.prompt }}
          SPEC_PATH:     ${{ inputs.spec_path }}
          SPECS_GLOB:    ${{ inputs.specs_glob }}
          TARGET_REPO:   ${{ env.TARGET_REPO }}
        run: |
          import os, sys
          from pathlib import Path

          prompt = (os.environ.get("PROMPT_INPUT") or "").strip()
          spec_path = (os.environ.get("SPEC_PATH") or "").strip()
          specs_glob = (os.environ.get("SPECS_GLOB") or "").strip()
          target_repo = os.environ["TARGET_REPO"]

          def newest(glob: str):
            ps = sorted(Path().glob(glob))
            return ps[-1] if ps else None

          # If no explicit prompt, build from the latest spec (Agent OS or Spec Kit)
          if not prompt:
            spec_dir = Path(spec_path) if spec_path else (
              newest(specs_glob) if specs_glob else
              (newest(".agent-os/specs/*") or newest(".specify/specs/*"))
            )
            if not spec_dir or not spec_dir.exists():
              print("::error:: No prompt and no spec found (.agent-os/specs or .specify/specs).")
              sys.exit(1)

            has_standards = Path(".agent-os/standards").exists()
            standards_hint = " and our standards in .agent-os/standards" if has_standards else ""

            prompt = f"""
            [MODE=RUN_SPEC]
            [REPO:{target_repo}]
            In repo {target_repo}, implement the tasks in {spec_dir}/tasks.md,
            following the spec in {spec_dir}{standards_hint}.
            Create a feature branch and open a PR with tests passing.
            ONLY operate on {target_repo}. Do not touch any other repository.
            """.strip()

          # Emit to output
          prompt = "\n".join(line.rstrip() for line in prompt.splitlines())
          print(f"PROMPT<<'EOF'\n{prompt}\nEOF")
          with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
            fh.write(f"prompt<<EOF\n{prompt}\nEOF\n")

      - name: Trigger Codegen (hardened)
        env:
          # Codegen auth + explicit repo pin
          CODEGEN_ORG_ID:  ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_TOKEN:   ${{ secrets.CODEGEN_TOKEN }}
          CODEGEN_REPO_ID: ${{ secrets.CODEGEN_REPO_ID }}

          # Behavior
          WAIT:          ${{ inputs.wait }}
          TARGET_REPO:   ${{ env.TARGET_REPO }}
          PROMPT_TEXT:   ${{ steps.prompt.outputs.prompt }}
        shell: python
        run: |
          import os, re, sys, time

          # Import SDK (support older/newer structures)
          try:
              from codegen.agents.agent import Agent
          except Exception:
              from codegen import Agent  # type: ignore

          org_id  = (os.environ.get("CODEGEN_ORG_ID") or "").strip()
          token   = (os.environ.get("CODEGEN_TOKEN")  or "").strip()
          repo_id = (os.environ.get("CODEGEN_REPO_ID") or "").strip()
          target_repo = (os.environ.get("TARGET_REPO") or "").strip()
          prompt = (os.environ.get("PROMPT_TEXT") or "").strip()
          wait   = (os.environ.get("WAIT","true").lower() in ("1","true","yes","on"))

          if not org_id or not token or not repo_id or not target_repo or not prompt:
              print("::error:: Missing one of required env vars (ORG_ID / TOKEN / REPO_ID / TARGET_REPO / PROMPT).")
              sys.exit(1)

          # Preflight log (no secrets)
          print(f"Org={org_id[:4]}...  RepoID=****  TargetRepo={target_repo}")
          print("=== Prompt ==="); print(prompt); print("==============")

          # Pin the backend repo via environment for the SDK call
          os.environ["REPOSITORY_ID"]  = repo_id
          os.environ["CODEGEN_REPO_ID"] = repo_id

          # Run the agent (Agent.run only accepts prompt; repo comes from env)
          try:
              agent = Agent(org_id=org_id, token=token)
              task = agent.run(prompt=prompt)
          except Exception as e:
              msg = str(e)
              if "401" in msg or "Unauthorized" in msg:
                  print("::error:: Codegen returned 401 Unauthorized. Check CODEGEN_TOKEN / CODEGEN_ORG_ID and rerun.")
              raise

          print(f"Task started -> {task.status}")

          # Poll and validate the PR URL belongs to TARGET_REPO
          pr_url, pr_repo, pr_mismatch = None, None, False
          if wait:
              for i in range(120):  # ~30m @15s
                  try:
                      task.refresh()
                  except Exception as e:
                      print(f"[{i+1}] refresh error: {e}")
                  else:
                      print(f"[{i+1}] status={task.status}")

                      # Try to extract PR URL early from task.result (best-effort)
                      try:
                          res = str(getattr(task, "result", "") or "")
                          m = re.search(r"https?://github\.com/([^/\s]+)/([^/\s]+)/pull/\d+", res)
                          if m:
                              pr_repo = f"{m.group(1)}/{m.group(2)}"
                              pr_url  = m.group(0)
                              if pr_repo != target_repo:
                                  pr_mismatch = True
                                  break
                      except Exception:
                          pass

                      if task.status in {"completed","failed","canceled"}:
                          break
                  time.sleep(15)

              print("Final status:", task.status)
              if pr_url:
                  print(f"PR URL: {pr_url}")

          if pr_mismatch:
              print(f"::error:: Codegen opened PR in {pr_repo}, but TARGET_REPO is {target_repo}.")
              sys.exit(1)

          # If no PR found at completion, provide a helpful hint
          if wait and task.status == "completed" and not pr_url:
              print("::notice:: No PR URL detected in task output. If changes were made, the PR should still be visible in GitHub.")