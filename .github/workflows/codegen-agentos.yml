name: reusable-codegen-agents (hardened)

on:
  workflow_call:
    inputs:
      prompt:
        description: "Optional explicit prompt. If empty, a prompt is built from the newest spec."
        type: string
        required: false
        default: ""
      spec_path:
        description: "Path to a specific spec folder (e.g., .agent-os/specs/2025-10-01-feature-x)"
        type: string
        required: false
        default: ""
      specs_glob:
        description: "Glob for spec discovery; if empty, auto-detects .agent-os/specs/* or .specify/specs/*"
        type: string
        required: false
        default: ""
      require_agentos:
        description: "Require .agent-os/ to be present (false for first-time seeding)"
        type: boolean
        required: false
        default: true
      wait:
        description: "Wait for Codegen to complete (poll & validate PR link)"
        type: boolean
        required: false
        default: true
      python_version:
        description: "Python version for the runner"
        type: string
        required: false
        default: "3.12"
      target_repo:
        description: "Owner/name of the repository to operate on; defaults to the calling repo"
        type: string
        required: false
        default: ""
    secrets:
      CODEGEN_ORG_ID:
        required: true
      CODEGEN_TOKEN:
        required: true
      CODEGEN_REPO_ID:
        required: true

jobs:
  run-codegen:
    concurrency:
      group: codegen-${{ github.repository }}-${{ github.ref }}
      cancel-in-progress: false

    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      # Resolve intended repo once; callers can override via input.
      TARGET_REPO: ${{ inputs.target_repo != '' && inputs.target_repo || github.repository }}

    steps:
      - name: Guard: no secrets in forked PRs
        if: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}
        run: |
          echo "::error:: This workflow is running on a forked PR; GitHub does not pass repository secrets to forks."
          exit 1

      - name: Checkout caller repo
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python_version }}

      - name: Install Codegen SDK
        run: pip install --upgrade codegen

      - name: Preflight: verify secrets & repo slug
        id: preflight
        env:
          CODEGEN_ORG_ID:  ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_TOKEN:   ${{ secrets.CODEGEN_TOKEN }}
          CODEGEN_REPO_ID: ${{ secrets.CODEGEN_REPO_ID }}
          TARGET_REPO:     ${{ env.TARGET_REPO }}
        run: |
          set -euo pipefail
          [ -n "${CODEGEN_ORG_ID}" ]  || { echo "::error:: Missing secret CODEGEN_ORG_ID"; exit 1; }
          [ -n "${CODEGEN_TOKEN}" ]   || { echo "::error:: Missing secret CODEGEN_TOKEN"; exit 1; }
          [ -n "${CODEGEN_REPO_ID}" ] || { echo "::error:: Missing secret CODEGEN_REPO_ID"; exit 1; }

          REPO_SLUG="$(git config --get remote.origin.url | sed -E 's#.*github.com[:/](.+?)(\.git)?$#\1#')"
          echo "repo_slug=${REPO_SLUG}" >> "$GITHUB_OUTPUT"

          if [ "${REPO_SLUG}" != "${TARGET_REPO}" ]; then
            echo "::error:: Repo mismatch. Expected ${TARGET_REPO}, got ${REPO_SLUG}."
            exit 1
          fi
          echo "::notice:: Preflight OK. TARGET_REPO=${TARGET_REPO} (Codegen repo pinned via secret; value hidden)"

      - name: Verify Agent OS presence (non-seeding runs)
        if: ${{ inputs.require_agentos }}
        run: |
          if [ ! -d ".agent-os" ]; then
            echo "::error::.agent-os/ not found. For first-time seeding, call with require_agentos=false."
            exit 1
          fi
          echo "::notice::.agent-os/ detected:"
          ls -R .agent-os | head -100

      - name: Proceeding without .agent-os (seeding expected)
        if: ${{ !inputs.require_agentos }}
        run: echo "::notice::.agent-os not found, but require_agentos=false; continuing (sandbox will seed)."

      - name: Build prompt or use provided
        id: prompt
        env:
          PROMPT_INPUT:  ${{ inputs.prompt }}
          SPEC_PATH:     ${{ inputs.spec_path }}
          SPECS_GLOB:    ${{ inputs.specs_glob }}
          TARGET_REPO:   ${{ env.TARGET_REPO }}
        run: |
          python - <<'PY'
          import os, sys
          from pathlib import Path

          prompt      = (os.environ.get("PROMPT_INPUT") or "").strip()
          spec_path   = (os.environ.get("SPEC_PATH") or "").strip()
          specs_glob  = (os.environ.get("SPECS_GLOB") or "").strip()
          target_repo = os.environ["TARGET_REPO"]

          def newest(glob: str):
              ps = sorted(Path().glob(glob))
              return ps[-1] if ps else None

          if not prompt:
              spec_dir = Path(spec_path) if spec_path else (
                  newest(specs_glob) if specs_glob else
                  (newest(".agent-os/specs/*") or newest(".specify/specs/*"))
              )
              if not spec_dir or not spec_dir.exists():
                  print("::error:: No prompt and no spec found (.agent-os/specs or .specify/specs).")
                  sys.exit(1)
              has_standards = Path(".agent-os/standards").exists()
              standards_hint = " and our standards in .agent-os/standards" if has_standards else ""
              prompt = f"""
              [MODE=RUN_SPEC]
              [REPO:{target_repo}]
              In repo {target_repo}, implement the tasks in {spec_dir}/tasks.md,
              following the spec in {spec_dir}{standards_hint}.
              Create a feature branch and open a PR with tests passing.
              ONLY operate on {target_repo}. Do not touch any other repository.
              """.strip()

          # emit to $GITHUB_OUTPUT (already provided by runner)
          with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
              fh.write("prompt<<EOF\n")
              fh.write(prompt + "\n")
              fh.write("EOF\n")

          print("Built prompt:")
          print(prompt)
          PY

      - name: Trigger Codegen (hardened)
        env:
          CODEGEN_ORG_ID:  ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_TOKEN:   ${{ secrets.CODEGEN_TOKEN }}
          CODEGEN_REPO_ID: ${{ secrets.CODEGEN_REPO_ID }}
          WAIT:            ${{ inputs.wait }}
          TARGET_REPO:     ${{ env.TARGET_REPO }}
          PROMPT_TEXT:     ${{ steps.prompt.outputs.prompt }}
        run: |
          python - <<'PY'
          import os, re, sys, time

          # Import SDK (support older/newer structures)
          try:
              from codegen.agents.agent import Agent
          except Exception:
              from codegen import Agent  # type: ignore

          org_id   = (os.environ.get("CODEGEN_ORG_ID")  or "").strip()
          token    = (os.environ.get("CODEGEN_TOKEN")   or "").strip()
          repo_id  = (os.environ.get("CODEGEN_REPO_ID") or "").strip()
          target   = (os.environ.get("TARGET_REPO")     or "").strip()
          prompt   = (os.environ.get("PROMPT_TEXT")     or "").strip()
          waitflag = (os.environ.get("WAIT","true").lower() in ("1","true","yes","on"))

          if not all([org_id, token, repo_id, target, prompt]):
              print("::error:: Missing one of required env vars (ORG_ID / TOKEN / REPO_ID / TARGET_REPO / PROMPT).")
              sys.exit(1)

          print(f"Org={org_id[:4]}...  RepoID=****  TargetRepo={target}")
          print("=== Prompt ==="); print(prompt); print("==============")

          # Pin backend repo via env for the SDK call
          os.environ["REPOSITORY_ID"]   = repo_id
          os.environ["CODEGEN_REPO_ID"] = repo_id

          try:
              agent = Agent(org_id=org_id, token=token)
              task = agent.run(prompt=prompt)   # repo is taken from env
          except Exception as e:
              msg = str(e)
              if "401" in msg or "Unauthorized" in msg:
                  print("::error:: Codegen 401 Unauthorized. Check CODEGEN_TOKEN / CODEGEN_ORG_ID and rerun.")
              raise

          print(f"Task started -> {task.status}")

          pr_url = None
          if waitflag:
              for i in range(120):  # ~30m @15s
                  try:
                      task.refresh()
                  except Exception as e:
                      print(f"[{i+1}] refresh error: {e}")
                  else:
                      print(f"[{i+1}] status={task.status}")
                      try:
                          res = str(getattr(task, "result", "") or "")
                          m = re.search(r"https?://github\.com/([^/\s]+)/([^/\s]+)/pull/\d+", res)
                          if m:
                              pr_repo = f"{m.group(1)}/{m.group(2)}"
                              pr_url  = m.group(0)
                              if pr_repo != target:
                                  print(f"::error:: Codegen opened PR in {pr_repo}, but TARGET_REPO is {target}.")
                                  sys.exit(1)
                              break
                      except Exception:
                          pass
                      if task.status in {"completed","failed","canceled"}:
                          break
                  time.sleep(15)

              print("Final status:", task.status)
              if pr_url:
                  print(f"PR URL: {pr_url}")

          if waitflag and task.status == "completed" and not pr_url:
              print("::notice:: No PR URL detected in task output. If changes were made, the PR should still be visible in GitHub.")
          PY