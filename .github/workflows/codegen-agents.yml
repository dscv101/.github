# .github/workflows/codegen-agents.yml
name: Codegen Agents

on:
  workflow_call:
    inputs:
      prompt:
        description: "Optional prompt to pass to Codegen"
        required: false
        type: string
        default: ""
      spec_path:
        description: "Explicit spec path"
        required: false
        type: string
        default: ""
      specs_glob:
        description: "Glob override for discovering specs"
        required: false
        type: string
        default: ""
      wait:
        description: "Wait for remote task completion"
        required: false
        type: boolean
        default: true
      python_version:
        description: "Python version for SDK"
        required: false
        type: string
        default: "3.12"
      target_repo:
        description: "Expected GitHub repository slug"
        required: false
        type: string
        default: ""
    secrets:
      CODEGEN_ORG_ID:
        required: true
      CODEGEN_TOKEN:
        required: true
      CODEGEN_REPO_ID:
        required: false

permissions:
  contents: read

concurrency:
  group: codegen-${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  run:
    name: Run Codegen Agent
    runs-on: ubuntu-latest
    env:
      PYTHONWARNINGS: ignore
    steps:
      - name: Guard forked pull requests
        if: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}
        run: |
          echo "::error::Codegen workflows do not run on pull requests from forks."
          exit 1

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python_version }}

      - name: Install Codegen SDK
        run: |
          set -euo pipefail
          python -m pip install --disable-pip-version-check --upgrade codegen

      - name: Preflight validation
        id: preflight
        env:
          CODEGEN_ORG_ID: ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_TOKEN: ${{ secrets.CODEGEN_TOKEN }}
          TARGET_REPO_INPUT: ${{ inputs.target_repo }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          if [ -z "${CODEGEN_ORG_ID:-}" ]; then
            echo "::error::Missing CODEGEN_ORG_ID secret."
            exit 1
          fi
          if [ -z "${CODEGEN_TOKEN:-}" ]; then
            echo "::error::Missing CODEGEN_TOKEN secret."
            exit 1
          fi

          origin_url=$(git config --get remote.origin.url || true)
          if [ -z "${origin_url}" ]; then
            echo "::error::Unable to determine git remote origin URL."
            exit 1
          fi

          target_repo="${TARGET_REPO_INPUT:-$GITHUB_REPOSITORY}"
          repo_slug="${origin_url}"
          case "${repo_slug}" in
            git@github.com:*)
              repo_slug="${repo_slug#git@github.com:}"
              ;;
            ssh://git@github.com/*)
              repo_slug="${repo_slug#ssh://git@github.com/}"
              ;;
            https://github.com/*)
              repo_slug="${repo_slug#https://github.com/}"
              ;;
            http://github.com/*)
              repo_slug="${repo_slug#http://github.com/}"
              ;;
            git://github.com/*)
              repo_slug="${repo_slug#git://github.com/}"
              ;;
          esac
          repo_slug="${repo_slug%.git}"
          repo_slug="${repo_slug#/}"
          if [ -z "${repo_slug}" ]; then
            echo "::error::Unable to parse repository slug from git remote URL."
            exit 1
          fi
          if [ "${repo_slug}" != "${target_repo}" ]; then
            echo "::error::Git remote slug '${repo_slug}' does not match expected '${target_repo}'."
            exit 1
          fi
          {
            echo "target-repo=${target_repo}"
            echo "repo-slug=${repo_slug}"
          } >>"${GITHUB_OUTPUT}"

      - name: Resolve Codegen repository id
        id: repo_id
        env:
          CODEGEN_REPO_ID_SECRET: ${{ secrets.CODEGEN_REPO_ID }}
          CODEGEN_ORG_ID: ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_TOKEN: ${{ secrets.CODEGEN_TOKEN }}
          TARGET_REPO: ${{ steps.preflight.outputs.repo-slug }}
        run: |
          set -euo pipefail
          mkdir -p .codegen

          trim() {
            printf '%s' "$1" | tr -d '\r\n\t '
          }

          cache_repo_id() {
            local repo_id
            repo_id="$(trim "$1")"
            if [ -z "${repo_id}" ]; then
              echo "::error::Repository id value is empty after trimming."
              exit 1
            fi
            if [ -z "${TARGET_REPO:-}" ]; then
              echo "::error::Target repository slug is unavailable for caching."
              exit 1
            fi
            local cache_path
            cache_path=".codegen/repos/${TARGET_REPO}/repo-id"
            mkdir -p "$(dirname "${cache_path}")"
            printf '%s\n' "${repo_id}" >"${cache_path}"
            printf 'repo-id=%s\n' "${repo_id}" >>"${GITHUB_OUTPUT}"
          }

          if [ -n "${CODEGEN_REPO_ID_SECRET:-}" ]; then
            repo_id="$(trim "${CODEGEN_REPO_ID_SECRET}")"
            if [ -z "${repo_id}" ]; then
              echo "::error::CODEGEN_REPO_ID secret is empty after trimming."
              exit 1
            fi
            cache_repo_id "${repo_id}"
            echo "::notice::Using Codegen repository id from secret."
            exit 0
          fi

          repo_cache_path=""
          if [ -n "${TARGET_REPO:-}" ]; then
            repo_cache_path=".codegen/repos/${TARGET_REPO}/repo-id"
          fi

          if [ -n "${repo_cache_path}" ] && [ -f "${repo_cache_path}" ]; then
            repo_id="$(head -n 1 "${repo_cache_path}" | tr -d '\r\n\t ')"
            if [ -n "${repo_id}" ]; then
              cache_repo_id "${repo_id}"
              echo "::notice::Using Codegen repository id cache for '${TARGET_REPO}'."
              exit 0
            fi
          fi

          legacy_cache=".codegen/repo-id"
          if [ -f "${legacy_cache}" ]; then
            legacy_line="$(head -n 1 "${legacy_cache}" | tr -d '\r\n\t ')"
            if [ -n "${legacy_line}" ]; then
              case "${legacy_line}" in
                *:*)
                  legacy_slug="$(trim "${legacy_line%%:*}")"
                  legacy_id="$(trim "${legacy_line#*:}")"
                  if [ -n "${legacy_slug}" ] && [ -n "${legacy_id}" ] && [ "${legacy_slug}" = "${TARGET_REPO}" ]; then
                    cache_repo_id "${legacy_id}"
                    echo "::notice::Using Codegen repository id from legacy cache for '${TARGET_REPO}'."
                    rm -f "${legacy_cache}"
                    exit 0
                  fi
                  ;;
                *)
                  echo "::notice::Ignoring legacy repo id cache without repository slug."
                  ;;
              esac
            fi
            rm -f "${legacy_cache}"
          fi

          if [ -z "${CODEGEN_TOKEN:-}" ]; then
            echo "::error::CODEGEN_TOKEN is required to discover the repository id."
            exit 1
          fi
          if [ -z "${CODEGEN_ORG_ID:-}" ]; then
            echo "::error::CODEGEN_ORG_ID is required to discover the repository id."
            exit 1
          fi
          if [ -z "${TARGET_REPO:-}" ]; then
            echo "::error::Target repository slug is unavailable."
            exit 1
          fi

          repo_id="$(python - <<'PY'
          import json
          import os
          import sys
          import urllib.error
          import urllib.request

          org_id = os.environ["CODEGEN_ORG_ID"].strip()
          token = os.environ["CODEGEN_TOKEN"].strip()
          target_repo = os.environ["TARGET_REPO"].strip().lower()

          headers = {
              "Authorization": f"Bearer {token}",
              "Accept": "application/json",
              "x-organization-id": org_id,
          }

          base_url = f"https://api.codegen.com/v1/organizations/{org_id}/repos"
          limit = 100
          skip = 0
          repo_id = None


          def fetch(url: str) -> dict:
              request = urllib.request.Request(url, headers=headers)
              try:
                  with urllib.request.urlopen(request, timeout=30) as response:
                      return json.load(response)
              except urllib.error.HTTPError as exc:  # pragma: no cover - network error handler
                  detail = exc.read().decode("utf-8", errors="ignore")
                  print(
                      f"::error::Failed to query Codegen API (HTTP {exc.code}): {detail}",
                      file=sys.stderr,
                  )
                  raise
              except Exception as exc:  # pragma: no cover - network error handler
                  print(f"::error::Failed to query Codegen API: {exc}", file=sys.stderr)
                  raise


          while True:
              url = f"{base_url}?limit={limit}&skip={skip}"
              payload = fetch(url)
              items = payload.get("items") or []
              for item in items:
                  full_name = (item.get("full_name") or "").lower()
                  if full_name == target_repo:
                      repo_id = item.get("id")
                      break
              if repo_id is not None:
                  break
              total = payload.get("total")
              if not items or total is None:
                  break
              skip += len(items)
              if skip >= int(total):
                  break

          if repo_id is None:
              sys.exit(
                  f"::error::Repository '{target_repo}' not found for organization {org_id}."
              )

          print(repo_id)
          PY
          )"
          repo_id="$(trim "${repo_id}")"
          if [ -z "${repo_id}" ]; then
            echo "::error::Failed to resolve Codegen repository id automatically."
            exit 1
          fi
          cache_repo_id "${repo_id}"
          echo "::notice::Discovered Codegen repository id automatically for '${TARGET_REPO}'."

      - name: Prepare prompt
        id: prompt
        env:
          INPUT_PROMPT: ${{ inputs.prompt }}
          INPUT_SPEC_PATH: ${{ inputs.spec_path }}
          INPUT_SPECS_GLOB: ${{ inputs.specs_glob }}
          LEGACY_DISCOVERY: 1
        run: |
          set -euo pipefail
          python .github/scripts/codegen_workflow.py prepare-prompt

      - name: Run Codegen task
        id: run_agent
        env:
          CODEGEN_ORG_ID: ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_TOKEN: ${{ secrets.CODEGEN_TOKEN }}
          RESOLVED_REPO_ID: ${{ steps.repo_id.outputs.repo-id }}
          PROMPT: ${{ steps.prompt.outputs.prompt }}
        run: |
          set -euo pipefail
          export CODEGEN_REPO_ID="${RESOLVED_REPO_ID}"
          export REPOSITORY_ID="${RESOLVED_REPO_ID}"
          python .github/scripts/codegen_workflow.py run-task

      - name: Wait for task completion
        id: wait
        if: ${{ inputs.wait && steps.run_agent.outputs.task_id }}
        env:
          CODEGEN_ORG_ID: ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_TOKEN: ${{ secrets.CODEGEN_TOKEN }}
          RESOLVED_REPO_ID: ${{ steps.repo_id.outputs.repo-id }}
          TASK_ID: ${{ steps.run_agent.outputs.task_id }}
        run: |
          set -euo pipefail
          export CODEGEN_REPO_ID="${RESOLVED_REPO_ID}"
          export REPOSITORY_ID="${RESOLVED_REPO_ID}"
          python .github/scripts/codegen_workflow.py wait-task

      - name: Validate generated pull request
        env:
          TARGET_REPO: ${{ steps.preflight.outputs.target-repo }}
          PR_URL_WAIT: ${{ steps.wait.outputs.pr_url }}
          PR_URL_INITIAL: ${{ steps.run_agent.outputs.pr_url }}
        run: |
          set -euo pipefail
          pr_url="${PR_URL_WAIT}"
          if [ -z "${pr_url}" ]; then
            pr_url="${PR_URL_INITIAL}"
          fi
          if [ -z "${pr_url}" ]; then
            echo "::notice::No pull request URL provided by Codegen."
            exit 0
          fi
          python .github/scripts/codegen_workflow.py validate-pr

      - name: Summary
        env:
          PR_URL_WAIT: ${{ steps.wait.outputs.pr_url }}
          PR_URL_INITIAL: ${{ steps.run_agent.outputs.pr_url }}
        run: |
          set -euo pipefail
          python .github/scripts/codegen_workflow.py summary
