<repomix><file_summary>This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been formatted for parsing in xml style, security check has been disabled.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been formatted for parsing in xml style
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)</notes></file_summary><directory_structure>.claude/
  settings.local.json
.github/
  actions/
    release-pypi/
      action.yml
    release-slack-bot/
      action.yml
    report/
      action.yml
    run-ats/
      action.yml
      ats.sh
      collect.sh
    setup-environment/
      action.yml
    setup-oss-repos/
      action.yml
  workflows/
    auto-release.yml
    cache-delete.yml
    pre-commit.yml
    release.yml
    test.yml
    ty.yml
  codecov.yml
  CODEOWNERS
  dependabot.yml
  pull_request_template.md
  release.yml
docs/
  agents/
    create-agent-run.mdx
    get-agent-run.mdx
  api-reference/
    agent-run-logs.mdx
    authentication.mdx
    github-actions.mdx
    openapi3.json
    overview.mdx
  capabilities/
    analytics.mdx
    capabilities.mdx
    checks-autofixer.mdx
    claude-code.mdx
    interrupts.mdx
    pr-review.mdx
    triggering-codegen.mdx
  integrations/
    circleci.mdx
    clickup.mdx
    figma.mdx
    github.mdx
    integrations.mdx
    jira.mdx
    linear.mdx
    mcp-servers.mdx
    mcp.mdx
    monday.mdx
    notion.mdx
    postgres.mdx
    sentry.mdx
    slack.mdx
    web-search.mdx
  introduction/
    about.mdx
    cli.mdx
    community.mdx
    faq.mdx
    guiding-principles.mdx
    how-it-works.mdx
    overview.mdx
    prompting.mdx
    sdk.mdx
    support.mdx
    use-cases.mdx
  logo/
    dark.svg
    light.svg
  organizations/
    get-organizations.mdx
  samples/
    sample.py
    sample.tsx
  sandboxes/
    base-image.mdx
    editor.mdx
    environment-variables.mdx
    image-snapshots.mdx
    overview.mdx
    secrets.mdx
    setup-commands.mdx
    web-preview.mdx
  settings/
    agent-behavior.mdx
    agent-permissions.mdx
    model-configuration.mdx
    on-prem-deployment.mdx
    organization-rules.mdx
    repo-rules.mdx
    repo-rules.tsx
    settings.mdx
    team-roles.mdx
    trufflehog-integration.mdx
  snippets/
    Attribute.mdx
    GithubLinkNote.mdx
    HorizontalDivider.mdx
    links.mdx
    Parameter.mdx
    ParameterWrapper.mdx
    Return.mdx
  users/
    get-user.mdx
    get-users.mdx
  .gitignore
  docs.json
  favicon.svg
  prism.css
  README.md
  self-update.md
  style.css
scripts/
  profiling/
    profile.py
  disallowed-words-check.sh
  install-deps.sh
  setup.sh
src/
  codegen/
    agents/
      __init__.py
      agent.py
      constants.py
      README.md
    cli/
      api/
        client.py
        endpoints.py
        modal.py
        schemas.py
        webapp_routes.py
      auth/
        constants.py
        decorators.py
        login.py
        session.ipynb
        session.py
        token_manager.ipynb
        token_manager.py
      claude/
        __init__.py
      commands/
        agent/
          __init__.py
          main.py
        agents/
          __init__.py
          main.py
        claude/
          config/
            claude_session_active_hook.py
            claude_session_hook.py
            claude_session_stop_hook.py
            mcp_setup.py
          __init__.py
          claude_log_utils.py
          claude_log_watcher.py
          claude_session_api.py
          hooks.py
          main.py
          quiet_console.py
          utils.py
        config/
          main.py
          telemetry.py
        init/
          main.py
          render.py
        integrations/
          __init__.py
          main.py
        login/
          main.py
        logout/
          main.py
        org/
          __init__.py
          main.py
          tui.py
        profile/
          main.py
        repo/
          __init__.py
          main.py
          tui.py
        style_debug/
          main.py
        tools/
          __init__.py
          main.py
        tui/
          __init__.py
          main.py
        update/
          __init__.py
          main.py
          updater.py
      env/
        constants.py
        enums.py
        global_env.ipynb
        global_env.py
      mcp/
        tools/
          __init__.py
          dynamic.py
          executor.py
          static.py
        __init__.py
        api_client.py
        prompts.py
        README.md
        resources.py
        runner.py
        server.py
      rich/
        codeblocks.py
        pretty_print.py
        spinners.py
      telemetry/
        __init__.py
        consent.py
        debug_exporter.py
        exception_logger.py
        otel_setup.py
        viewer.py
      tui/
        __init__.py
        agent_detail.py
        app.py
        codegen_theme.tcss
        codegen_tui.tcss
      utils/
        codemod_manager.py
        codemods.py
        count_functions_2.py
        default_code.py
        function_finder.py
        inplace_print.py
        json_schema.py
        notebooks.py
        org.py
        repo.py
        schema.ipynb
        schema.py
        simple_selector.py
        url.py
      _env.py
      cli.py
      errors.py
      README.md
    configs/
      models/
        base_config.py
        codebase.py
        repository.py
        secrets.py
        telemetry.py
        utils.py
      constants.py
      session_manager.py
      user_config.py
    git/
      clients/
        git_repo_client.py
        github_client.py
      configs/
        constants.py
      models/
        codemod_context.py
        github_named_user_context.py
        pr_options.py
        pr_part_context.py
        pull_request_context.py
      repo_operator/
        local_git_repo.py
        repo_operator.py
      schemas/
        enums.py
        repo_config.py
      utils/
        clone_url.py
        clone.py
        codeowner_utils.py
        file_utils.py
        format.py
        language.py
        pr_review.py
        remote_progress.py
      README.md
    shared/
      compilation/
        codeblock_validation.py
        exception_utils.py
        function_compilation.py
        function_construction.py
        function_imports.py
        README.md
        string_to_code.py
      decorators/
        docs.py
      enums/
        programming_language.py
      exceptions/
        api.py
        compilation.py
        control_flow.py
      logging/
        get_logger.py
      network/
        port.py
      performance/
        memory_utils.py
        stopwatch_utils.py
        time_utils.py
      string/
        csv_utils.py
      path.py
      README.md
    __init__.py
    exports.py
  HIRING.md
tests/
  cli/
    mcp/
      test_basic_integration.py
      test_server_startup.py
      test_simple_integration.py
  integration/
    codegen/
      test_placeholder.py
  shared/
    utils/
      normalize.py
      recursion.py
    README.md
  unit/
    codegen/
      agents/
        test_agent.py
        test_usage_demo.py
      test_cli_basic.py
      test_top_level_imports.py
  conftest.py
.gitignore
.pre-commit-config.yaml
.watchmanconfig
CLA.md
CONTRIBUTING.md
hatch.toml
install-hooks.sh
LICENSE
package.json
pyproject.toml
QUICK_START_LOGGING.md
README.md
renovate.json5
ruff.toml
ty.toml</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".claude/settings.local.json">{
	&quot;permissions&quot;: {
		&quot;allow&quot;: [
			&quot;mcp__codegen-tools__linear_get_teams&quot;,
			&quot;mcp__codegen-tools__linear_search_issues&quot;,
			&quot;mcp__codegen-tools__linear_create_issue&quot;
		],
		&quot;deny&quot;: [],
		&quot;ask&quot;: []
	}
}</file><file path=".github/actions/release-pypi/action.yml">name: &quot;Release PyPI&quot;
description: &quot;Release PyPI&quot;
inputs:
  pypi-token:
    required: true
    description: &quot;PyPI token&quot;
runs:
  using: &quot;composite&quot;
  steps:
    - name: Release PyPI
      shell: bash
      run: |
        export UV_PUBLISH_PASSWORD=&quot;${{ inputs.pypi-token }}&quot;
        export UV_PUBLISH_USERNAME=&quot;__token__&quot;
        uv publish --publish-url https://upload.pypi.org/legacy/</file><file path=".github/actions/release-slack-bot/action.yml">name: &quot;Release Slack Bot&quot;
description: &quot;Release Slack Bot&quot;
inputs:
  release-tag:
    required: true
    description: &quot;Release tag&quot;
  slack-token:
    required: true
    description: &quot;Slack token&quot;
runs:
  using: &quot;composite&quot;
  steps:
    # TODO: use python exec instead
    - uses: slackapi/slack-github-action@v2.1.0
      with:
        method: chat.postMessage
        token: ${{ inputs.slack-token }}
        payload: |
          username: ${{ job.status == &apos;success&apos; &amp;&amp; format(&apos;Released codegen@{0}&apos;, inputs.release-tag) || format(&apos;Failed to release codegen@{0}&apos;, inputs.release-tag) }}
          channel: &quot;#release&quot;
          icon_emoji: &quot;${{ job.status == &apos;success&apos; &amp;&amp; &apos;:white_check_mark:&apos; || &apos;:x:&apos; }}&quot;
          text: |
            Actor: `${{ github.triggering_actor }}`
            Author: `${{ github.event.head_commit.author.username }}`
            ${{ format(&apos;Commit: &lt;{0}/{1}/commit/{2}|{1}@{2}&gt;&apos;, github.server_url, github.repository, github.sha) || &apos;&apos;}}
            View &lt;${{ format(&apos;{0}/{1}/releases/tag/{2}&apos;, github.server_url, github.repository, inputs.release-tag) }}|Github Release&gt;
            View &lt;${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|GHA logs&gt;</file><file path=".github/actions/report/action.yml">name: report
description: &quot;Publish Test Reports&quot;
inputs:
  flag:
    required: true
    description: &quot;Relevant codecov flag&quot;
  codecov_token:
    required: true
    description: &quot;Codecov token&quot;
runs:
  using: &quot;composite&quot;
  steps:
      - name: Upload test results to Codecov
        if: ${{ !cancelled() }}
        uses: codecov/test-results-action@v1
        with:
          token: ${{ inputs.codecov_token }}
          files: build/test-results/test/TEST.xml
      - name: Upload coverage reports to Codecov
        if: (success() || failure()) # always upload coverage reports even if the tests fail
        continue-on-error: true
        uses: codecov/codecov-action@v5.4.3
        with:
          token: ${{ inputs.codecov_token }}
          files: coverage.xml
          flags: ${{ inputs.flag }}
          plugins: pycoverage,compress-pycoverage</file><file path=".github/actions/run-ats/action.yml">name: &apos;Run ATS&apos;
description: &apos;Run Automated Test Selection to determine which tests to run&apos;

inputs:
  default_tests:
    description: &apos;Default test path to run&apos;
    required: true
  codecov_static_token:
    description: &apos;Codecov static token&apos;
    required: true
  codecov_token:
    description: &apos;Codecov token&apos;
    required: true
  collect_args:
    description: &apos;Additional arguments for test collection&apos;
    required: false
    default: &apos;&apos;
  ats_collect_args:
    description: &apos;Additional arguments for ATS collection&apos;
    required: false
    default: &apos;&apos;
  codecov_flags:
    description: &apos;Flags for codecov upload&apos;
    required: true

runs:
  using: &quot;composite&quot;
  steps:
    - name: Run ATS
      shell: bash
      env:
        BASE_SHA: ${{ github.event_name == &apos;pull_request&apos; &amp;&amp; github.event.pull_request.base.sha || github.event.before }}
        DEFAULT_TESTS: ${{ inputs.default_tests }}
        CODECOV_STATIC_TOKEN: ${{ inputs.codecov_static_token }}
        CODECOV_TOKEN: ${{ inputs.codecov_token }}
        COLLECT_ARGS: ${{ inputs.collect_args }}
        ATS_COLLECT_ARGS: ${{ inputs.ats_collect_args }}
      run: |
        uv run codecovcli create-commit -t ${{ inputs.codecov_token }}
        uv run codecovcli create-report -t ${{ inputs.codecov_token }}
        bash .github/actions/run-ats/ats.sh

    - name: Run tests
      shell: bash
      run: |
        TESTS_TO_RUN=$(cat codecov_ats/tests_to_run.txt)
        if [ -z &quot;$TESTS_TO_RUN&quot; ]; then
          echo &quot;No tests to run, skipping...&quot;
          exit 0
        fi
        echo $TESTS_TO_RUN | xargs uv run --frozen pytest --cov \
          -o junit_suite_name=&quot;${{ github.job }}&quot; \
          -n auto \
          -vv \
          --cov-append \
          ${{ inputs.collect_args }}

    - uses: ./.github/actions/report
      with:
        flag: ${{ inputs.codecov_flags }}
        codecov_token: ${{ inputs.codecov_token }}</file><file path=".github/actions/run-ats/ats.sh">#!/usr/bin/env bash
if ! command -v jq &amp;&gt; /dev/null; then
    apt update
    apt install jq -y
fi
export PATH=$PATH:$HOME/.local/bin
echo &quot;Git fetch&quot;
git fetch
echo &quot;Creating commit&quot;
uv run --frozen codecovcli create-commit -t ${CODECOV_TOKEN}
echo &quot;Creating report&quot;
uv run --frozen codecovcli create-report -t ${CODECOV_TOKEN}
echo &quot;Running static analysis&quot;
uv run --frozen codecovcli static-analysis --token ${CODECOV_STATIC_TOKEN} --folders-to-exclude .venv
ATS_COLLECT_ARGS=&quot;${ATS_COLLECT_ARGS}${DEFAULT_TESTS},&quot;
echo &quot;Label analysis with base sha: ${BASE_SHA} and default tests: ${ATS_COLLECT_ARGS}&quot;
runner_param=&quot;collect_tests_options=${ATS_COLLECT_ARGS}&quot;

# Always get last 10 commits as fallback options, starting with BASE_SHA if provided
base_commit_candidates=($(git log --format=%H | sed -n &quot;1,10p&quot;))
if [[ -n ${BASE_SHA} ]]; then
    # Prepend BASE_SHA to the candidates list if it&apos;s provided
    base_commit_candidates=(&quot;${BASE_SHA}&quot; &quot;${base_commit_candidates[@]}&quot;)
fi

for base_commit in ${base_commit_candidates[@]}
do
    echo &quot;Attempting label analysis with base commit: $base_commit&quot;
    response=$(uv run --frozen codecovcli label-analysis --token ${CODECOV_STATIC_TOKEN} --base-sha=$base_commit --dry-run --dry-run-format=&quot;json&quot; --runner-param &quot;$runner_param&quot; --max-wait-time=30 || true)
    if [[ -n $response ]]; then
        break
    else
        echo &quot;-&gt; Attempt failed&quot;
    fi
done

if [[ -z $response ]]; then
    echo &quot;Failed to run label analysis with any base commit.&quot;
fi

mkdir codecov_ats
jq &lt;&lt;&lt; &quot;$response&quot; &apos;.runner_options + .ats_tests_to_run | .[1:] | map(gsub(&quot;\&quot;&quot;; &quot;&quot;)) | join(&quot; &quot;)&apos; --raw-output &gt; codecov_ats/tests_to_run.txt
jq &lt;&lt;&lt; &quot;$response&quot; &apos;.runner_options + .ats_tests_to_skip | .[1:] | map(gsub(&quot;\&quot;&quot;; &quot;&quot;)) | join(&quot; &quot;)&apos; --raw-output &gt; codecov_ats/tests_to_skip.txt
testcount() { jq &lt;&lt;&lt; &quot;$response&quot; &quot;.$1 | length - 1&quot;; }
run_count=$(testcount ats_tests_to_run)
skip_count=$(testcount ats_tests_to_skip)
echo &quot;Run count: $run_count&quot;
echo &quot;Skip count: $skip_count&quot;
if [ ! -s codecov_ats/tests_to_run.txt ]; then
    echo &quot;No tests to run, collecting from default tests&quot;
    PYTEST_ARGS=&quot;${COLLECT_ARGS} ${DEFAULT_TESTS}&quot;
    echo &quot;Using args: ${PYTEST_ARGS}&quot;
    TESTS_TO_RUN=$(PYTEST_ARGS=${PYTEST_ARGS} ./.github/actions/run-ats/collect.sh)
    echo &quot;${TESTS_TO_RUN}&quot; &gt; codecov_ats/tests_to_run.txt
    run_count=1
    echo &quot;Added ${TESTS_TO_RUN} as fallback. New run count: $run_count&quot;
fi</file><file path=".github/actions/run-ats/collect.sh">#!/usr/bin/env bash
TESTS_TO_RUN=$(uv run --frozen pytest --collect-only ${PYTEST_ARGS} -q --disable-warnings --no-summary --no-header)
TESTS_TO_RUN=$(echo &quot;${TESTS_TO_RUN}&quot; | head -n -2)
echo $TESTS_TO_RUN</file><file path=".github/actions/setup-environment/action.yml">name: &quot;Setup Environment&quot;
description: &quot;Setup Environment&quot;
inputs:
  python-version:
    required: false
    description: &quot;Python version to use&quot;
    default: &quot;3.13&quot;
runs:
  using: &quot;composite&quot;
  steps:
    - name: Install UV
      uses: astral-sh/setup-uv@v5.4
      id: setup-uv
      with:
        enable-cache: true
        prune-cache: false
        python-version: ${{ inputs.python-version }}
        version: &apos;0.5.24&apos;
        cache-suffix: ${{inputs.python-version}}

    - name: Install dependencies
      shell: bash
      run: |
        uv sync --frozen --all-extras

    - name: Install codecov
      shell: bash
      run: |
        uv tool install codecov-cli@10.0.1
        uv tool update-shell</file><file path=".github/actions/setup-oss-repos/action.yml">name: &quot;Setup OSS repos (disabled)&quot;
description: &quot;OSS repos setup has been disabled&quot;
runs:
  using: &quot;composite&quot;
  steps:
    - name: Skip OSS repos setup
      shell: bash
      run: echo &quot;OSS repos setup is disabled&quot;</file><file path=".github/workflows/auto-release.yml">name: Auto-Release
on:
  push:
    branches:
      - develop

jobs:
  semantic-version:
    name: Semantic version
    runs-on: ubuntu-latest
    outputs:
      release-tag: ${{ steps.semantic.outputs.git-tag }}
    permissions:
      checks: read # to wait for required checks
      contents: write # to be able to publish a GitHub release
      issues: write # to be able to comment on released issues
      pull-requests: write # to be able to comment on released pull requests
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # TODO(CG-10743): clean-up once we remove LFS
      - name: Remove pre-push hook
        run: rm -f .git/hooks/pre-push

      - name: Wait for required checks
        uses: poseidon/wait-for-status-checks@v0.6.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          match_pattern: &quot;(unit-tests|integration-tests)&quot;

      - uses: codfish/semantic-release-action@v3
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



  release:
    if: ${{ needs.semantic-version.outputs.release-tag }}
    needs: semantic-version
    uses: ./.github/workflows/release.yml
    permissions:
      contents: write
    secrets: inherit
    with:
      release-tag: ${{ needs.semantic-version.outputs.release-tag }}</file><file path=".github/workflows/cache-delete.yml">name: Cleanup caches by a branch
on:
  pull_request:
    types:
      - closed

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup
        run: |
          gh extension install actions/gh-actions-cache

          echo &quot;Fetching list of cache key&quot;
          cacheKeysForPR=$(gh actions-cache list -R $REPO -B $BRANCH -L 100 | cut -f 1 )

          ## Setting this to not fail the workflow while deleting cache keys.
          set +e
          echo &quot;Deleting caches...&quot;
          for cacheKey in $cacheKeysForPR
          do
              gh actions-cache delete $cacheKey -R $REPO -B $BRANCH --confirm
          done
          echo &quot;Done&quot;
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          BRANCH: refs/pull/${{ github.event.pull_request.number }}/merge</file><file path=".github/workflows/pre-commit.yml">name: pre-commit

on:
  pull_request:
    branches:
      - &quot;develop&quot;
  push:
    branches:
      - &quot;develop&quot;

jobs:
  pre-commit:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      REPO_SCOPED_TOKEN: ${{ secrets.REPO_SCOPED_TOKEN }}

    steps:
      - name: Check out the repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ env.REPO_SCOPED_TOKEN || github.token }}

      - name: Setup environment
        uses: ./.github/actions/setup-environment

      - name: Setup-pre-commit
        run: uv tool install pre-commit --with pre-commit-uv --force-reinstall

      - uses: actions/cache@v4
        with:
          path: ~/.cache/pre-commit
          key: pre-commit|${{ env.pythonLocation }}|${{ hashFiles(&apos;.pre-commit-config.yaml&apos;) }}
          restore-keys: pre-commit

      - run: uv run --frozen pre-commit run --show-diff-on-failure --color=always --all-files --source ${{ github.event.pull_request.base.sha || github.event.before }} --origin ${{ github.event.pull_request.head.sha || github.event.after }}
        shell: bash

      # Temporarily disabled to prevent infinite loop with version updates
      # - uses: stefanzweifel/git-auto-commit-action@v5
      #   if: ${{ always() &amp;&amp; env.REPO_SCOPED_TOKEN &amp;&amp; github.event_name == &apos;pull_request&apos; }}
      #   with:
      #     commit_message: &quot;Automated pre-commit update&quot;
      #     push_options: &quot;--no-verify&quot;</file><file path=".github/workflows/release.yml">name: Build &amp; Release

on:
  workflow_call:
    inputs:
      release-tag:
        required: true
        type: string
        description: Tag to release
  # TODO(CG-10758): create if it does not exist
  # workflow_dispatch:
  #   inputs:
  #     tag:
  #       required: true
  #       type: string
  #       description: Tag to release
  push:
    tags:
      - v*
  pull_request:
    branches:
      - develop

permissions:
  contents: read

jobs:
  build:
    name: Build Pure Python Wheel
    runs-on: ubuntu-latest
    steps:
      - name: Github context
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: echo &quot;$GITHUB_CONTEXT&quot;

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.release-tag || github.event.pull_request.head.ref || github.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name || github.event.repository.full_name }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5.4
        id: setup-uv
        with:
          enable-cache: true
          prune-cache: false
          python-version: &quot;3.12&quot;  # Use single Python version for building
          version: &apos;0.5.24&apos;

      - name: Fetch tags
        if: ${{ inputs.release-tag || startsWith(github.ref, &apos;refs/tags/&apos;) }}
        run: |
          git branch
          git fetch --depth=1 origin +refs/tags/*:refs/tags/*

      - name: Build wheel
        run: |
          uv build --wheel --out-dir dist/

      - uses: actions/upload-artifact@v4
        with:
          name: wheels
          path: ./dist/*.whl

  release:
    if: ${{ inputs.release-tag || startsWith(github.ref, &apos;refs/tags/&apos;) }}
    needs: build
    runs-on: ubuntu-latest
    environment: release
    permissions:
      contents: write # grants permission to create a release on github
    steps:
      - uses: actions/checkout@v4

      - name: Setup backend
        uses: ./.github/actions/setup-environment

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist
          merge-multiple: true
          pattern: wheels

      - name: Release PyPI
        uses: ./.github/actions/release-pypi
        with:
          pypi-token: ${{ secrets.PYPI_TOKEN }}

      - name: Github release
        id: github-release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.release-tag || github.ref_name }}
          files: dist/*
          fail_on_unmatched_files: true
          generate_release_notes: ${{ startsWith(github.ref, &apos;refs/tags/&apos;) }}

      - name: Slack notification
        if: always()
        uses: ./.github/actions/release-slack-bot
        with:
          release-tag: ${{ inputs.release-tag || github.ref_name }}
          slack-token: ${{ secrets.SLACK_BOT_TOKEN }}</file><file path=".github/workflows/test.yml">name: Tests

on:
  push:
    branches:
      - &quot;develop&quot;
  pull_request_target:
    types: [ opened, synchronize, reopened, labeled ]
    branches:
      - &quot;develop&quot;
  workflow_dispatch:

jobs:
  access-check:
    runs-on: ubuntu-latest
    steps:
      - name: Check if codegen bot
        id: check-bot
        run: |
          if [[ &quot;${{ github.triggering_actor }}&quot; == &quot;codegen-sh[bot]&quot; ]]; then
            echo &quot;is_bot=true&quot; &gt;&gt; $GITHUB_OUTPUT
          else
            echo &quot;is_bot=false&quot; &gt;&gt; $GITHUB_OUTPUT
          fi

      - uses: actions-cool/check-user-permission@v2
        if: steps.check-bot.outputs.is_bot == &apos;false&apos;
        with:
          require: write
          username: ${{ github.triggering_actor }}
          error-if-missing: true

  unit-tests:
    needs: access-check
    runs-on: ubuntu-latest-8
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup environment
        uses: ./.github/actions/setup-environment

      - name: Test with pytest
        timeout-minutes: 5
        run: |
          uv run pytest \
            -n auto \
            --cov src \
            --timeout 15 \
            -o junit_suite_name=&quot;${{github.job}}&quot; \
            tests/unit

      - uses: ./.github/actions/report
        with:
          flag: unit-tests
          codecov_token: ${{ secrets.CODECOV_TOKEN }}

  codemod-tests:
    needs: access-check
    # TODO: re-enable when this check is a develop required check
    if: false
    runs-on: ubuntu-latest-32
    strategy:
      matrix:
        sync_graph: [ true, false ]
        size: [ small, large ]
        exclude:
          # Exclude large codemod tests when not needed
          - size: ${{(contains(github.event.pull_request.labels.*.name, &apos;big-codemod-tests&apos;) || github.event_name == &apos;push&apos; || github.event_name == &apos;workflow_dispatch&apos;) &amp;&amp; &apos;kevin&apos; || &apos;large&apos;}}
          - size: large
            sync_graph: true
    concurrency:
      group: ${{ github.workflow }}-${{github.ref}}-${{matrix.sync_graph}}-${{matrix.size}}-${{github.event_name == &apos;push&apos;&amp;&amp; github.sha}}
      cancel-in-progress: true
    name: &quot;Codemod tests ${{matrix.size}}: Sync Graph=${{matrix.sync_graph}}&quot;
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup environment
        uses: ./.github/actions/setup-environment

      - name: Cache oss-repos
        uses: ./.github/actions/setup-oss-repos

      - name: Run ATS and Tests
        uses: ./.github/actions/run-ats
        timeout-minutes: 15
        with:
          default_tests: &quot;tests/integration/codemod/test_codemods.py&quot;
          codecov_static_token: ${{ secrets.CODECOV_STATIC_TOKEN }}
          codecov_token: ${{ secrets.CODECOV_TOKEN }}
          collect_args: &quot;--size=${{matrix.size}} --sync-graph=${{matrix.sync_graph}}&quot;
          ats_collect_args: &quot;--size=${{matrix.size}},--sync-graph=${{matrix.sync_graph}},&quot;
          codecov_flags: codemod-tests-${{matrix.size}}-${{matrix.sync_graph}}
        env:
          GITHUB_WORKSPACE: $GITHUB_WORKSPACE



  integration-tests:
    needs: access-check
    runs-on: ubuntu-latest-16
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup environment
        uses: ./.github/actions/setup-environment

      - name: Test with pytest
        timeout-minutes: 5
        env:
          GITHUB_WORKSPACE: $GITHUB_WORKSPACE
          GITHUB_TOKEN: ${{ secrets.GHA_PAT }}
        run: |
          uv run pytest \
            -n auto \
            -o junit_suite_name=&quot;${{github.job}}&quot; \
            tests/integration/codegen

      - uses: ./.github/actions/report
        with:
          flag: integration-tests
          codecov_token: ${{ secrets.CODECOV_TOKEN }}</file><file path=".github/workflows/ty.yml">name: Ty Type Checks

on:
  pull_request:
    branches:
      - &quot;develop&quot;

concurrency:
  group: ${{ github.workflow_ref }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  ty:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup environment
        uses: ./.github/actions/setup-environment

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v46.0.3

      - name: Filter Python files
        id: filter-python
        run: |
          python_files=()
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            if [[ $file == *.py ]]; then
              python_files+=(&quot;${file}&quot;)
            fi
          done
          echo &quot;python_files=${python_files[*]}&quot; &gt;&gt; $GITHUB_ENV

      - name: Run ty
        if: ${{ env.python_files != &apos;&apos; }}
        run: |
          echo &quot;Running ty on changed files: ${{ env.python_files }}&quot;
          uv run ty check --output-format concise --python-version 3.12 --exclude &quot;**/tests/**&quot; --exclude &quot;**/codegen_tests/**&quot; ${{ env.python_files }}</file><file path=".github/codecov.yml">codecov:
  branch: develop
  max_report_age: &apos;12h&apos;
component_management:
  default_rules:  # default rules that will be inherited by all components
    statuses:
      - type: project # in this case every component that doens&apos;t have a status defined will have a project type one
        threshold: 0 # Shouldn&apos;t remove coverage
  individual_components:
    - component_id: codegen-sdk-python  # this is an identifier that should not be changed
      name: codegen-sdk-python  # this is a display name, and can be changed freely
      paths:
        - src/codegen/sdk/python/**
      statuses:
        - type: project # in this case every component that doens&apos;t have a status defined will have a project type one
          threshold: 0 # Shouldn&apos;t remove coverage
        - type: patch
          target: 50 # Language specific featues must be 100% covered
      flags:
        - unit-tests
    - component_id: codegen-sdk-typescript
      name: codegen-sdk-typescript
      paths:
        - src/codegen/sdk/typescript/**
      statuses:
        - type: project # in this case every component that doens&apos;t have a status defined will have a project type one
          threshold: 0 # Shouldn&apos;t remove coverage
        - type: patch
          target: 50 # Language specific featues must be 100% covered
      flags:
        - unit-tests
    - component_id: codegen-sdk-core
      name: codegen-sdk-core
      paths:
        - src/codegen/sdk/**
      flags:
        - unit-tests

flag_management:
  default_rules:
    carryforward: true
    carryforward_mode: &apos;labels&apos;
    statuses:
      - type: project
  individual_flags:
    - name: unit-tests
      carryforward: true
      carryforward_mode: &apos;labels&apos;
      statuses:
        - type: &apos;project&apos;
        - type: &apos;patch&apos;
    - name: codemod-tests
      carryforward: true
      carryforward_mode: &apos;labels&apos;
    - name: integration-tests
      carryforward: true
      carryforward_mode: &apos;labels&apos;
comment:
  layout: &quot;condensed_header, condensed_files&quot;
  hide_project_coverage: true
cli:
  plugins:
    pycoverage:
      report_type: &apos;json&apos;
      include_contexts: true
  runners:
    pytest:
      coverage_root: &quot;./&quot;
      execute_tests_options:
        - &quot;cov-report=xml&quot;
        - &quot;--verbose&quot;
        - &quot;-n=auto&quot;
      python_path: &quot;.venv/bin/python&quot;</file><file path=".github/CODEOWNERS">* @codegen-sh/codegen-sdk @codegen-team
**/skills @codegen-sh/capabilities @codegen-team @codegen-sh/capabilities
**/code_generation @codegen-sh/codegen-sdk @codegen-team</file><file path=".github/dependabot.yml"># To get started with Dependabot version updates, you&apos;ll need to specify which
# package ecosystems to update and where the package manifests are located.
# Please see the documentation for all configuration options:
# https://docs.github.com/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file

version: 2
updates:
  - package-ecosystem: &quot;pip&quot; # See documentation for possible values
    directory: &quot;/&quot; # Location of package manifests
    schedule:
      interval: &quot;weekly&quot;

  - package-ecosystem: &quot;npm&quot; # See documentation for possible values
    directory: &quot;/&quot; # Location of package manifests
    schedule:
      interval: &quot;weekly&quot;</file><file path=".github/pull_request_template.md"># Motivation

&lt;!-- Why is this change necessary? --&gt;

# Content

&lt;!-- Please include a summary of the change --&gt;

# Testing

&lt;!-- How was the change tested? --&gt;

# Please check the following before marking your PR as ready for review

- [ ] I have added tests for my changes
- [ ] I have updated the documentation or added new documentation as needed</file><file path=".github/release.yml">changelog:
  categories:
    - title: BREAKING CHANGES! ðŸš¨
      labels:
        - breaking-change
        - unburdened by what has been
    - title: Other Changes
      labels:
        - &quot;*&quot;</file><file path="docs/agents/create-agent-run.mdx">---
openapi: post /v1/organizations/{org_id}/agent/run
---</file><file path="docs/agents/get-agent-run.mdx">---
openapi: get /v1/organizations/{org_id}/agent/run/{agent_run_id}
---</file><file path="docs/api-reference/agent-run-logs.mdx">---
title: &quot;Retrieving Traces&quot;
sidebarTitle: &quot;Retrieving Traces&quot;
icon: &quot;list&quot;
iconType: &quot;solid&quot;
---

The Agent Run Logs API allows you to retrieve detailed execution logs for agent runs, providing insights into the agent&apos;s thought process, tool usage, and execution flow.

## Endpoint

```
GET /v1/organizations/{org_id}/agent/run/{agent_run_id}/logs
```

## Authentication

This endpoint requires API token authentication. Include your token in the Authorization header:

```bash
Authorization: Bearer YOUR_API_TOKEN
```

## Parameters

| Parameter      | Type    | Required | Description                                               |
| -------------- | ------- | -------- | --------------------------------------------------------- |
| `org_id`       | integer | Yes      | Your organization ID                                      |
| `agent_run_id` | integer | Yes      | The ID of the agent run to retrieve logs for              |
| `skip`         | integer | No       | Number of logs to skip for pagination (default: 0)        |
| `limit`        | integer | No       | Maximum number of logs to return (default: 100, max: 100) |

## Response Structure

The endpoint returns an `AgentRunWithLogsResponse` object containing the agent run details and paginated logs:

```json
{
  &quot;id&quot;: 12345,
  &quot;organization_id&quot;: 67890,
  &quot;status&quot;: &quot;completed&quot;,
  &quot;created_at&quot;: &quot;2024-01-15T10:30:00Z&quot;,
  &quot;web_url&quot;: &quot;https://app.codegen.com/agent/trace/12345&quot;,
  &quot;result&quot;: &quot;Task completed successfully&quot;,
  &quot;logs&quot;: [
    {
      &quot;agent_run_id&quot;: 12345,
      &quot;created_at&quot;: &quot;2024-01-15T10:30:15Z&quot;,
      &quot;tool_name&quot;: &quot;ripgrep_search&quot;,
      &quot;message_type&quot;: &quot;ACTION&quot;,
      &quot;thought&quot;: &quot;I need to search for the user&apos;s function in the codebase&quot;,
      &quot;observation&quot;: {
        &quot;status&quot;: &quot;success&quot;,
        &quot;results&quot;: [&quot;Found 3 matches...&quot;]
      },
      &quot;tool_input&quot;: {
        &quot;query&quot;: &quot;function getUserData&quot;,
        &quot;file_extensions&quot;: [&quot;.js&quot;, &quot;.ts&quot;]
      },
      &quot;tool_output&quot;: {
        &quot;matches&quot;: 3,
        &quot;files&quot;: [&quot;src/user.js&quot;, &quot;src/api.ts&quot;]
      }
    }
  ],
  &quot;total_logs&quot;: 25,
  &quot;page&quot;: 1,
  &quot;size&quot;: 100,
  &quot;pages&quot;: 1
}
```

## Agent Run Log Fields

Each log entry in the `logs` array contains the following fields:

### Core Fields

| Field          | Type    | Description                                               |
| -------------- | ------- | --------------------------------------------------------- |
| `agent_run_id` | integer | The ID of the agent run this log belongs to               |
| `created_at`   | string  | ISO 8601 timestamp when the log entry was created         |
| `message_type` | string  | The type of log entry (see [Log Types](#log-types) below) |

### Agent Reasoning Fields

| Field     | Type           | Description                                                     |
| --------- | -------------- | --------------------------------------------------------------- |
| `thought` | string \| null | The agent&apos;s internal reasoning or thought process for this step |

### Tool Execution Fields

| Field         | Type                     | Description                                                                    |
| ------------- | ------------------------ | ------------------------------------------------------------------------------ |
| `tool_name`   | string \| null           | Name of the tool being executed (e.g., &quot;ripgrep_search&quot;, &quot;file_write&quot;)         |
| `tool_input`  | object \| null           | JSON object containing the parameters passed to the tool                       |
| `tool_output` | object \| null           | JSON object containing the tool&apos;s execution results                            |
| `observation` | object \| string \| null | The agent&apos;s observation of the tool execution results or other contextual data |

## Log Types

The `message_type` field indicates the type of log entry. Here are the possible values:

### Plan Agent Types

| Type                        | Description                                                         |
| --------------------------- | ------------------------------------------------------------------- |
| `ACTION`                    | The agent is executing a tool or taking an action                   |
| `PLAN_EVALUATION`           | The agent is evaluating or updating its plan                        |
| `FINAL_ANSWER`              | The agent is providing its final response or conclusion             |
| `ERROR`                     | An error occurred during execution                                  |
| `USER_MESSAGE`              | A message from the user (e.g., interruptions or additional context) |
| `USER_GITHUB_ISSUE_COMMENT` | A comment from a GitHub issue that the agent is processing          |

### PR Agent Types

| Type                    | Description                                        |
| ----------------------- | -------------------------------------------------- |
| `INITIAL_PR_GENERATION` | The agent is generating the initial pull request   |
| `DETECT_PR_ERRORS`      | The agent is detecting errors in a pull request    |
| `FIX_PR_ERRORS`         | The agent is fixing errors found in a pull request |
| `PR_CREATION_FAILED`    | Pull request creation failed                       |
| `PR_EVALUATION`         | The agent is evaluating a pull request             |

### Commit Agent Types

| Type                | Description                     |
| ------------------- | ------------------------------- |
| `COMMIT_EVALUATION` | The agent is evaluating commits |

### Link Types

| Type             | Description                         |
| ---------------- | ----------------------------------- |
| `AGENT_RUN_LINK` | A link to another related agent run |

## Field Population Patterns

Different log types populate different fields:

### ACTION Logs

- Always have: `tool_name`, `tool_input`, `tool_output`
- Often have: `thought`, `observation`
- Example: Tool executions like searching code, editing files, creating PRs

### PLAN_EVALUATION Logs

- Always have: `thought`
- May have: `observation`
- Rarely have: Tool-related fields
- Example: Agent reasoning about next steps

### ERROR Logs

- Always have: `observation` (containing error details)
- May have: `tool_name` (if error occurred during tool execution)
- Example: Failed tool executions or system errors

### FINAL_ANSWER Logs

- Always have: `observation` (containing the final response)
- May have: `thought`
- Example: Agent&apos;s final response to the user

## Usage Examples

### Basic Log Retrieval

```python
import requests

url = &quot;https://api.codegen.com/v1/organizations/67890/agent/run/12345/logs&quot;
headers = {&quot;Authorization&quot;: &quot;Bearer YOUR_API_TOKEN&quot;}

response = requests.get(url, headers=headers)
data = response.json()

print(f&quot;Agent run status: {data[&apos;status&apos;]}&quot;)
print(f&quot;Total logs: {data[&apos;total_logs&apos;]}&quot;)

for log in data[&apos;logs&apos;]:
    print(f&quot;[{log[&apos;created_at&apos;]}] {log[&apos;message_type&apos;]}: {log[&apos;thought&apos;]}&quot;)
```

### Filtering by Log Type

```python
# Get only ACTION logs to see tool executions
action_logs = [log for log in data[&apos;logs&apos;] if log[&apos;message_type&apos;] == &apos;ACTION&apos;]

for log in action_logs:
    print(f&quot;Tool: {log[&apos;tool_name&apos;]}&quot;)
    print(f&quot;Input: {log[&apos;tool_input&apos;]}&quot;)
    print(f&quot;Output: {log[&apos;tool_output&apos;]}&quot;)
    print(&quot;---&quot;)
```

### Pagination Example

```python
# Get logs in batches of 50
skip = 0
limit = 50
all_logs = []

while True:
    url = f&quot;https://api.codegen.com/v1/organizations/67890/agent/run/12345/logs?skip={skip}&amp;limit={limit}&quot;
    response = requests.get(url, headers=headers)
    data = response.json()

    all_logs.extend(data[&apos;logs&apos;])

    if len(data[&apos;logs&apos;]) &lt; limit:
        break  # No more logs

    skip += limit

print(f&quot;Retrieved {len(all_logs)} total logs&quot;)
```

### Debugging Failed Runs

```python
# Find error logs to debug issues
error_logs = [log for log in data[&apos;logs&apos;] if log[&apos;message_type&apos;] == &apos;ERROR&apos;]

for error_log in error_logs:
    print(f&quot;Error at {error_log[&apos;created_at&apos;]}: {error_log[&apos;observation&apos;]}&quot;)
    if error_log[&apos;tool_name&apos;]:
        print(f&quot;Failed tool: {error_log[&apos;tool_name&apos;]}&quot;)
```

## Common Use Cases

### 1. Building Monitoring Dashboards

Use the logs to create dashboards showing:

- Agent execution progress
- Tool usage patterns
- Error rates and types
- Execution timelines

### 2. Debugging Agent Behavior

Analyze logs to understand:

- Why an agent made certain decisions
- Where errors occurred in the execution flow
- What tools were used and their results

### 3. Audit and Compliance

Track agent actions for:

- Code change auditing
- Compliance reporting
- Security monitoring

### 4. Performance Analysis

Monitor:

- Tool execution times
- Common failure patterns
- Agent reasoning efficiency

## Rate Limits

- **60 requests per 60 seconds** per API token
- Rate limits are shared across all API endpoints

## Error Responses

| Status Code | Description                                 |
| ----------- | ------------------------------------------- |
| 400         | Bad Request - Invalid parameters            |
| 401         | Unauthorized - Invalid or missing API token |
| 403         | Forbidden - Insufficient permissions        |
| 404         | Not Found - Agent run not found             |
| 429         | Too Many Requests - Rate limit exceeded     |

## Feedback and Support

Since this endpoint is in ALPHA, we&apos;d love your feedback! Please reach out through:

- [Community Slack](https://join.slack.com/t/codegen-community/shared_invite/zt-2p4xjjzjx-1~3tTbJWZWQUYOLAhvG5rA)
- [GitHub Issues](https://github.com/codegen-sh/codegen-sdk/issues)
- Email: support@codegen.com

&lt;Note&gt;
  The structure and fields of this API may change as we gather feedback and
  improve the service. We&apos;ll provide advance notice of any breaking changes.
&lt;/Note&gt;</file><file path="docs/api-reference/authentication.mdx">---
title: &quot;Authentication&quot;
sidebarTitle: &quot;Authentication&quot;
icon: &quot;key&quot;
---

All Codegen API endpoints require authentication using Bearer tokens. You&apos;ll need both an API token and your organization ID to get started.

## Get Your Credentials

&lt;Card
  title=&quot;Get API Token &amp; Organization ID&quot;
  icon=&quot;key&quot;
  href=&quot;https://codegen.com/token&quot;
&gt;
  Visit the developer settings to generate your API token and find your
  organization ID.
&lt;/Card&gt;

## Required Information

### API Token

Your personal API token authenticates all requests to the Codegen API. This token is tied to your user account and inherits your permissions within organizations.

### Organization ID

Most API endpoints require an organization ID to specify which organization&apos;s resources you want to access. You can find your organization ID in the developer settings.

## Using Your Credentials

### REST API

Include your API token in the Authorization header for all requests:

```bash
curl -H &quot;Authorization: Bearer YOUR_API_TOKEN&quot; \
  &quot;https://api.codegen.com/v1/organizations/YOUR_ORG_ID/agent/run&quot;
```

### Python SDK

The Python SDK makes authentication simple:

```python
from codegen import Agent

# Initialize with your credentials
agent = Agent(org_id=&quot;YOUR_ORG_ID&quot;, token=&quot;YOUR_API_TOKEN&quot;)

# The SDK handles authentication automatically
task = agent.run(prompt=&quot;Fix the bug in user authentication&quot;)
```</file><file path="docs/api-reference/github-actions.mdx">---
title: &quot;GitHub Actions Integration&quot;
sidebarTitle: &quot;GitHub Actions&quot;
icon: &quot;github&quot;
---

Integrate Codegen with GitHub Actions to automate code reviews, issue triage, and other development workflows. This guide shows you how to use the Codegen Python SDK within GitHub Actions workflows.

&lt;Note&gt;
  This approach is necessary because GitHub webhooks don&apos;t fire for bot users, preventing direct `@codegen` mentions in automated workflows. Using GitHub Actions with the Codegen API provides a reliable alternative.
&lt;/Note&gt;

## Prerequisites

Before setting up GitHub Actions with Codegen, ensure you have:

- A GitHub repository with Actions enabled
- A Codegen account with API access
- Your organization ID and API token from [codegen.com/developer](https://codegen.com/developer)
- The Codegen GitHub App installed on your repository

## Basic Setup

### 1. Store Your Credentials

Add your Codegen credentials as GitHub repository secrets:

1. Go to your repository â†’ Settings â†’ Secrets and variables â†’ Actions
2. Add the following secrets:
   - `CODEGEN_ORG_ID`: Your organization ID from codegen.com/developer
   - `CODEGEN_API_TOKEN`: Your API token from codegen.com/developer

### 2. Create a GitHub Actions Workflow

Create `.github/workflows/codegen-review.yml` in your repository:

```yaml
name: Codegen PR Review

on:
  pull_request:
    types: [opened, synchronize]
    branches: [main, develop]

jobs:
  codegen-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: &apos;3.11&apos;

      - name: Install Codegen SDK
        run: |
          pip install codegen

      - name: Run Codegen Review
        env:
          CODEGEN_ORG_ID: ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_API_TOKEN: ${{ secrets.CODEGEN_API_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python .github/scripts/codegen_review.py
```

### 3. Create the Review Script

Create `.github/scripts/codegen_review.py`:

```python
import os
import sys
from codegen.agents.agent import Agent

def main():
    # Get environment variables
    org_id = os.getenv(&apos;CODEGEN_ORG_ID&apos;)
    api_token = os.getenv(&apos;CODEGEN_API_TOKEN&apos;)
    github_token = os.getenv(&apos;GITHUB_TOKEN&apos;)
    
    if not all([org_id, api_token]):
        print(&quot;Error: Missing required environment variables&quot;)
        sys.exit(1)
    
    # Get PR information from GitHub context
    pr_number = os.getenv(&apos;GITHUB_EVENT_PATH&apos;)
    repo_name = os.getenv(&apos;GITHUB_REPOSITORY&apos;)
    
    # Initialize Codegen agent
    agent = Agent(
        org_id=org_id,
        token=api_token
    )
    
    # Create review prompt
    prompt = f&quot;&quot;&quot;
    Please review PR #{pr_number} in repository {repo_name}.
    
    Focus on:
    - Code quality and best practices
    - Potential bugs or security issues
    - Performance considerations
    - Documentation and testing
    
    Provide specific, actionable feedback with line-by-line comments where appropriate.
    &quot;&quot;&quot;
    
    try:
        # Run the agent
        task = agent.run(prompt=prompt)
        
        # Wait for completion (with timeout)
        max_attempts = 30  # 5 minutes with 10-second intervals
        attempt = 0
        
        while attempt &lt; max_attempts:
            task.refresh()
            print(f&quot;Task status: {task.status}&quot;)
            
            if task.status == &quot;completed&quot;:
                print(&quot;âœ… Review completed successfully!&quot;)
                if hasattr(task, &apos;result&apos;) and task.result:
                    print(f&quot;Result: {task.result}&quot;)
                break
            elif task.status == &quot;failed&quot;:
                print(&quot;âŒ Review failed&quot;)
                sys.exit(1)
            
            attempt += 1
            time.sleep(10)
        
        if attempt &gt;= max_attempts:
            print(&quot;â° Review timed out&quot;)
            sys.exit(1)
            
    except Exception as e:
        print(f&quot;Error running Codegen review: {e}&quot;)
        sys.exit(1)

if __name__ == &quot;__main__&quot;:
    main()
```

## Advanced Configuration

### Conditional Reviews

Only run reviews for specific conditions:

```yaml
name: Conditional Codegen Review

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  check-conditions:
    runs-on: ubuntu-latest
    outputs:
      should-review: ${{ steps.check.outputs.should-review }}
    steps:
      - name: Check if review needed
        id: check
        run: |
          # Skip if PR is from dependabot
          if [[ &quot;${{ github.actor }}&quot; == &quot;dependabot[bot]&quot; ]]; then
            echo &quot;should-review=false&quot; &gt;&gt; $GITHUB_OUTPUT
          # Skip if PR is a draft
          elif [[ &quot;${{ github.event.pull_request.draft }}&quot; == &quot;true&quot; ]]; then
            echo &quot;should-review=false&quot; &gt;&gt; $GITHUB_OUTPUT
          # Skip if PR has &quot;skip-review&quot; label
          elif [[ &quot;${{ contains(github.event.pull_request.labels.*.name, &apos;skip-review&apos;) }}&quot; == &quot;true&quot; ]]; then
            echo &quot;should-review=false&quot; &gt;&gt; $GITHUB_OUTPUT
          else
            echo &quot;should-review=true&quot; &gt;&gt; $GITHUB_OUTPUT
          fi

  codegen-review:
    needs: check-conditions
    if: needs.check-conditions.outputs.should-review == &apos;true&apos;
    runs-on: ubuntu-latest
    # ... rest of the job
```

### Custom Review Types

Create different review workflows for different scenarios:

```python
# .github/scripts/codegen_security_review.py
def security_review():
    prompt = f&quot;&quot;&quot;
    Perform a security-focused review of PR #{pr_number} in {repo_name}.
    
    Look specifically for:
    - SQL injection vulnerabilities
    - XSS vulnerabilities
    - Authentication/authorization issues
    - Sensitive data exposure
    - Insecure dependencies
    
    Provide detailed security recommendations.
    &quot;&quot;&quot;
    # ... rest of implementation

# .github/scripts/codegen_performance_review.py
def performance_review():
    prompt = f&quot;&quot;&quot;
    Analyze PR #{pr_number} in {repo_name} for performance implications.
    
    Focus on:
    - Database query efficiency
    - Memory usage patterns
    - CPU-intensive operations
    - Caching opportunities
    - Scalability concerns
    
    Suggest specific optimizations.
    &quot;&quot;&quot;
    # ... rest of implementation
```

### Error Handling and Retries

Implement robust error handling:

```python
import time
import logging
from typing import Optional

def run_with_retry(agent: Agent, prompt: str, max_retries: int = 3) -&gt; Optional[str]:
    &quot;&quot;&quot;Run agent with retry logic and proper error handling.&quot;&quot;&quot;
    
    for attempt in range(max_retries):
        try:
            task = agent.run(prompt=prompt)
            
            # Wait for completion with exponential backoff
            max_wait_time = 300  # 5 minutes
            check_interval = 10
            total_wait = 0
            
            while total_wait &lt; max_wait_time:
                task.refresh()
                logging.info(f&quot;Attempt {attempt + 1}: Task status: {task.status}&quot;)
                
                if task.status == &quot;completed&quot;:
                    return task.result if hasattr(task, &apos;result&apos;) else &quot;Review completed&quot;
                elif task.status == &quot;failed&quot;:
                    raise Exception(f&quot;Task failed: {getattr(task, &apos;error&apos;, &apos;Unknown error&apos;)}&quot;)
                
                time.sleep(check_interval)
                total_wait += check_interval
            
            raise Exception(&quot;Task timed out&quot;)
            
        except Exception as e:
            logging.error(f&quot;Attempt {attempt + 1} failed: {e}&quot;)
            if attempt == max_retries - 1:
                raise
            time.sleep(2 ** attempt)  # Exponential backoff
    
    return None
```

## Environment-Specific Workflows

### Development Environment

```yaml
# .github/workflows/codegen-dev-review.yml
name: Codegen Dev Review

on:
  pull_request:
    types: [opened, synchronize]
    branches: [develop, feature/*]

jobs:
  dev-review:
    runs-on: ubuntu-latest
    steps:
      # ... setup steps
      - name: Run Development Review
        env:
          CODEGEN_ORG_ID: ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_API_TOKEN: ${{ secrets.CODEGEN_API_TOKEN }}
          REVIEW_TYPE: &quot;development&quot;
        run: |
          python .github/scripts/codegen_review.py --type development
```

### Production Environment

```yaml
# .github/workflows/codegen-prod-review.yml
name: Codegen Production Review

on:
  pull_request:
    types: [opened, synchronize]
    branches: [main, master]

jobs:
  prod-review:
    runs-on: ubuntu-latest
    steps:
      # ... setup steps
      - name: Run Production Review
        env:
          CODEGEN_ORG_ID: ${{ secrets.CODEGEN_ORG_ID }}
          CODEGEN_API_TOKEN: ${{ secrets.CODEGEN_API_TOKEN }}
          REVIEW_TYPE: &quot;production&quot;
        run: |
          python .github/scripts/codegen_review.py --type production --strict
```

## Best Practices

### Security

- **Never commit API tokens**: Always use GitHub Secrets
- **Use least privilege**: Create dedicated API tokens with minimal required permissions
- **Rotate tokens regularly**: Update API tokens periodically
- **Monitor usage**: Track API usage to detect anomalies

### Performance

- **Set appropriate timeouts**: Don&apos;t let workflows run indefinitely
- **Use caching**: Cache Python dependencies to speed up workflow execution
- **Parallel execution**: Run multiple review types in parallel when possible
- **Rate limiting**: Respect API rate limits to avoid throttling

### Reliability

- **Implement retries**: Handle transient failures gracefully
- **Add logging**: Include detailed logging for debugging
- **Fail gracefully**: Don&apos;t block PRs if reviews fail
- **Monitor workflows**: Set up alerts for workflow failures

## Troubleshooting

### Common Issues

**Issue**: &quot;No repos found in the organization&quot;
```
Solution: Verify your organization ID is correct and the repository 
is accessible to your Codegen organization.
```

**Issue**: &quot;Authentication failed&quot;
```
Solution: Check that your API token is valid and properly set in 
GitHub Secrets. Tokens may expire and need renewal.
```

**Issue**: &quot;Task timeout&quot;
```
Solution: Increase the timeout duration or break large PRs into 
smaller chunks. Complex reviews may take longer to complete.
```

**Issue**: &quot;Workflow not triggering&quot;
```
Solution: Check the workflow triggers and ensure the PR meets 
the specified conditions (branch names, PR types, etc.).
```

### Debugging

Enable debug logging in your workflow:

```yaml
- name: Run Codegen Review
  env:
    CODEGEN_DEBUG: &quot;true&quot;
    CODEGEN_LOG_LEVEL: &quot;DEBUG&quot;
  run: |
    python .github/scripts/codegen_review.py
```

Add debug output to your Python script:

```python
import logging

logging.basicConfig(
    level=logging.DEBUG if os.getenv(&apos;CODEGEN_DEBUG&apos;) else logging.INFO,
    format=&apos;%(asctime)s - %(levelname)s - %(message)s&apos;
)

logger = logging.getLogger(__name__)
```

## Examples

### Complete Working Example

Here&apos;s a complete, production-ready workflow:

&lt;Card title=&quot;View Complete Example&quot; icon=&quot;github&quot; href=&quot;https://github.com/codegen-sh/codegen-examples/tree/main/github-actions&quot;&gt;
  See a full working example with all files and configurations in our examples repository.
&lt;/Card&gt;

### Integration with Existing CI/CD

Integrate Codegen reviews with your existing CI/CD pipeline:

```yaml
name: CI/CD with Codegen

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
      - name: Run tests
        run: npm test

  codegen-review:
    needs: tests  # Only run review if tests pass
    if: success()
    runs-on: ubuntu-latest
    steps:
      # ... Codegen review steps

  deploy:
    needs: [tests, codegen-review]
    if: success() &amp;&amp; github.ref == &apos;refs/heads/main&apos;
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: npm run deploy
```

## Next Steps

- Explore the [Codegen API Reference](/api-reference) for advanced usage
- Check out [example workflows](https://github.com/codegen-sh/codegen-examples) in our examples repository
- Join our [Slack community](https://community.codegen.com) for support and best practices
- Consider [enterprise features](https://codegen.com/enterprise) for advanced workflow management</file><file path="docs/api-reference/openapi3.json">{
  &quot;openapi&quot;: &quot;3.1.0&quot;,
  &quot;info&quot;: {
    &quot;title&quot;: &quot;Developer API&quot;,
    &quot;description&quot;: &quot;API for application developers&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;
  },
  &quot;servers&quot;: [
    {
      &quot;url&quot;: &quot;https://api.codegen.com&quot;,
      &quot;description&quot;: &quot;Codegen API&quot;
    }
  ],
  &quot;paths&quot;: {
    &quot;/v1/organizations/{org_id}/users&quot;: {
      &quot;get&quot;: {
        &quot;tags&quot;: [
          &quot;users&quot;,
          &quot;users&quot;,
          &quot;users&quot;
        ],
        &quot;summary&quot;: &quot;Get Users&quot;,
        &quot;description&quot;: &quot;Get users for the specified organization.\n\nReturns a paginated list of all users that belong to the specified organization.\nResults include user details such as name, email, GitHub username, and avatar.\nUse pagination parameters to control the number of results returned.\n\nRate limit: 60 requests per 30 seconds.&quot;,
        &quot;operationId&quot;: &quot;get_users_v1_organizations__org_id__users_get&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;skip&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;minimum&quot;: 0,
              &quot;default&quot;: 0,
              &quot;title&quot;: &quot;Skip&quot;
            }
          },
          {
            &quot;name&quot;: &quot;limit&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;maximum&quot;: 100,
              &quot;minimum&quot;: 1,
              &quot;default&quot;: 100,
              &quot;title&quot;: &quot;Limit&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/Page_UserResponse_&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/users/{user_id}&quot;: {
      &quot;get&quot;: {
        &quot;tags&quot;: [
          &quot;users&quot;,
          &quot;users&quot;,
          &quot;users&quot;
        ],
        &quot;summary&quot;: &quot;Get User&quot;,
        &quot;description&quot;: &quot;Get details for a specific user in an organization.\n\nReturns detailed information about a user within the specified organization.\nThe requesting user must be a member of the organization to access this endpoint.\n\nRate limit: 60 requests per 30 seconds.&quot;,
        &quot;operationId&quot;: &quot;get_user_v1_organizations__org_id__users__user_id__get&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;user_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;User Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/UserResponse&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;404&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/UserNotFoundErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Not Found&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/users/me&quot;: {
      &quot;get&quot;: {
        &quot;tags&quot;: [
          &quot;users&quot;,
          &quot;users&quot;,
          &quot;users&quot;
        ],
        &quot;summary&quot;: &quot;Get Current User Info&quot;,
        &quot;description&quot;: &quot;Get current user information from API token.\n\nReturns detailed information about the user associated with the provided API token.\nThis is useful for applications that need to identify the current user from their API token.\n\nRate limit: 60 requests per 30 seconds.&quot;,
        &quot;operationId&quot;: &quot;get_current_user_info_v1_users_me_get&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/UserResponse&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/agent/run&quot;: {
      &quot;post&quot;: {
        &quot;tags&quot;: [
          &quot;agents&quot;,
          &quot;agents&quot;,
          &quot;agents&quot;
        ],
        &quot;summary&quot;: &quot;Create Agent Run&quot;,
        &quot;description&quot;: &quot;Create a new agent run.\n\nCreates and initiates a long-running agent process based on the provided prompt.\nThe process will complete asynchronously, and the response contains the agent run ID\nwhich can be used to check the status later. The requesting user must be a member\nof the specified organization.\n\nThis endpoint accepts both a text prompt and an optional image file upload.\n\nRate limit: 10 requests per minute.&quot;,
        &quot;operationId&quot;: &quot;create_agent_run_v1_organizations__org_id__agent_run_post&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;requestBody&quot;: {
          &quot;required&quot;: true,
          &quot;content&quot;: {
            &quot;application/json&quot;: {
              &quot;schema&quot;: {
                &quot;$ref&quot;: &quot;#/components/schemas/CreateAgentRunInput&quot;
              }
            }
          }
        },
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AgentRunResponse&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;402&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AgentRunLimitReachedErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Payment Required&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;404&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/NoReposFoundInOrgErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Not Found&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/agent/run/{agent_run_id}&quot;: {
      &quot;get&quot;: {
        &quot;tags&quot;: [
          &quot;agents&quot;,
          &quot;agents&quot;,
          &quot;agents&quot;
        ],
        &quot;summary&quot;: &quot;Get Agent Run&quot;,
        &quot;description&quot;: &quot;Retrieve the status and result of an agent run.\n\nReturns the current status, progress, and any available results for the specified agent run.\nThe agent run must belong to the specified organization. If the agent run is still in progress,\nthis endpoint can be polled to check for completion.\n\nRate limit: 60 requests per 30 seconds.&quot;,
        &quot;operationId&quot;: &quot;get_agent_run_v1_organizations__org_id__agent_run__agent_run_id__get&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;agent_run_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Agent Run Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AgentRunResponse&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;404&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AgentRunNotFoundErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Not Found&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/agent/runs&quot;: {
      &quot;get&quot;: {
        &quot;tags&quot;: [
          &quot;agents&quot;,
          &quot;agents&quot;,
          &quot;agents&quot;
        ],
        &quot;summary&quot;: &quot;List Agent Runs&quot;,
        &quot;description&quot;: &quot;List agent runs for an organization with optional user filtering.\n\nReturns a paginated list of agent runs for the specified organization.\nOptionally filter by user_id to get only agent runs initiated by a specific user.\nResults are ordered by creation date (newest first).\n\nRate limit: 60 requests per 30 seconds.&quot;,
        &quot;operationId&quot;: &quot;list_agent_runs_v1_organizations__org_id__agent_runs_get&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;user_id&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;anyOf&quot;: [
                {
                  &quot;type&quot;: &quot;integer&quot;
                },
                {
                  &quot;type&quot;: &quot;null&quot;
                }
              ],
              &quot;description&quot;: &quot;Filter by user ID who initiated the agent runs&quot;,
              &quot;title&quot;: &quot;User Id&quot;
            },
            &quot;description&quot;: &quot;Filter by user ID who initiated the agent runs&quot;
          },
          {
            &quot;name&quot;: &quot;source_type&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;anyOf&quot;: [
                {
                  &quot;$ref&quot;: &quot;#/components/schemas/ApiAgentRunSourceType&quot;
                },
                {
                  &quot;type&quot;: &quot;null&quot;
                }
              ],
              &quot;description&quot;: &quot;Filter by source type of the agent runs&quot;,
              &quot;title&quot;: &quot;Source Type&quot;
            },
            &quot;description&quot;: &quot;Filter by source type of the agent runs&quot;
          },
          {
            &quot;name&quot;: &quot;skip&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;minimum&quot;: 0,
              &quot;default&quot;: 0,
              &quot;title&quot;: &quot;Skip&quot;
            }
          },
          {
            &quot;name&quot;: &quot;limit&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;maximum&quot;: 100,
              &quot;minimum&quot;: 1,
              &quot;default&quot;: 100,
              &quot;title&quot;: &quot;Limit&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/Page_AgentRunResponse_&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/agent/run/resume&quot;: {
      &quot;post&quot;: {
        &quot;tags&quot;: [
          &quot;agents&quot;,
          &quot;agents&quot;,
          &quot;agents&quot;
        ],
        &quot;summary&quot;: &quot;Resume Agent Run&quot;,
        &quot;description&quot;: &quot;Resume a paused agent run.\n\nResumes a paused agent run, allowing it to continue processing.\n\nNote: Setup commands agents are automatically routed to their dedicated resume function.&quot;,
        &quot;operationId&quot;: &quot;resume_agent_run_v1_organizations__org_id__agent_run_resume_post&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;requestBody&quot;: {
          &quot;required&quot;: true,
          &quot;content&quot;: {
            &quot;application/json&quot;: {
              &quot;schema&quot;: {
                &quot;$ref&quot;: &quot;#/components/schemas/ResumeAgentRunInput&quot;
              }
            }
          }
        },
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AgentRunResponse&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;404&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AgentRunNotFoundErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Not Found&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/agent/run/ban&quot;: {
      &quot;post&quot;: {
        &quot;tags&quot;: [
          &quot;agents&quot;,
          &quot;agents&quot;,
          &quot;agents&quot;
        ],
        &quot;summary&quot;: &quot;Ban All Checks For Agent Run&quot;,
        &quot;description&quot;: &quot;Ban all checks for a PR and stop all related agents.\n\nThis endpoint:\n1. Flags the PR to prevent future CI/CD check suite events from being processed\n2. Stops all current agents for that PR&quot;,
        &quot;operationId&quot;: &quot;ban_all_checks_for_agent_run_v1_organizations__org_id__agent_run_ban_post&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;requestBody&quot;: {
          &quot;required&quot;: true,
          &quot;content&quot;: {
            &quot;application/json&quot;: {
              &quot;schema&quot;: {
                &quot;$ref&quot;: &quot;#/components/schemas/StopAgentRunInput&quot;
              }
            }
          }
        },
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {}
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;404&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AgentRunNotFoundErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Not Found&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/agent/run/unban&quot;: {
      &quot;post&quot;: {
        &quot;tags&quot;: [
          &quot;agents&quot;,
          &quot;agents&quot;,
          &quot;agents&quot;
        ],
        &quot;summary&quot;: &quot;Unban All Checks For Agent Run&quot;,
        &quot;description&quot;: &quot;Unban all checks for a PR.\n\nThis endpoint:\n1. Removes the ban flag from the PR to allow future CI/CD check suite events to be processed\n2. Handles both URL-based bans and parent-agent-run-based bans&quot;,
        &quot;operationId&quot;: &quot;unban_all_checks_for_agent_run_v1_organizations__org_id__agent_run_unban_post&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;requestBody&quot;: {
          &quot;required&quot;: true,
          &quot;content&quot;: {
            &quot;application/json&quot;: {
              &quot;schema&quot;: {
                &quot;$ref&quot;: &quot;#/components/schemas/StopAgentRunInput&quot;
              }
            }
          }
        },
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {}
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;404&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AgentRunNotFoundErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Not Found&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/agent/run/remove-from-pr&quot;: {
      &quot;post&quot;: {
        &quot;tags&quot;: [
          &quot;agents&quot;,
          &quot;agents&quot;,
          &quot;agents&quot;
        ],
        &quot;summary&quot;: &quot;Remove Codegen From Pr&quot;,
        &quot;description&quot;: &quot;Remove Codegen from a PR.\n\nThis endpoint performs the same action as banning all checks but with more user-friendly naming.\nIt:\n1. Flags the PR to prevent future CI/CD check suite events from being processed\n2. Stops all current agents for that PR&quot;,
        &quot;operationId&quot;: &quot;remove_codegen_from_pr_v1_organizations__org_id__agent_run_remove_from_pr_post&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;requestBody&quot;: {
          &quot;required&quot;: true,
          &quot;content&quot;: {
            &quot;application/json&quot;: {
              &quot;schema&quot;: {
                &quot;$ref&quot;: &quot;#/components/schemas/StopAgentRunInput&quot;
              }
            }
          }
        },
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {}
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;404&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AgentRunNotFoundErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Not Found&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/repos&quot;: {
      &quot;get&quot;: {
        &quot;tags&quot;: [
          &quot;repositories&quot;,
          &quot;repositories&quot;,
          &quot;repositories&quot;
        ],
        &quot;summary&quot;: &quot;Get Repositories&quot;,
        &quot;description&quot;: &quot;Get repositories for the specified organization.\n\nReturns a paginated list of all repositories that belong to the specified organization.\nResults include repository details such as name, ID, description, visibility, and setup status.\nUse pagination parameters to control the number of results returned.\n\nRate limit: 60 requests per 30 seconds.&quot;,
        &quot;operationId&quot;: &quot;get_repositories_v1_organizations__org_id__repos_get&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;skip&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;minimum&quot;: 0,
              &quot;default&quot;: 0,
              &quot;title&quot;: &quot;Skip&quot;
            }
          },
          {
            &quot;name&quot;: &quot;limit&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;maximum&quot;: 100,
              &quot;minimum&quot;: 1,
              &quot;default&quot;: 100,
              &quot;title&quot;: &quot;Limit&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/Page_RepoResponse_&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/repos/check-suite-settings&quot;: {
      &quot;get&quot;: {
        &quot;tags&quot;: [
          &quot;repositories&quot;,
          &quot;check-suite-settings&quot;
        ],
        &quot;summary&quot;: &quot;Get Check Suite Settings&quot;,
        &quot;description&quot;: &quot;Get check suite settings for a repository.&quot;,
        &quot;operationId&quot;: &quot;get_check_suite_settings_v1_organizations__org_id__repos_check_suite_settings_get&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;repo_id&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;description&quot;: &quot;Repository ID&quot;,
              &quot;title&quot;: &quot;Repo Id&quot;
            },
            &quot;description&quot;: &quot;Repository ID&quot;
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/CheckSuiteSettingsResponse&quot;
                }
              }
            }
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      },
      &quot;put&quot;: {
        &quot;tags&quot;: [
          &quot;repositories&quot;,
          &quot;check-suite-settings&quot;
        ],
        &quot;summary&quot;: &quot;Update Check Suite Settings&quot;,
        &quot;description&quot;: &quot;Update check suite settings for a repository.&quot;,
        &quot;operationId&quot;: &quot;update_check_suite_settings_v1_organizations__org_id__repos_check_suite_settings_put&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;repo_id&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;description&quot;: &quot;Repository ID&quot;,
              &quot;title&quot;: &quot;Repo Id&quot;
            },
            &quot;description&quot;: &quot;Repository ID&quot;
          }
        ],
        &quot;requestBody&quot;: {
          &quot;required&quot;: true,
          &quot;content&quot;: {
            &quot;application/json&quot;: {
              &quot;schema&quot;: {
                &quot;$ref&quot;: &quot;#/components/schemas/CheckSuiteSettingsRequest&quot;
              }
            }
          }
        },
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;type&quot;: &quot;object&quot;,
                  &quot;additionalProperties&quot;: true,
                  &quot;title&quot;: &quot;Response Update Check Suite Settings V1 Organizations  Org Id  Repos Check Suite Settings Put&quot;
                }
              }
            }
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/prs/{pr_id}&quot;: {
      &quot;patch&quot;: {
        &quot;tags&quot;: [
          &quot;pull-requests&quot;,
          &quot;pull-requests&quot;,
          &quot;pull-requests&quot;
        ],
        &quot;summary&quot;: &quot;Edit Pull Request Simple&quot;,
        &quot;description&quot;: &quot;Edit pull request properties (simple endpoint).\n\nUpdate the state of a pull request (open, closed, draft, ready_for_review).\nThis endpoint only requires the PR ID, not the repo ID.\nThe requesting user must have write permissions to the repository.\n\nRate limit: 30 requests per minute.&quot;,
        &quot;operationId&quot;: &quot;edit_pull_request_simple_v1_organizations__org_id__prs__pr_id__patch&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;pr_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Pr Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;requestBody&quot;: {
          &quot;required&quot;: true,
          &quot;content&quot;: {
            &quot;application/json&quot;: {
              &quot;schema&quot;: {
                &quot;$ref&quot;: &quot;#/components/schemas/EditPRInput&quot;
              }
            }
          }
        },
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/EditPRResponse&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/repos/{repo_id}/prs/{pr_id}&quot;: {
      &quot;patch&quot;: {
        &quot;tags&quot;: [
          &quot;pull-requests&quot;,
          &quot;pull-requests&quot;,
          &quot;pull-requests&quot;
        ],
        &quot;summary&quot;: &quot;Edit Pull Request&quot;,
        &quot;description&quot;: &quot;Edit pull request properties (RESTful endpoint).\n\nUpdate the state of a pull request (open, closed, draft, ready_for_review).\nThis endpoint requires both repo_id and pr_id for RESTful compliance.\nThe requesting user must have write permissions to the repository.\n\nRate limit: 30 requests per minute.&quot;,
        &quot;operationId&quot;: &quot;edit_pull_request_v1_organizations__org_id__repos__repo_id__prs__pr_id__patch&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;repo_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Repo Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;pr_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Pr Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;requestBody&quot;: {
          &quot;required&quot;: true,
          &quot;content&quot;: {
            &quot;application/json&quot;: {
              &quot;schema&quot;: {
                &quot;$ref&quot;: &quot;#/components/schemas/EditPRInput&quot;
              }
            }
          }
        },
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/EditPRResponse&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/integrations&quot;: {
      &quot;get&quot;: {
        &quot;tags&quot;: [
          &quot;integrations&quot;,
          &quot;integrations&quot;,
          &quot;integrations&quot;
        ],
        &quot;summary&quot;: &quot;Get Organization Integrations Endpoint&quot;,
        &quot;description&quot;: &quot;Get all integration statuses for the given organization.\n\nReturns a comprehensive overview of all integrations configured for the organization,\nincluding:\n- OAuth-based integrations (Slack, Linear, Notion, Figma, ClickUp, Jira, Sentry, Monday.com)\n- GitHub app installations\n- API key-based integrations (CircleCI)\n- Database connections (PostgreSQL)\n\nEach integration includes its current status (active/inactive), associated token/installation IDs,\nand relevant metadata such as app names, organization names, etc.\n\nRate limit: 60 requests per 30 seconds.&quot;,
        &quot;operationId&quot;: &quot;get_organization_integrations_endpoint_v1_organizations__org_id__integrations_get&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/OrganizationIntegrationsResponse&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/setup-commands/generate&quot;: {
      &quot;post&quot;: {
        &quot;tags&quot;: [
          &quot;setup-commands&quot;,
          &quot;setup-commands&quot;,
          &quot;setup-commands&quot;
        ],
        &quot;summary&quot;: &quot;Generate Setup Commands&quot;,
        &quot;description&quot;: &quot;Generate setup commands for a repository.\n\nCreates and initiates a setup command generation agent for the specified repository.\nThe agent will analyze the repository structure and generate appropriate setup commands.\n\nRate limit: 5 requests per minute.&quot;,
        &quot;operationId&quot;: &quot;generate_setup_commands_v1_organizations__org_id__setup_commands_generate_post&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;requestBody&quot;: {
          &quot;required&quot;: true,
          &quot;content&quot;: {
            &quot;application/json&quot;: {
              &quot;schema&quot;: {
                &quot;$ref&quot;: &quot;#/components/schemas/GenerateSetupCommandsInput&quot;
              }
            }
          }
        },
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/SetupCommandsResponse&quot;
                }
              }
            }
          },
          &quot;404&quot;: {
            &quot;description&quot;: &quot;Repository not found&quot;
          },
          &quot;400&quot;: {
            &quot;description&quot;: &quot;Invalid input&quot;
          },
          &quot;500&quot;: {
            &quot;description&quot;: &quot;Internal server error&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations&quot;: {
      &quot;get&quot;: {
        &quot;tags&quot;: [
          &quot;organizations&quot;,
          &quot;organizations&quot;,
          &quot;organizations&quot;
        ],
        &quot;summary&quot;: &quot;Get Organizations&quot;,
        &quot;description&quot;: &quot;Get organizations for the authenticated user.\n\nReturns a paginated list of all organizations that the authenticated user is a member of.\nResults include basic organization details such as name, ID, and membership information.\nUse pagination parameters to control the number of results returned.\n\nRate limit: 60 requests per 30 seconds.&quot;,
        &quot;operationId&quot;: &quot;get_organizations_v1_organizations_get&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;skip&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;minimum&quot;: 0,
              &quot;default&quot;: 0,
              &quot;title&quot;: &quot;Skip&quot;
            }
          },
          {
            &quot;name&quot;: &quot;limit&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;maximum&quot;: 100,
              &quot;minimum&quot;: 1,
              &quot;default&quot;: 100,
              &quot;title&quot;: &quot;Limit&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/Page_OrganizationResponse_&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/sandbox/{sandbox_id}/analyze-logs&quot;: {
      &quot;post&quot;: {
        &quot;tags&quot;: [
          &quot;sandbox&quot;,
          &quot;sandbox&quot;,
          &quot;sandbox&quot;
        ],
        &quot;summary&quot;: &quot;Analyze Sandbox Logs&quot;,
        &quot;description&quot;: &quot;Analyze sandbox setup logs using an AI agent.\n\nThis endpoint creates an AI agent that will analyze the setup logs from a sandbox,\nidentify any errors, provide insights about what went wrong, and suggest potential\nsolutions. The analysis runs asynchronously and results can be retrieved using the\nreturned agent run ID.\n\nRate limit: 5 requests per minute.&quot;,
        &quot;operationId&quot;: &quot;analyze_sandbox_logs_v1_organizations__org_id__sandbox__sandbox_id__analyze_logs_post&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;sandbox_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Sandbox Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AnalyzeLogsResponse&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;404&quot;: {
            &quot;description&quot;: &quot;Sandbox not found&quot;
          },
          &quot;400&quot;: {
            &quot;description&quot;: &quot;No logs available for analysis&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/organizations/{org_id}/cli/rules&quot;: {
      &quot;get&quot;: {
        &quot;tags&quot;: [
          &quot;cli-rules&quot;,
          &quot;cli-rules&quot;,
          &quot;cli-rules&quot;
        ],
        &quot;summary&quot;: &quot;Get Cli Rules&quot;,
        &quot;description&quot;: &quot;Get organization and user rules for CLI applications.\n\nThis endpoint is designed for CLI applications that need to fetch both organization-specific\nrules and user-specific custom prompts that are used in prompts. This includes:\n\n- Organization rules: Same as MCP organization_rules prompt and agent prompt builders\n- User custom prompt: Same as MCP user_custom_prompt and agent prompt builders\n\nReturns the rules and prompts that should be followed by AI agents.\n\nRate limit: 30 requests per minute.&quot;,
        &quot;operationId&quot;: &quot;get_cli_rules_v1_organizations__org_id__cli_rules_get&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/CLIRulesResponse&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/slack-connect/generate-token&quot;: {
      &quot;post&quot;: {
        &quot;tags&quot;: [
          &quot;slack-connect&quot;,
          &quot;slack-connect&quot;
        ],
        &quot;summary&quot;: &quot;Generate Slack Connect Token Endpoint&quot;,
        &quot;description&quot;: &quot;Generate a temporary token for Slack account connection.\n\nThis token:\n- Expires in 10 minutes\n- Can only be used once\n- Must be sent to the Codegen bot in a DM with format: \&quot;Connect my account: {token}\&quot;&quot;,
        &quot;operationId&quot;: &quot;generate_slack_connect_token_endpoint_v1_slack_connect_generate_token_post&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;requestBody&quot;: {
          &quot;required&quot;: true,
          &quot;content&quot;: {
            &quot;application/json&quot;: {
              &quot;schema&quot;: {
                &quot;$ref&quot;: &quot;#/components/schemas/GenerateTokenRequest&quot;
              }
            }
          }
        },
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/GenerateTokenResponse&quot;
                }
              }
            }
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    },
    &quot;/v1/alpha/organizations/{org_id}/agent/run/{agent_run_id}/logs&quot;: {
      &quot;get&quot;: {
        &quot;tags&quot;: [
          &quot;agents-alpha&quot;,
          &quot;agents-alpha&quot;,
          &quot;agents-beta&quot;
        ],
        &quot;summary&quot;: &quot;Get Agent Run Logs&quot;,
        &quot;description&quot;: &quot;Retrieve an agent run with its logs using pagination. This endpoint is currently in ALPHA and IS subject to change.\n\nReturns the agent run details along with a paginated list of logs for the specified agent run.\nThe agent run must belong to the specified organization. Logs are returned in chronological order.\nUses standard pagination parameters (skip and limit) and includes pagination metadata in the response.\n\nRate limit: 60 requests per 60 seconds.&quot;,
        &quot;operationId&quot;: &quot;get_agent_run_logs_v1_alpha_organizations__org_id__agent_run__agent_run_id__logs_get&quot;,
        &quot;parameters&quot;: [
          {
            &quot;name&quot;: &quot;agent_run_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Agent Run Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;org_id&quot;,
            &quot;in&quot;: &quot;path&quot;,
            &quot;required&quot;: true,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;title&quot;: &quot;Org Id&quot;
            }
          },
          {
            &quot;name&quot;: &quot;skip&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;minimum&quot;: 0,
              &quot;default&quot;: 0,
              &quot;title&quot;: &quot;Skip&quot;
            }
          },
          {
            &quot;name&quot;: &quot;limit&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;integer&quot;,
              &quot;maximum&quot;: 100,
              &quot;minimum&quot;: 1,
              &quot;default&quot;: 100,
              &quot;title&quot;: &quot;Limit&quot;
            }
          },
          {
            &quot;name&quot;: &quot;reverse&quot;,
            &quot;in&quot;: &quot;query&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;type&quot;: &quot;boolean&quot;,
              &quot;default&quot;: false,
              &quot;title&quot;: &quot;Reverse&quot;
            }
          },
          {
            &quot;name&quot;: &quot;authorization&quot;,
            &quot;in&quot;: &quot;header&quot;,
            &quot;required&quot;: false,
            &quot;schema&quot;: {
              &quot;title&quot;: &quot;Authorization&quot;
            }
          }
        ],
        &quot;responses&quot;: {
          &quot;200&quot;: {
            &quot;description&quot;: &quot;Successful Response&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AgentRunWithLogsResponse&quot;
                }
              }
            }
          },
          &quot;429&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/APIRateLimitErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Too Many Requests&quot;
          },
          &quot;403&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/PermissionsErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Forbidden&quot;
          },
          &quot;404&quot;: {
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/AgentRunNotFoundErrorResponse&quot;
                }
              }
            },
            &quot;description&quot;: &quot;Not Found&quot;
          },
          &quot;422&quot;: {
            &quot;description&quot;: &quot;Validation Error&quot;,
            &quot;content&quot;: {
              &quot;application/json&quot;: {
                &quot;schema&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;
                }
              }
            }
          }
        }
      }
    }
  },
  &quot;components&quot;: {
    &quot;schemas&quot;: {
      &quot;APIRateLimitErrorResponse&quot;: {
        &quot;properties&quot;: {
          &quot;message&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Message&quot;,
            &quot;default&quot;: &quot;Rate limit exceeded. Please try again later.&quot;
          },
          &quot;status_code&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Status Code&quot;,
            &quot;default&quot;: 429
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;title&quot;: &quot;APIRateLimitErrorResponse&quot;
      },
      &quot;AgentRunLimitReachedErrorResponse&quot;: {
        &quot;properties&quot;: {
          &quot;message&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Message&quot;,
            &quot;default&quot;: &quot;Alloted agent runs for the current billing plan have been reached. Please upgrade your plan to continue.&quot;
          },
          &quot;status_code&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Status Code&quot;,
            &quot;default&quot;: 402
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;title&quot;: &quot;AgentRunLimitReachedErrorResponse&quot;
      },
      &quot;AgentRunLogResponse&quot;: {
        &quot;properties&quot;: {
          &quot;agent_run_id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Agent Run Id&quot;
          },
          &quot;created_at&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Created At&quot;
          },
          &quot;tool_name&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Tool Name&quot;
          },
          &quot;message_type&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Message Type&quot;
          },
          &quot;thought&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Thought&quot;
          },
          &quot;observation&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;additionalProperties&quot;: true,
                &quot;type&quot;: &quot;object&quot;
              },
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Observation&quot;
          },
          &quot;tool_input&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;additionalProperties&quot;: true,
                &quot;type&quot;: &quot;object&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Tool Input&quot;
          },
          &quot;tool_output&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;additionalProperties&quot;: true,
                &quot;type&quot;: &quot;object&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Tool Output&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;agent_run_id&quot;
        ],
        &quot;title&quot;: &quot;AgentRunLogResponse&quot;,
        &quot;description&quot;: &quot;Represents an agent run log in API responses&quot;
      },
      &quot;AgentRunNotFoundErrorResponse&quot;: {
        &quot;properties&quot;: {
          &quot;message&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Message&quot;,
            &quot;default&quot;: &quot;Agent run not found.&quot;
          },
          &quot;status_code&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Status Code&quot;,
            &quot;default&quot;: 404
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;title&quot;: &quot;AgentRunNotFoundErrorResponse&quot;
      },
      &quot;AgentRunResponse&quot;: {
        &quot;properties&quot;: {
          &quot;id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Id&quot;
          },
          &quot;organization_id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Organization Id&quot;
          },
          &quot;status&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Status&quot;
          },
          &quot;created_at&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Created At&quot;
          },
          &quot;web_url&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Web Url&quot;
          },
          &quot;result&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Result&quot;
          },
          &quot;summary&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Summary&quot;
          },
          &quot;source_type&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;$ref&quot;: &quot;#/components/schemas/ApiAgentRunSourceType&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ]
          },
          &quot;github_pull_requests&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;items&quot;: {
                  &quot;$ref&quot;: &quot;#/components/schemas/GithubPullRequestResponse&quot;
                },
                &quot;type&quot;: &quot;array&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Github Pull Requests&quot;
          },
          &quot;metadata&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;additionalProperties&quot;: true,
                &quot;type&quot;: &quot;object&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Metadata&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;id&quot;,
          &quot;organization_id&quot;
        ],
        &quot;title&quot;: &quot;AgentRunResponse&quot;,
        &quot;description&quot;: &quot;Represents an agent run in API responses&quot;
      },
      &quot;AgentRunWithLogsResponse&quot;: {
        &quot;properties&quot;: {
          &quot;id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Id&quot;
          },
          &quot;organization_id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Organization Id&quot;
          },
          &quot;status&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Status&quot;
          },
          &quot;created_at&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Created At&quot;
          },
          &quot;web_url&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Web Url&quot;
          },
          &quot;result&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Result&quot;
          },
          &quot;metadata&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;additionalProperties&quot;: true,
                &quot;type&quot;: &quot;object&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Metadata&quot;
          },
          &quot;logs&quot;: {
            &quot;items&quot;: {
              &quot;$ref&quot;: &quot;#/components/schemas/AgentRunLogResponse&quot;
            },
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;Logs&quot;
          },
          &quot;total_logs&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;integer&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Total Logs&quot;
          },
          &quot;page&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;integer&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Page&quot;
          },
          &quot;size&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;integer&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Size&quot;
          },
          &quot;pages&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;integer&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Pages&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;id&quot;,
          &quot;organization_id&quot;,
          &quot;logs&quot;
        ],
        &quot;title&quot;: &quot;AgentRunWithLogsResponse&quot;,
        &quot;description&quot;: &quot;Represents an agent run in API responses&quot;
      },
      &quot;AnalyzeLogsResponse&quot;: {
        &quot;properties&quot;: {
          &quot;agent_run_id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Agent Run Id&quot;,
            &quot;description&quot;: &quot;The ID of the agent run analyzing the logs&quot;
          },
          &quot;status&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Status&quot;,
            &quot;description&quot;: &quot;The status of the agent run&quot;
          },
          &quot;message&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Message&quot;,
            &quot;description&quot;: &quot;Information about the analysis process&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;agent_run_id&quot;,
          &quot;status&quot;,
          &quot;message&quot;
        ],
        &quot;title&quot;: &quot;AnalyzeLogsResponse&quot;
      },
      &quot;ApiAgentRunSourceType&quot;: {
        &quot;type&quot;: &quot;string&quot;,
        &quot;enum&quot;: [
          &quot;LOCAL&quot;,
          &quot;SLACK&quot;,
          &quot;GITHUB&quot;,
          &quot;GITHUB_CHECK_SUITE&quot;,
          &quot;GITHUB_PR_REVIEW&quot;,
          &quot;LINEAR&quot;,
          &quot;API&quot;,
          &quot;CHAT&quot;,
          &quot;JIRA&quot;,
          &quot;CLICKUP&quot;,
          &quot;MONDAY&quot;,
          &quot;SETUP_COMMANDS&quot;
        ],
        &quot;title&quot;: &quot;ApiAgentRunSourceType&quot;
      },
      &quot;CLIRulesResponse&quot;: {
        &quot;properties&quot;: {
          &quot;organization_rules&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Organization Rules&quot;
          },
          &quot;user_custom_prompt&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;User Custom Prompt&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;organization_rules&quot;,
          &quot;user_custom_prompt&quot;
        ],
        &quot;title&quot;: &quot;CLIRulesResponse&quot;,
        &quot;description&quot;: &quot;Response model for CLI rules containing organization and user rules.&quot;
      },
      &quot;CheckSuiteSettingsRequest&quot;: {
        &quot;properties&quot;: {
          &quot;check_retry_count&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;integer&quot;,
                &quot;maximum&quot;: 10.0,
                &quot;minimum&quot;: 0.0
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Check Retry Count&quot;,
            &quot;description&quot;: &quot;Global retry count for failed checks&quot;
          },
          &quot;ignored_checks&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;items&quot;: {
                  &quot;type&quot;: &quot;string&quot;
                },
                &quot;type&quot;: &quot;array&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Ignored Checks&quot;,
            &quot;description&quot;: &quot;List of check names to ignore&quot;
          },
          &quot;check_retry_counts&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;additionalProperties&quot;: {
                  &quot;type&quot;: &quot;integer&quot;
                },
                &quot;type&quot;: &quot;object&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Check Retry Counts&quot;,
            &quot;description&quot;: &quot;Per-check retry counts&quot;
          },
          &quot;custom_prompts&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;additionalProperties&quot;: {
                  &quot;type&quot;: &quot;string&quot;
                },
                &quot;type&quot;: &quot;object&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Custom Prompts&quot;,
            &quot;description&quot;: &quot;Custom prompts per check&quot;
          },
          &quot;high_priority_apps&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;items&quot;: {
                  &quot;type&quot;: &quot;string&quot;
                },
                &quot;type&quot;: &quot;array&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;High Priority Apps&quot;,
            &quot;description&quot;: &quot;Apps that trigger immediate processing on failure&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;title&quot;: &quot;CheckSuiteSettingsRequest&quot;,
        &quot;description&quot;: &quot;Request model for updating check suite settings.&quot;
      },
      &quot;CheckSuiteSettingsResponse&quot;: {
        &quot;properties&quot;: {
          &quot;check_retry_count&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Check Retry Count&quot;
          },
          &quot;ignored_checks&quot;: {
            &quot;items&quot;: {
              &quot;type&quot;: &quot;string&quot;
            },
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;Ignored Checks&quot;
          },
          &quot;check_retry_counts&quot;: {
            &quot;additionalProperties&quot;: {
              &quot;type&quot;: &quot;integer&quot;
            },
            &quot;type&quot;: &quot;object&quot;,
            &quot;title&quot;: &quot;Check Retry Counts&quot;
          },
          &quot;custom_prompts&quot;: {
            &quot;additionalProperties&quot;: {
              &quot;type&quot;: &quot;string&quot;
            },
            &quot;type&quot;: &quot;object&quot;,
            &quot;title&quot;: &quot;Custom Prompts&quot;
          },
          &quot;high_priority_apps&quot;: {
            &quot;items&quot;: {
              &quot;type&quot;: &quot;string&quot;
            },
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;High Priority Apps&quot;
          },
          &quot;available_check_suite_names&quot;: {
            &quot;items&quot;: {
              &quot;type&quot;: &quot;string&quot;
            },
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;Available Check Suite Names&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;check_retry_count&quot;,
          &quot;ignored_checks&quot;,
          &quot;check_retry_counts&quot;,
          &quot;custom_prompts&quot;,
          &quot;high_priority_apps&quot;,
          &quot;available_check_suite_names&quot;
        ],
        &quot;title&quot;: &quot;CheckSuiteSettingsResponse&quot;,
        &quot;description&quot;: &quot;Response model for check suite settings.&quot;
      },
      &quot;CreateAgentRunInput&quot;: {
        &quot;properties&quot;: {
          &quot;prompt&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Prompt&quot;
          },
          &quot;images&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;items&quot;: {
                  &quot;type&quot;: &quot;string&quot;
                },
                &quot;type&quot;: &quot;array&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Images&quot;,
            &quot;description&quot;: &quot;List of base64 encoded data URIs representing images to be processed by the agent&quot;
          },
          &quot;metadata&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;additionalProperties&quot;: true,
                &quot;type&quot;: &quot;object&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Metadata&quot;,
            &quot;description&quot;: &quot;Arbitrary JSON metadata to be stored with the agent run&quot;
          },
          &quot;repo_id&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;integer&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Repo Id&quot;,
            &quot;description&quot;: &quot;ID of the repository to use for the agent run&quot;
          },
          &quot;model&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Model&quot;,
            &quot;description&quot;: &quot;Model to use for this agent run (optional, uses org default if not specified)&quot;
          },
          &quot;agent_type&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;,
                &quot;enum&quot;: [
                  &quot;codegen&quot;,
                  &quot;claude_code&quot;
                ]
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Agent Type&quot;,
            &quot;description&quot;: &quot;Type of agent to use for this agent run (optional, uses org default if not specified)&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;prompt&quot;
        ],
        &quot;title&quot;: &quot;CreateAgentRunInput&quot;
      },
      &quot;EditPRInput&quot;: {
        &quot;properties&quot;: {
          &quot;state&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;enum&quot;: [
              &quot;open&quot;,
              &quot;closed&quot;,
              &quot;draft&quot;,
              &quot;ready_for_review&quot;
            ],
            &quot;title&quot;: &quot;State&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;state&quot;
        ],
        &quot;title&quot;: &quot;EditPRInput&quot;,
        &quot;description&quot;: &quot;Input for editing PR properties.&quot;
      },
      &quot;EditPRResponse&quot;: {
        &quot;properties&quot;: {
          &quot;success&quot;: {
            &quot;type&quot;: &quot;boolean&quot;,
            &quot;title&quot;: &quot;Success&quot;
          },
          &quot;url&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Url&quot;
          },
          &quot;number&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;integer&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Number&quot;
          },
          &quot;title&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Title&quot;
          },
          &quot;state&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;State&quot;
          },
          &quot;error&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Error&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;success&quot;
        ],
        &quot;title&quot;: &quot;EditPRResponse&quot;,
        &quot;description&quot;: &quot;Response from editing PR properties.&quot;
      },
      &quot;GenerateSetupCommandsInput&quot;: {
        &quot;properties&quot;: {
          &quot;repo_id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Repo Id&quot;
          },
          &quot;prompt&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Prompt&quot;
          },
          &quot;trigger_source&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Trigger Source&quot;,
            &quot;default&quot;: &quot;setup-commands&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;repo_id&quot;
        ],
        &quot;title&quot;: &quot;GenerateSetupCommandsInput&quot;,
        &quot;description&quot;: &quot;Input for generating setup commands.&quot;
      },
      &quot;GenerateTokenRequest&quot;: {
        &quot;properties&quot;: {
          &quot;org_id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Org Id&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;org_id&quot;
        ],
        &quot;title&quot;: &quot;GenerateTokenRequest&quot;
      },
      &quot;GenerateTokenResponse&quot;: {
        &quot;properties&quot;: {
          &quot;token&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Token&quot;
          },
          &quot;message&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Message&quot;
          },
          &quot;expires_in_minutes&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Expires In Minutes&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;token&quot;,
          &quot;message&quot;,
          &quot;expires_in_minutes&quot;
        ],
        &quot;title&quot;: &quot;GenerateTokenResponse&quot;
      },
      &quot;GithubPullRequestResponse&quot;: {
        &quot;properties&quot;: {
          &quot;id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Id&quot;
          },
          &quot;title&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Title&quot;
          },
          &quot;url&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Url&quot;
          },
          &quot;created_at&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Created At&quot;
          },
          &quot;head_branch_name&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Head Branch Name&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;id&quot;,
          &quot;created_at&quot;
        ],
        &quot;title&quot;: &quot;GithubPullRequestResponse&quot;
      },
      &quot;HTTPValidationError&quot;: {
        &quot;properties&quot;: {
          &quot;detail&quot;: {
            &quot;items&quot;: {
              &quot;$ref&quot;: &quot;#/components/schemas/ValidationError&quot;
            },
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;Detail&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;title&quot;: &quot;HTTPValidationError&quot;
      },
      &quot;IntegrationStatus&quot;: {
        &quot;properties&quot;: {
          &quot;integration_type&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Integration Type&quot;,
            &quot;description&quot;: &quot;Type of integration (e.g., &apos;github&apos;, &apos;slack&apos;, &apos;linear&apos;, etc.)&quot;
          },
          &quot;active&quot;: {
            &quot;type&quot;: &quot;boolean&quot;,
            &quot;title&quot;: &quot;Active&quot;,
            &quot;description&quot;: &quot;Whether the integration is currently active&quot;
          },
          &quot;token_id&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;integer&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Token Id&quot;,
            &quot;description&quot;: &quot;ID of the associated token, if any&quot;
          },
          &quot;installation_id&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;integer&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Installation Id&quot;,
            &quot;description&quot;: &quot;ID of the app installation, if applicable&quot;
          },
          &quot;metadata&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;additionalProperties&quot;: true,
                &quot;type&quot;: &quot;object&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Metadata&quot;,
            &quot;description&quot;: &quot;Additional metadata about the integration&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;integration_type&quot;,
          &quot;active&quot;
        ],
        &quot;title&quot;: &quot;IntegrationStatus&quot;,
        &quot;description&quot;: &quot;Status information for a single integration.&quot;
      },
      &quot;NoReposFoundInOrgErrorResponse&quot;: {
        &quot;properties&quot;: {
          &quot;message&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Message&quot;,
            &quot;default&quot;: &quot;No repos found in the organization. Please add some repos and try again.&quot;
          },
          &quot;status_code&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Status Code&quot;,
            &quot;default&quot;: 404
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;title&quot;: &quot;NoReposFoundInOrgErrorResponse&quot;
      },
      &quot;OrganizationIntegrationsResponse&quot;: {
        &quot;properties&quot;: {
          &quot;organization_id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Organization Id&quot;,
            &quot;description&quot;: &quot;ID of the organization&quot;
          },
          &quot;organization_name&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Organization Name&quot;,
            &quot;description&quot;: &quot;Name of the organization&quot;
          },
          &quot;integrations&quot;: {
            &quot;items&quot;: {
              &quot;$ref&quot;: &quot;#/components/schemas/IntegrationStatus&quot;
            },
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;Integrations&quot;,
            &quot;description&quot;: &quot;List of integration statuses&quot;
          },
          &quot;total_active_integrations&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Total Active Integrations&quot;,
            &quot;description&quot;: &quot;Total number of active integrations&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;organization_id&quot;,
          &quot;organization_name&quot;,
          &quot;integrations&quot;,
          &quot;total_active_integrations&quot;
        ],
        &quot;title&quot;: &quot;OrganizationIntegrationsResponse&quot;,
        &quot;description&quot;: &quot;Response schema for organization integrations.&quot;
      },
      &quot;OrganizationResponse&quot;: {
        &quot;properties&quot;: {
          &quot;id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Id&quot;
          },
          &quot;name&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Name&quot;
          },
          &quot;settings&quot;: {
            &quot;$ref&quot;: &quot;#/components/schemas/OrganizationSettings&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;id&quot;,
          &quot;name&quot;,
          &quot;settings&quot;
        ],
        &quot;title&quot;: &quot;OrganizationResponse&quot;,
        &quot;description&quot;: &quot;Represents an organization in API responses&quot;
      },
      &quot;OrganizationSettings&quot;: {
        &quot;properties&quot;: {
          &quot;enable_pr_creation&quot;: {
            &quot;type&quot;: &quot;boolean&quot;,
            &quot;title&quot;: &quot;Enable Pr Creation&quot;,
            &quot;default&quot;: true
          },
          &quot;enable_rules_detection&quot;: {
            &quot;type&quot;: &quot;boolean&quot;,
            &quot;title&quot;: &quot;Enable Rules Detection&quot;,
            &quot;default&quot;: true
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;title&quot;: &quot;OrganizationSettings&quot;
      },
      &quot;Page_AgentRunResponse_&quot;: {
        &quot;properties&quot;: {
          &quot;items&quot;: {
            &quot;items&quot;: {
              &quot;$ref&quot;: &quot;#/components/schemas/AgentRunResponse&quot;
            },
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;Items&quot;
          },
          &quot;total&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Total&quot;
          },
          &quot;page&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Page&quot;
          },
          &quot;size&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Size&quot;
          },
          &quot;pages&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Pages&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;items&quot;,
          &quot;total&quot;,
          &quot;page&quot;,
          &quot;size&quot;,
          &quot;pages&quot;
        ],
        &quot;title&quot;: &quot;Page[AgentRunResponse]&quot;
      },
      &quot;Page_OrganizationResponse_&quot;: {
        &quot;properties&quot;: {
          &quot;items&quot;: {
            &quot;items&quot;: {
              &quot;$ref&quot;: &quot;#/components/schemas/OrganizationResponse&quot;
            },
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;Items&quot;
          },
          &quot;total&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Total&quot;
          },
          &quot;page&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Page&quot;
          },
          &quot;size&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Size&quot;
          },
          &quot;pages&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Pages&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;items&quot;,
          &quot;total&quot;,
          &quot;page&quot;,
          &quot;size&quot;,
          &quot;pages&quot;
        ],
        &quot;title&quot;: &quot;Page[OrganizationResponse]&quot;
      },
      &quot;Page_RepoResponse_&quot;: {
        &quot;properties&quot;: {
          &quot;items&quot;: {
            &quot;items&quot;: {
              &quot;$ref&quot;: &quot;#/components/schemas/RepoResponse&quot;
            },
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;Items&quot;
          },
          &quot;total&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Total&quot;
          },
          &quot;page&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Page&quot;
          },
          &quot;size&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Size&quot;
          },
          &quot;pages&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Pages&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;items&quot;,
          &quot;total&quot;,
          &quot;page&quot;,
          &quot;size&quot;,
          &quot;pages&quot;
        ],
        &quot;title&quot;: &quot;Page[RepoResponse]&quot;
      },
      &quot;Page_UserResponse_&quot;: {
        &quot;properties&quot;: {
          &quot;items&quot;: {
            &quot;items&quot;: {
              &quot;$ref&quot;: &quot;#/components/schemas/UserResponse&quot;
            },
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;Items&quot;
          },
          &quot;total&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Total&quot;
          },
          &quot;page&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Page&quot;
          },
          &quot;size&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Size&quot;
          },
          &quot;pages&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Pages&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;items&quot;,
          &quot;total&quot;,
          &quot;page&quot;,
          &quot;size&quot;,
          &quot;pages&quot;
        ],
        &quot;title&quot;: &quot;Page[UserResponse]&quot;
      },
      &quot;PermissionsErrorResponse&quot;: {
        &quot;properties&quot;: {
          &quot;message&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Message&quot;,
            &quot;default&quot;: &quot;You do not have access to this organization.&quot;
          },
          &quot;status_code&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Status Code&quot;,
            &quot;default&quot;: 403
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;title&quot;: &quot;PermissionsErrorResponse&quot;
      },
      &quot;RepoResponse&quot;: {
        &quot;properties&quot;: {
          &quot;id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Id&quot;
          },
          &quot;name&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Name&quot;
          },
          &quot;full_name&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Full Name&quot;
          },
          &quot;description&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Description&quot;
          },
          &quot;github_id&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Github Id&quot;
          },
          &quot;organization_id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Organization Id&quot;
          },
          &quot;visibility&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Visibility&quot;
          },
          &quot;archived&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;boolean&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Archived&quot;
          },
          &quot;setup_status&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Setup Status&quot;
          },
          &quot;language&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Language&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;id&quot;,
          &quot;name&quot;,
          &quot;full_name&quot;,
          &quot;description&quot;,
          &quot;github_id&quot;,
          &quot;organization_id&quot;,
          &quot;visibility&quot;,
          &quot;archived&quot;,
          &quot;setup_status&quot;,
          &quot;language&quot;
        ],
        &quot;title&quot;: &quot;RepoResponse&quot;,
        &quot;description&quot;: &quot;Represents a repository in API responses&quot;
      },
      &quot;ResumeAgentRunInput&quot;: {
        &quot;properties&quot;: {
          &quot;agent_run_id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Agent Run Id&quot;
          },
          &quot;prompt&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Prompt&quot;
          },
          &quot;images&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;items&quot;: {
                  &quot;type&quot;: &quot;string&quot;
                },
                &quot;type&quot;: &quot;array&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Images&quot;,
            &quot;description&quot;: &quot;List of base64 encoded data URIs representing images to be processed by the agent&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;agent_run_id&quot;,
          &quot;prompt&quot;
        ],
        &quot;title&quot;: &quot;ResumeAgentRunInput&quot;
      },
      &quot;SetupCommandsResponse&quot;: {
        &quot;properties&quot;: {
          &quot;agent_run_id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Agent Run Id&quot;
          },
          &quot;status&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Status&quot;
          },
          &quot;url&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Url&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;agent_run_id&quot;,
          &quot;status&quot;,
          &quot;url&quot;
        ],
        &quot;title&quot;: &quot;SetupCommandsResponse&quot;,
        &quot;description&quot;: &quot;Response for setup commands generation.&quot;
      },
      &quot;StopAgentRunInput&quot;: {
        &quot;properties&quot;: {
          &quot;agent_run_id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Agent Run Id&quot;
          },
          &quot;before_card_order_id&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Before Card Order Id&quot;,
            &quot;description&quot;: &quot;Kanban order key of the card that should come before this agent run in the CANCELLED column&quot;
          },
          &quot;after_card_order_id&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;After Card Order Id&quot;,
            &quot;description&quot;: &quot;Kanban order key of the card that should come after this agent run in the CANCELLED column&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;agent_run_id&quot;
        ],
        &quot;title&quot;: &quot;StopAgentRunInput&quot;
      },
      &quot;UserNotFoundErrorResponse&quot;: {
        &quot;properties&quot;: {
          &quot;message&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Message&quot;,
            &quot;default&quot;: &quot;User not found.&quot;
          },
          &quot;status_code&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Status Code&quot;,
            &quot;default&quot;: 404
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;title&quot;: &quot;UserNotFoundErrorResponse&quot;
      },
      &quot;UserResponse&quot;: {
        &quot;properties&quot;: {
          &quot;id&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;title&quot;: &quot;Id&quot;,
            &quot;description&quot;: &quot;Unique user ID&quot;
          },
          &quot;email&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Email&quot;,
            &quot;description&quot;: &quot;User&apos;s email address&quot;
          },
          &quot;github_user_id&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Github User Id&quot;,
            &quot;description&quot;: &quot;GitHub user ID&quot;
          },
          &quot;github_username&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Github Username&quot;,
            &quot;description&quot;: &quot;GitHub username&quot;
          },
          &quot;avatar_url&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Avatar Url&quot;,
            &quot;description&quot;: &quot;URL to user&apos;s avatar image&quot;
          },
          &quot;full_name&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Full Name&quot;,
            &quot;description&quot;: &quot;User&apos;s full name&quot;
          },
          &quot;role&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;string&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Role&quot;,
            &quot;description&quot;: &quot;User&apos;s role in the organization (ADMIN, MANAGER, MEMBER)&quot;
          },
          &quot;is_admin&quot;: {
            &quot;anyOf&quot;: [
              {
                &quot;type&quot;: &quot;boolean&quot;
              },
              {
                &quot;type&quot;: &quot;null&quot;
              }
            ],
            &quot;title&quot;: &quot;Is Admin&quot;,
            &quot;description&quot;: &quot;Whether the user is an admin (deprecated, use role instead)&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;id&quot;,
          &quot;github_user_id&quot;,
          &quot;github_username&quot;
        ],
        &quot;title&quot;: &quot;UserResponse&quot;,
        &quot;description&quot;: &quot;Represents a user in API responses&quot;
      },
      &quot;ValidationError&quot;: {
        &quot;properties&quot;: {
          &quot;loc&quot;: {
            &quot;items&quot;: {
              &quot;anyOf&quot;: [
                {
                  &quot;type&quot;: &quot;string&quot;
                },
                {
                  &quot;type&quot;: &quot;integer&quot;
                }
              ]
            },
            &quot;type&quot;: &quot;array&quot;,
            &quot;title&quot;: &quot;Location&quot;
          },
          &quot;msg&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Message&quot;
          },
          &quot;type&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;title&quot;: &quot;Error Type&quot;
          }
        },
        &quot;type&quot;: &quot;object&quot;,
        &quot;required&quot;: [
          &quot;loc&quot;,
          &quot;msg&quot;,
          &quot;type&quot;
        ],
        &quot;title&quot;: &quot;ValidationError&quot;
      }
    }
  }
}</file><file path="docs/api-reference/overview.mdx">---
title: &quot;Codegen API&quot;
sidebarTitle: &quot;Overview&quot;
icon: &quot;code&quot;
---

The Codegen API provides programmatic access to create and manage AI agents, enabling you to integrate Codegen&apos;s capabilities into your own applications and workflows.

## What You Can Do

**[Create and manage AI agents](/api-reference/agents/create-agent-run)** that can write code, fix bugs, and handle development tasks across your repositories with full programmatic control over their execution and monitoring. **[Access your organization data](/api-reference/organizations/get-organizations)** including users, repositories, integrations, and **[programmatically retrieve detailed agent traces](/api-reference/agent-run-logs)** for analysis and debugging.

&lt;Note&gt;
  All agents created through the API are fully configurable and viewable in the
  Codegen web UI at codegen.com, allowing seamless integration between
  programmatic and manual workflows.
&lt;/Note&gt;

&lt;Tip&gt;
  Not seeing a capability you want? Get in touch! Join our [community
  Slack](https://community.codegen.com) or email us at support@codegen.com.
&lt;/Tip&gt;

## Authentication

All API endpoints require authentication using Bearer tokens and your organization ID.

&lt;Card
  title=&quot;Authentication Guide&quot;
  icon=&quot;key&quot;
  href=&quot;/api-reference/authentication&quot;
&gt;
  Get your API token and organization ID to start using the Codegen API.
&lt;/Card&gt;

## Rate Limits

The API includes rate limiting to ensure fair usage:

- **Standard endpoints**: 60 requests per 30 seconds
- **Agent creation**: 10 requests per minute
- **Setup commands**: 5 requests per minute
- **Log analysis**: 5 requests per minute

## Getting Started

### 1. Create Your First Agent Run

```bash
curl -X POST &quot;https://api.codegen.com/v1/organizations/{org_id}/agent/run&quot; \
  -H &quot;Authorization: Bearer YOUR_API_KEY&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &apos;{
    &quot;prompt&quot;: &quot;Add error handling to the user authentication function&quot;,
    &quot;repo_id&quot;: 123
  }&apos;
```

### 2. Check Agent Status

```bash
curl &quot;https://api.codegen.com/v1/organizations/{org_id}/agent/run/{agent_run_id}&quot; \
  -H &quot;Authorization: Bearer YOUR_API_KEY&quot;
```

### 3. Resume with Follow-up

```bash
curl -X POST &quot;https://api.codegen.com/v1/organizations/{org_id}/agent/run/resume&quot; \
  -H &quot;Authorization: Bearer YOUR_API_KEY&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &apos;{
    &quot;agent_run_id&quot;: 456,
    &quot;prompt&quot;: &quot;Also add unit tests for the error handling&quot;
  }&apos;
```

## Use Cases

**Automated Workflows**

- Trigger agents from CI/CD pipelines when builds fail
- Create agents in response to issue tracking system events
- Automate code reviews and quality checks

**Custom Integrations**

- Build Codegen into your existing development tools
- Create custom dashboards for agent activity
- Integrate with internal systems and workflows

**Batch Operations**

- Process multiple repositories with consistent changes
- Generate setup commands for new projects
- Analyze logs across multiple sandbox environments

## Explore the API

&lt;Card
  title=&quot;Browse API Endpoints&quot;
  icon=&quot;list&quot;
  href=&quot;/api-reference/agents/create-agent-run&quot;
&gt;
  Explore all available endpoints with detailed schemas and examples.
&lt;/Card&gt;

&lt;Card
  title=&quot;Programmatically Retrieve Agent Traces&quot;
  icon=&quot;list&quot;
  href=&quot;/api-reference/agent-run-logs&quot;
&gt;
  Learn how to retrieve and analyze detailed agent execution logs.
&lt;/Card&gt;

## SDKs and Tools

For easier integration, we recommend using our Python SDK which provides a simple wrapper around the API:

&lt;Card title=&quot;Python SDK&quot; icon=&quot;python&quot; href=&quot;/introduction/sdk&quot;&gt;
  Use the Codegen Python SDK for a pythonic interface to create and manage
  agents programmatically.
&lt;/Card&gt;

**Also available:**

- **[CLI Tool](/introduction/cli)** - Command-line interface for common API operations

&lt;Note&gt;
  The API is RESTful and returns JSON responses. All endpoints support standard
  HTTP status codes and include detailed error messages for troubleshooting.
&lt;/Note&gt;</file><file path="docs/capabilities/analytics.mdx">---
title: &quot;Analytics&quot;
sidebarTitle: &quot;Analytics&quot;
icon: &quot;chart-column&quot;
---

What impact are code agents having on your codebase (and your finances) today? How can you better deploy them across your org?
Codegen Analytics was built to answer these questions and more.

&lt;Frame caption=&quot;Cost analytics on codegen.com/analytics&quot;&gt;
  &lt;img
    src=&quot;/images/cost-breakdown.png&quot;
    alt=&quot;Analyze cost breakdown&quot;
    className=&quot;aspect-[559/334]&quot;
  /&gt;
&lt;/Frame&gt;

&lt;Card
  title=&quot;View Analytics Dashboard&quot;
  icon=&quot;chart-line&quot;
  href=&quot;https://codegen.com/analytics&quot;
&gt;
  Access detailed analytics on agent performance, costs, and team productivity.
&lt;/Card&gt;

## Key Metrics

Track the metrics that matter most for your development workflow:

- **Pull Request Analytics** - Monitor code merged, review velocity, and contributor activity
- **Agent Tool Usage** - See which tools agents use most frequently and their success rates
- **Cost Analysis** - Track spending across different models, agents, and time periods
- **Performance Insights** - Analyze agent response times and task completion rates
- **Team Activity** - Understand how different team members interact with agents

## Features

### Pull Request Tracking

- **Merge velocity** - Track how quickly PRs are created and merged
- **Author activity** - See contributor patterns and productivity trends
- **Status monitoring** - Monitor PR states and resolution times

### Detailed Filtering

- **Date range selection** - Analyze data over custom time periods
- **User-specific views** - Filter by individual team members
- **Status filtering** - Focus on specific PR states or outcomes
- **Interactive charts** - Explore data with dynamic visualizations

### Real-time Insights

- **Live dashboards** - Get up-to-date metrics on agent activity
- **Trend analysis** - Identify patterns in agent usage and effectiveness
- **Cost optimization** - Make informed decisions about model selection and usage

## Use Cases

**Performance Optimization**

- Identify which agents and tools provide the best ROI
- Optimize model selection based on cost and performance data
- Track improvement in development velocity over time

**Team Insights**

- Understand how different team members leverage AI assistance
- Identify opportunities for increased agent adoption
- Monitor the impact of agents on overall productivity

**Cost Management**

- Track spending across different LLM providers and models
- Identify high-cost operations and optimize usage patterns
- Budget and forecast AI assistance costs

&lt;Tip&gt;
  Use analytics to continuously optimize your agent workflows and demonstrate
  the value of AI assistance to your organization.
&lt;/Tip&gt;</file><file path="docs/capabilities/capabilities.mdx">---
title: &quot;How Codegen Agents Work&quot;
sidebarTitle: &quot;How it Works&quot;
icon: &quot;gear&quot;
iconType: &quot;solid&quot;
---

Codegen agents follow a simple but powerful workflow: they&apos;re triggered from your existing tools, work in secure sandboxes to implement changes, create pull requests, and then monitor and fix any issues that arise. This creates a seamless development experience that integrates naturally with your team&apos;s existing processes.

## The Agent Happy Path

Here&apos;s how Codegen agents work from start to finish:

```mermaid
graph TD
    A[Trigger from Integration] --&gt; B[Work in Remote Sandbox]
    B --&gt; C[Create Pull Request]
    C --&gt; D[Monitor CI Checks]
    D --&gt; E[Auto-fix Failed Checks]
    E --&gt; D
    D --&gt; D1[All checks pass âœ“]
    D1 --&gt; G[Ready for Review]
    G --&gt; F[Respond to Follow-up Questions]
    F --&gt; G

    A1[Slack @mention] --&gt; A
    A2[Linear issue assignment] --&gt; A
    A3[GitHub issue comment] --&gt; A
```

### 1. Users Trigger `@codegen` to Perform Tasks

Agents activate seamlessly from the platforms you already use:

- **[Slack](/integrations/slack)** - Tag `@codegen` in any channel or send a direct message
- **[Linear](/integrations/linear)** - Assign an issue to Codegen or mention it in comments
- **[Jira](/integrations/jira)** - Assign an issue to Codegen or mention it in comments
- **[ClickUp](/integrations/clickup)** - Assign a task to Codegen or mention it in comments
- **[Monday.com](/integrations/monday)** - Assign an item to Codegen or mention it in comments
- **[GitHub](/integrations/github)** - Comment on issues or PRs to request changes
- **[API](http://localhost:3001/api-reference/agents/create-agent-run)** - Programmatically trigger agents for automated workflows

### 2. `@codegen` Performs Work in Secure Sandboxes

Once triggered, agents work in **[isolated sandbox environments](/sandboxes/overview)** where they can:

- Execute code safely without affecting your systems
- Install dependencies and run tests
- Make changes and validate them before committing
- Access your repository context while maintaining security

### 3. Users Receive Completed Pull-Requests

Agents create **[GitHub pull requests](/integrations/github)** with:

- Detailed descriptions explaining the changes
- Links back to the original request (Linear issue, Slack thread, etc.)
- Clean, tested code ready for review
- Proper commit messages following your conventions

### 4. Agents Monitor and Auto-fix PR Issues

The **[Checks Auto-fixer](/capabilities/checks-autofixer)** ensures quality by:

- Monitoring CI/CD pipeline results in real-time
- Automatically analyzing build failures and test errors
- Pushing targeted fixes to resolve issues
- Retrying up to 3 times before escalating to humans

### 5. Agents Respond to Follow-ups

Agents remain active to handle questions and refinements:

- Respond to PR review comments with additional changes
- Answer questions in the original Slack thread or Linear issue
- Make adjustments based on feedback from team members
- Provide explanations of their implementation decisions

## Configuration &amp; Customization

Codegen agents can be customized to match your team&apos;s specific workflows and requirements:

### Model Selection

Choose from leading AI models and configure custom API keys to optimize performance and cost for your organization.

&lt;Card title=&quot;Model Choice&quot; icon=&quot;cpu&quot; href=&quot;/settings/model-configuration&quot;&gt;
  Select LLM providers, configure custom API keys, and optimize performance
  settings.
&lt;/Card&gt;

### Agent Behavior

Control how agents interact with users and approach code modifications to ensure they align with your team&apos;s preferences.

&lt;Card title=&quot;Agent Behavior&quot; icon=&quot;robot&quot; href=&quot;/settings/agent-behavior&quot;&gt;
  Configure plan proposals, GitHub mention requirements, and interaction
  patterns.
&lt;/Card&gt;

### Security &amp; Permissions

Define what actions agents are allowed to perform across your organization with fine-grained permission controls.

&lt;Card
  title=&quot;Agent Permissions&quot;
  icon=&quot;shield-check&quot;
  href=&quot;/settings/agent-permissions&quot;
&gt;
  Control PR creation, rules detection, and enforce security policies like
  signed commits.
&lt;/Card&gt;

&lt;Tip&gt;
  Start with conservative settings and gradually expand agent capabilities as
  your team becomes comfortable with AI assistance.
&lt;/Tip&gt;

## Learn More

Dive deeper into specific capabilities:

- **[Get started with the overview](/introduction/overview)** - Complete introduction to Codegen
- **[Explore integrations](/integrations/integrations)** - See all available platforms and tools
- **[Understand sandboxes](/sandboxes/overview)** - Learn about the secure execution environment
- **[Configure settings](/settings/settings)** - Customize agent behavior and permissions
- **[View analytics](/capabilities/analytics)** - Monitor agent performance and impact</file><file path="docs/capabilities/checks-autofixer.mdx">---
title: &quot;Check Suite Auto-fixer&quot;
sidebarTitle: &quot;Checks Auto-fixer&quot;
icon: &quot;bell&quot;
---

When GitHub checks fail on a Codegen PR, Codegen agents will automatically &quot;wake up&quot;, analyze the failure, and push fix commits.

&lt;video
  controls
  src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1757875834/4-fixing-checks_aagrki.mp4&quot;
  className=&quot;w-full aspect-[3456/2160] rounded-sm&quot;
/&gt;

This intelligent system monitors CI status and proactively resolves issues without manual intervention.

&lt;Card
  title=&quot;Configure Check Suite Auto-fixer&quot;
  icon=&quot;rocket&quot;
  href=&quot;https://codegen.com/settings/checks-autofixer&quot;
&gt;
  Configure globally at the organization level or customize settings per
  repository. Enterprise plans can adjust retry limits for optimal performance.
&lt;/Card&gt;

&lt;Tip&gt;
  Codegen will try to fix broken checks 3 times before &quot;tapping out&quot; by default.
  Enterprise customers can customize the retry count per check or per
  repository.
&lt;/Tip&gt;

## How Checks Auto-Fixer Works

Codegen continuously monitors your pull requests and automatically responds to check failures:

- **Automatic Detection:** Monitors GitHub check runs and CI status in real-time
- **Intelligent Analysis:** Analyzes build logs, test failures, and error messages to understand root causes
- **Targeted Fixes:** Generates specific code changes to resolve the identified issues
- **Persistent Retry:** Will attempt to fix issues up to 3 times per PR

## What Triggers Auto-Fixing

Check auto-fixing activates when:

- **CI Checks Fail:** Any GitHub check run reports a failure status
- **Build Errors:** Compilation, linting, or build process failures
- **Test Failures:** Unit tests, integration tests, or automated test suites fail
- **Code Quality Issues:** Static analysis tools report violations or warnings

## The Auto-Fix Process

When Codegen auto-fixes a failing PR, it follows this process:

1. **Detect Failure:** Monitor check status and identify when builds break
2. **Analyze Logs:** Grep through CI logs to understand specific failure points
3. **Generate Solution:** Create targeted code changes to resolve identified issues
4. **Apply Fix:** Automatically commit fixes to the same PR branch
5. **Re-validate:** Monitor the new check run to ensure the fix was successful

## Retry Logic

Codegen implements intelligent retry behavior:

- **Default: 3 attempts** per PR to resolve failing checks
- **Enterprise customization** - Enterprise customers can configure retry limits:
  - Set global defaults at the organization level
  - Override per repository in repository settings
  - Customize retry counts per individual check type
- **Progressive analysis** - each retry incorporates learnings from previous attempts
- **Failure escalation** - when retry limit is reached, the issue is flagged for human review

## Configuration Options

The Checks Auto-Fixer can be configured at multiple levels:

### Organization Level

- **Global settings** - Configure default behavior for all repositories
- **Available to all plans** - Enable/disable the feature organization-wide
- **Access via** - Organization Settings â†’ Checks Auto-Fixer

### Repository Level

- **Per-repo overrides** - Customize settings for specific repositories
- **Individual check control** - Enable/disable monitoring per check type
- **Custom instructions** - Provide specific guidance for handling each check
- **Access via** - Repository Settings â†’ Checks Auto-Fixer

### Enterprise Features

- **Custom retry limits** - Set retry counts globally, per repository, or per check type
- **Advanced monitoring** - Granular control over which checks to monitor
- **Priority handling** - Configure high-priority checks for immediate processing

## GitHub Integration

The auto-fix system integrates deeply with GitHub:

- **Check Run Annotations:** Creates detailed feedback with line-specific suggestions
- **PR Comments:** Adds contextual suggestions and explanations
- **Auto-Fix Actions:** Provides one-click fix buttons in the GitHub UI
- **Status Updates:** Real-time updates on fix progress and results

&lt;Note&gt;
  Checks Auto-Fixer only activates for repositories where Codegen has write
  access and the feature is enabled. It respects your repository permissions and
  team workflows.
&lt;/Note&gt;</file><file path="docs/capabilities/claude-code.mdx">---
title: &quot;Claude Code Integration&quot;
sidebarTitle: &quot;Claude Code&quot;
icon: &quot;code&quot;
---

Claude Code brings the power of Anthropic&apos;s coding assistant directly into your development workflow through Codegen. Whether you&apos;re running Claude locally or in the cloud, Codegen provides the infrastructure to enhance your AI coding experience with telemetry, integrations, and seamless deployment options.

&lt;Frame&gt;
  &lt;video
    controls
    src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1757996504/Claude_Code_Integration_coe5sm.mp4&quot;
    className=&quot;aspect-[3340/2160]&quot;
  /&gt;
&lt;/Frame&gt;

## Cloud Logging for Local Sessions

Every local Claude Code session is automatically logged to the cloud through the Codegen CLI. This seamless integration means your local development gains enterprise-grade observability without any extra configuration.

When you run Claude through `codegen`, you get:

- **Persistent history** across all your local Claude sessions
- **Searchable conversations** accessible from any device
- **Team visibility** into AI-assisted development patterns
- **Audit trails** for compliance and debugging

&lt;Note&gt;
  Sessions appear instantly at [codegen.com/agents](https://codegen.com/agents),
  making it easy to share context with teammates or continue work from another
  machine.
&lt;/Note&gt;

## Connect Claude Code to Codegen Tools

Claude Code running through Codegen automatically gains access to all your connected integrations via MCP (Model Context Protocol). This transforms Claude from a coding assistant into a full development platform orchestrator.

Your existing Codegen integrations work seamlessly:

- **Slack** - Send updates and coordinate with your team
- **Linear/Jira** - Update tickets and track progress
- **GitHub** - Create PRs and manage repositories
- **Databases** - Query and modify data safely
- **Custom tools** - Any MCP server you&apos;ve configured

No additional setup required - if it&apos;s connected to Codegen, Claude can use it.

&lt;Tip&gt;
  MCP integration means Claude can perform complex workflows like &quot;When tests
  fail, create a Linear ticket and notify the team on Slack&quot; - all in a single
  command.
&lt;/Tip&gt;

## Run Background Agents from your Terminal

Keep your terminal free while Claude handles long-running tasks. Background agents run asynchronously, perfect for automation that doesn&apos;t need constant supervision.

## Remote Sandbox Execution

Configure Claude Code as your default agent to run in Codegen&apos;s secure cloud sandboxes. This provides consistent, scalable environments for all your AI-assisted development.

&lt;Card
  title=&quot;Set Claude Code as Default&quot;
  icon=&quot;toggle-on&quot;
  href=&quot;https://codegen.com/settings/model&quot;
&gt;
  Enable Claude Code mode to run all agents in secure sandboxes with full
  integration support.
&lt;/Card&gt;

Remote execution benefits:

- **Consistent environments** across your team
- **Pre-configured tools** and dependencies
- **Scalable compute** for resource-intensive tasks
- **Security isolation** from your local machine

## Getting Started

### Local Claude with Cloud Benefits

Get up and running in three simple steps:

1. Install the Codegen CLI:

   ```bash
   uv tool install codegen
   ```

2. Authenticate with your account:

   ```bash
   codegen login
   ```

3. Run Claude with full telemetry:
   ```bash
   codegen claude &quot;Help me refactor this authentication module&quot;
   ```

Your session immediately appears in the cloud with full integration access.

&lt;Tip&gt;
  To use claude with codegen, ensure you have claude installed and available on your system.
&lt;/Tip&gt;

## Analytics and Insights

Transform your Claude Code usage into actionable intelligence. The analytics dashboard provides deep insights into how AI is transforming your development workflow.

Track key metrics:

- **Token usage** to understand costs and optimize prompts
- **Task completion rates** and success patterns
- **Integration usage** showing which tools Claude uses most
- **Team adoption** identifying power users and best practices

Access detailed analytics at [codegen.com/analytics](https://codegen.com/analytics).

&lt;Tip&gt;
  Use analytics to identify repetitive tasks that could be automated with
  background agents, maximizing your team&apos;s productivity gains.
&lt;/Tip&gt;

## What&apos;s Next

Claude Code integration is just the beginning. We&apos;re actively working on:

- OpenAI Codex support for GPT-4 workflows
- Gemini CLI integration for Google&apos;s models
- Enhanced MCP protocol features
- Custom model deployment options

Join our [community Slack](https://community.codegen.com) to stay updated and share your Claude Code workflows with other developers.</file><file path="docs/capabilities/interrupts.mdx">---
title: &quot;Interrupts&quot;
description: &quot;How Codegen handles real-time interrupts from Slack and Linear while working&quot;
icon: &quot;bolt&quot;
iconType: &quot;solid&quot;
---

## Overview

Codegen supports **real-time interrupts** that allow users to send additional messages or clarifications while the agent is actively working on a task. This feature enables dynamic, conversational interactions where users can provide feedback, corrections, or additional context without waiting for the agent to complete its current work.

## How Interrupts Work

When Codegen is actively processing a request, users can send follow-up messages through supported channels (Slack, Linear) that will be immediately delivered to the running agent as &quot;interrupt messages.&quot;

### Key Features

- **Real-time delivery**: Messages are delivered immediately to the active agent
- **Context preservation**: The agent maintains full context of the original task
- **Immediate acknowledgment**: Codegen typically responds quickly to acknowledge the interrupt
- **Seamless integration**: The agent incorporates new information into its current workflow

## Supported Channels

### Slack Interrupts

In Slack, you can send interrupt messages by:

1. **Replying in the thread** where Codegen is working
2. **Mentioning @codegen** with additional context
3. **Sending follow-up messages** in the same channel

&lt;Warning&gt;
  **Important**: You **must** mention `@codegen` in your interrupt messages for
  Codegen to respond in Slack channels, unless you&apos;re in a direct message (DM)
  with Codegen where it will respond automatically.
&lt;/Warning&gt;

**Example:**

```
User: @codegen can you fix the login bug?
Codegen: I&apos;ll fix the login bug! ðŸ”§ [starts working]
User: Actually, make sure to also handle the password reset flow
Codegen: Got it! I&apos;ll include the password reset flow in my fix ðŸ‘
```

### Linear Interrupts

In Linear, interrupts work through:

1. **Adding comments** to the issue Codegen is working on
2. **Updating the issue description** with additional requirements
3. **Changing issue priority or labels** (triggers re-evaluation)

&lt;Info&gt;
  **Note**: Codegen will respond automatically to your comments in Linear unless
  another user is tagged in the same comment.
&lt;/Info&gt;

**Example:**

```
Issue: Fix authentication system
Codegen: Working on the authentication fix...
[User adds comment]: &quot;Please also add 2FA support&quot;
Codegen: I see you&apos;ve added 2FA requirements - incorporating that now!
```

## Best Practices

### For Users

&lt;Tip&gt;
  **Send interrupts early**: If you realize you need to add context or change
  requirements, send the message immediately rather than waiting for completion.
&lt;/Tip&gt;

- **Be specific**: Clearly state what you want to add or change
- **Provide context**: Explain how the new information relates to the original request
- **Use @mentions in Slack**: Always mention @codegen in Slack channels (not needed in DMs)
- **No mentions needed in Linear**: Codegen responds automatically unless other users are tagged

### Common Use Cases

1. **Adding requirements**: &quot;Also make sure to add error handling&quot;
2. **Providing clarification**: &quot;By &apos;users&apos; I meant admin users specifically&quot;
3. **Changing scope**: &quot;Actually, let&apos;s focus on the mobile version first&quot;
4. **Sharing additional context**: &quot;Here&apos;s the error log I forgot to include&quot;
5. **Course correction**: &quot;That approach won&apos;t work, try using the new API instead&quot;

## Limitations

- **Processing order**: Interrupts are processed in the order they&apos;re received
- **Context switching**: Very frequent interrupts may slow down overall progress
- **Channel-specific**: Interrupts only work within the same channel/issue where work started

## Troubleshooting

### Interrupt Not Acknowledged

If your interrupt isn&apos;t acknowledged:

1. **Check the channel**: Ensure you&apos;re messaging in the same thread/issue
2. **Wait briefly**: The agent may be in the middle of a long operation
3. **Use @mentions in Slack**: Make sure you mentioned @codegen (required in channels, not DMs)
4. **Check for other tags in Linear**: If you tagged other users, Codegen won&apos;t respond automatically
5. **Check agent status**: The agent may have completed or encountered an error

### Message Not Incorporated

If your interrupt seems ignored:

1. **Be more explicit**: Clearly state what you want changed
2. **Reference the original task**: Connect your interrupt to the current work
3. **Follow up**: Send a clarifying message if needed

## Examples

### Slack Thread Example

```
User: @codegen create a user registration form
Codegen: I&apos;ll create a user registration form! ðŸ“ [working...]

User: Make sure it includes email verification
Codegen: Got it! Adding email verification to the registration form ðŸ“§

User: And add password strength requirements
Codegen: Perfect! I&apos;ll include password strength validation as well ðŸ”’
```

### Linear Issue Example

```
Linear Issue: &quot;Implement search functionality&quot;
Codegen: Working on search functionality...

[User adds comment]: &quot;Please include filters for date and category&quot;
Codegen: I see you&apos;ve added filter requirements - implementing date and category filters now!

[User adds comment]: &quot;Also add sorting options&quot;
Codegen: Adding sorting options to the search as well! ðŸ“Š
```

## Related Features

- [Wake-up Triggers](/capabilities/wake-up) - How to initially trigger Codegen
- [Slack Integration](/integrations/slack) - Complete Slack setup and usage
- [Linear Integration](/integrations/linear) - Complete Linear setup and usage</file><file path="docs/capabilities/pr-review.mdx">---
title: &quot;PR Review Agent&quot;
sidebarTitle: &quot;PR Review&quot;
icon: &quot;microscope&quot;
---

Codegen provides AI code review as a first-class supported feature.

&lt;Frame&gt;
  &lt;video
    controls
    src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1757981307/Reviews_lufat8.mp4&quot;
    className=&quot;aspect-[3584/2160]&quot;
  /&gt;
&lt;/Frame&gt;

&lt;Card
  title=&quot;Configure PR Reviews&quot;
  icon=&quot;microscope&quot;
  href=&quot;https://codegen.com/settings/review&quot;
&gt;
  Set up PR review at the organization level, then customize per repository.
&lt;/Card&gt;

## How It Works

When PR review is enabled on a repo, a Codegen agent will spin up to leave a detailed review.

This includes:

- **Inline comments** on specific lines with actionable feedback
- **Security scanning** for vulnerabilities and unsafe patterns
- **Code quality** suggestions for maintainability and best practices
- **Architectural feedback** on design patterns and structure

## Configuration

Configure PR reviews at two levels:

### Organization Settings

Set global defaults and organization-wide review rules at [Organization Settings â†’ PR Review](https://codegen.com/settings/review).

### Repository Settings

Override settings and add repository-specific rules at **Repository Settings â†’ Review**.

Repository rules are combined with organization rules for comprehensive coverage. You can:

- Enable/disable PR reviews for the repository
- Add custom review guidelines specific to the codebase
- Define language-specific requirements
- Set repository-specific coding standards

&lt;Tip&gt;
  Start with organization-level settings, then customize individual repositories
  as needed.
&lt;/Tip&gt;

&lt;Note&gt;
  PR reviews require read access to your repository. Enable the feature at both
  organization and repository levels to activate reviews.
&lt;/Note&gt;</file><file path="docs/capabilities/triggering-codegen.mdx">---
title: &quot;Triggering Codegen&quot;
sidebarTitle: &quot;Triggering Agents&quot;
icon: &quot;play&quot;
---

Codegen is designed to work where you work. Trigger agents from your existing tools and they&apos;ll respond right where the conversation started.

## Trigger Methods

### From Your Tools

- **[Slack](/integrations/slack)** - Mention `@codegen` in any channel or DM
- **[Linear](/integrations/linear)** - Assign issues to Codegen or mention in comments
- **[Jira](/integrations/jira)** - Assign issues to Codegen or `@mention` in comments
- **[ClickUp](/integrations/clickup)** - Assign tasks to Codegen or mention in comments
- **[Monday.com](/integrations/monday)** - Assign items to Codegen or mention in comments
- **[GitHub](/integrations/github)** - Comment on PRs or issues with `@codegen-agent`

### From Codegen

- **[Web UI](https://codegen.com/new)** - Start a new agent run directly from the dashboard
- **[CLI](/introduction/cli)** - Run `codegen agent create &quot;your task&quot;` from your terminal
- **[API](/api-reference/agents/create-agent-run)** - Trigger programmatically for automated workflows

## How Agent Context Works

### One Agent Per Context

Each context gets its own dedicated agent:

- **Slack** - Each thread is a separate agent. Follow-up messages in the same thread route to the same agent
- **Linear/Jira/ClickUp/Monday** - Each ticket is a separate agent. All comments on that ticket go to the same agent
- **GitHub** - Each issue or PR is a separate agent. All comments stay with the same agent

### Shared Context with PRs

When an agent creates a PR:

- The agent **always monitors its own PR** and responds to comments
- Agents triggered from tickets (Linear, Jira, etc.) share context between the ticket and any PRs they create
- Follow-up requests on either the ticket or PR route to the same agent
- **Automatically fixes broken tests** - When CI checks fail, the agent wakes up and pushes fix commits

&lt;Note&gt;
  This means you can start a conversation in Linear, have the agent create a PR,
  then continue the discussion on either platform - it&apos;s all the same agent with
  full context.
&lt;/Note&gt;

&lt;Tip&gt;
  Follow-up messages always go to the same agent. Whether you&apos;re continuing a
  Slack thread, commenting on a ticket, or reviewing a PR - the agent maintains
  full conversation history.
&lt;/Tip&gt;

Learn more about automatic test fixing in the **[Checks Auto-fixer](/capabilities/checks-autofixer)** documentation.

## All Agents Created Equal

No matter where you trigger from, your request:

1. Routes to a dedicated agent for that context
2. Runs in secure [sandboxes](/sandboxes/overview)
3. Has access to all your [integrations](/integrations/integrations)
4. Creates trackable runs visible at [codegen.com/agents](https://codegen.com/agents)

## Automatic Triggers

Codegen supports certain automated triggers as first-class citizens. These activate without manual intervention to maintain code quality:

- **[Checks Auto-fixer](/capabilities/checks-autofixer)** - Automatically fixes failing CI checks on agent PRs
- **[PR Review](/capabilities/pr-review)** - Provides instant code review feedback on all PRs

&lt;Note&gt;
  These automations work alongside manual triggers. An agent fixing broken tests
  can still respond to comments on its PR or the original ticket that triggered
  it.
&lt;/Note&gt;

## Learn More

&lt;CardGroup cols={2}&gt;
  &lt;Card
    title=&quot;Configure Integrations&quot;
    icon=&quot;plug&quot;
    href=&quot;/integrations/integrations&quot;
  &gt;
    Set up GitHub, Slack, and other tools
  &lt;/Card&gt;

  &lt;Card title=&quot;CLI Documentation&quot; icon=&quot;terminal&quot; href=&quot;/introduction/cli&quot;&gt;
    Trigger agents from your terminal
  &lt;/Card&gt;
  &lt;Card title=&quot;API Reference&quot; icon=&quot;code&quot; href=&quot;/api-reference/overview&quot;&gt;
    Build custom workflows and automations
  &lt;/Card&gt;
&lt;/CardGroup&gt;</file><file path="docs/integrations/circleci.mdx">---
title: &quot;CircleCI Integration&quot;
sidebarTitle: &quot;CircleCI&quot;
icon: &quot;circle-play&quot;
---

Monitor and automatically fix failing CI checks with CircleCI integration. Codegen views check status, analyzes build logs, and automatically fixes issues when PRs fail. When Codegen creates a PR and checks fail, it will automatically wake up to investigate the logs and push fixes.

&lt;Warning&gt;
  CircleCI is currently available for enterprise customers. See
  [codegen.com/billing](https://codegen.com/billing) for more
&lt;/Warning&gt;

## Capabilities

The CircleCI integration enables intelligent check monitoring and automatic issue resolution:

- **View broken checks and failures** - Monitor CI check status and identify specific failure points
- **Analyze build logs and error messages** - Grep through logs to understand root causes of failures
- **Automatically fix failing PRs** - Push corrective changes when checks fail on Codegen-created PRs
- **Wake up on check failures** - Automatically trigger when CI checks fail to investigate and resolve issues

## Permissions

The Codegen CircleCI integration requires the following permissions:

- **Read project information and settings** - Access pipeline configurations and project details
- **View build history and logs** - Monitor pipeline execution and analyze failure logs
- **Read test results and artifacts** - Access build outputs, test reports, and error details
- **Access check status and details** - Monitor CI check results and failure information

&lt;Note&gt;
  Codegen operates in read-only mode for CircleCI - it monitors and analyzes but
  does not trigger builds or modify CI configurations.
&lt;/Note&gt;

## How Agents Use CircleCI

Agents leverage the CircleCI integration to:

- **Monitor Check Status:** Continuously watch for CI check failures on pull requests
- **Analyze Failure Logs:** Grep through build logs to identify specific errors, test failures, or build issues
- **Auto-Fix Issues:** When Codegen creates a PR and checks fail, it automatically investigates and pushes fixes
- **Prevent Broken Merges:** Ensure code quality by resolving CI failures before merge

## Automatic Wake-Up Behavior

When Codegen creates a pull request and CircleCI checks fail, Codegen will automatically:

1. **Detect the failure** - Monitor check status and identify when builds break
2. **Analyze the logs** - Grep through CircleCI logs to understand the specific failure
3. **Generate fixes** - Create targeted code changes to resolve the identified issues
4. **Push updates** - Automatically commit fixes to the same PR branch

This ensures that Codegen-created PRs maintain high quality and don&apos;t introduce breaking changes to your codebase.

## Installation

Connect your CircleCI account to Codegen to enable automatic check monitoring and issue resolution.

&lt;Card
  title=&quot;Connect CircleCI Account&quot;
  icon=&quot;circle-play&quot;
  href=&quot;https://codegen.com/integrations/circleci&quot;
&gt;
  Authorize Codegen to view your CircleCI check results and build logs.
&lt;/Card&gt;

&lt;Note&gt;
  Ensure the agent has access to the specific CircleCI projects and
  organizations you want it to monitor.
&lt;/Note&gt;{&quot; &quot;}</file><file path="docs/integrations/clickup.mdx">---
title: &quot;ClickUp Integration&quot;
sidebarTitle: &quot;ClickUp&quot;
icon: &quot;feather&quot;
---

import { COMMUNITY_SLACK_URL } from &quot;/snippets/links.mdx&quot;;

Codegen supports ClickUp as a first-class integration. Assign issues, create issues, perform triage and more.

&lt;Frame&gt;
  &lt;video
    controls
    src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1758064133/ClickUp_ysxp5s.mp4&quot;
    className=&quot;aspect-[3340/2160]&quot;
  /&gt;
&lt;/Frame&gt;

## Installation

Connect your ClickUp workspace to Codegen to enable agent interactions.

&lt;Card
  title=&quot;Connect ClickUp Workspace&quot;
  icon=&quot;feather&quot;
  href=&quot;https://codegen.com/integrations/clickup&quot;
&gt;
  Authorize Codegen to access your ClickUp workspace and project data.
&lt;/Card&gt;

&lt;Note&gt;
  The ClickUp integration is currently in &lt;b&gt;beta&lt;/b&gt;. Please reach out in the{&quot; &quot;}
  &lt;a href={COMMUNITY_SLACK_URL}&gt;community&lt;/a&gt; to have it enabled for your
  Codegen account.
&lt;/Note&gt;

## Capabilities

The ClickUp integration provides comprehensive task management capabilities:

- **Create tasks in your workspace** - Generate new tasks automatically based on development needs and project requirements
- **Update existing tasks and status** - Modify task details, progress, and completion status as work advances
- **Read workspace structure and data** - Access project hierarchies, spaces, folders, and lists to understand organization
- **Add comments to tasks and discussions** - Provide updates, ask questions, and facilitate team collaboration
- **Assign tasks to team members** - Route work to appropriate developers and coordinate team workload
- **Access custom fields and properties** - Work with specialized data fields and project-specific information
- **Read and update task dependencies** - Manage task relationships and project workflow dependencies
- **View workspace members and teams** - Access team structure for proper task assignment and collaboration

## Permissions

The Codegen ClickUp integration requires the following permissions:

- **Create tasks in your workspace** - Generate new tasks and to-do items as needed
- **Update existing tasks and status** - Modify task progress, completion status, and details
- **Read workspace structure and data** - Access project organization, spaces, and folder structures
- **Add comments to tasks and discussions** - Provide updates and facilitate collaboration
- **Assign tasks to team members** - Route work to appropriate team members
- **Access custom fields and properties** - Work with specialized project data and configurations
- **Read and update task dependencies** - Manage workflow relationships between tasks
- **View workspace members and teams** - Access team information for proper task management

## How Agents Use ClickUp

Agents leverage the ClickUp integration to:

- **Track Work:** Automatically update the status of tasks they are working on
- **Create Tasks:** Generate new tasks for follow-up work, bugs discovered, or sub-tasks
- **Link Development:** Connect implemented changes and GitHub PRs directly to relevant ClickUp tasks
- **Provide Updates:** Add comments to tasks with progress reports, results, or questions
- **Manage Dependencies:** Update task relationships as development work progresses
- **Coordinate Teams:** Assign and reassign tasks based on workload and expertise

&lt;Warning&gt;
  **Data Access Notice:** Workspace content can be surfaced in agent runs by any
  of your Codegen account members. Do not connect sensitive workspaces.
&lt;/Warning&gt;

&lt;Note&gt;
  The ClickUp integration requires feature flag access. Contact your team
  administrator to enable this integration.
&lt;/Note&gt;</file><file path="docs/integrations/figma.mdx">---
title: &quot;Figma Integration&quot;
sidebarTitle: &quot;Figma&quot;
icon: &quot;figma&quot;
---

AI is one of the most valuable collaborators for front-end modifications, UI updates, messaging, and crafting the aesthetic of what you&apos;re building. Codegen can now do serious work on both implementation and contributing to your design documentation, bridging the gap between design and code seamlessly.

## Installation

Connect your Figma account to Codegen to enable design-to-code workflows.

&lt;Card
  title=&quot;Connect Figma Account&quot;
  icon=&quot;figma&quot;
  href=&quot;https://codegen.com/integrations/figma&quot;
&gt;
  Authorize Codegen to access your Figma files and design resources.
&lt;/Card&gt;

## Capabilities

The Figma integration enables seamless design-to-code workflows:

- **Access design specifications** - Read design files, components, and detailed specifications
- **Extract design assets** - Pull images, icons, and visual elements for implementation
- **Convert designs to code** - Transform design mockups into functional frontend code
- **Sync design changes** - Stay updated with design iterations and modifications

## Permissions

The Codegen Figma integration requires the following permissions:

- **Read your profile and user information** - Access basic account details for authentication
- **Access file contents, nodes, and editor data** - Read design files and component structures
- **Read file metadata and version history** - Track design changes and version information
- **View file comments and discussions** - Understand design context and feedback
- **Access design variables and tokens** - Use consistent design system values
- **Read published components and styles** - Access shared design system components
- **Access team library content** - Use shared assets and design resources
- **List projects and project files** - Navigate and organize design files

## How Agents Use Figma

Agents leverage the Figma integration to:

- **Analyze Designs:** Examine design files to understand layout, styling, and component structure
- **Generate Code:** Convert Figma designs into HTML, CSS, React components, or other frontend code
- **Extract Assets:** Pull icons, images, and other visual assets needed for implementation
- **Maintain Design Systems:** Ensure code implementation follows design system guidelines and tokens

&lt;Note&gt;
  The Figma integration requires feature flag access. Contact your team
  administrator to enable this integration.
&lt;/Note&gt;</file><file path="docs/integrations/github.mdx">---
title: &quot;GitHub Integration&quot;
sidebarTitle: &quot;GitHub&quot;
icon: &quot;github&quot;
---

GitHub is how Codegen accesses your repository contents and performs all git interactions. Codegen can create PRs from requests or issues, help resolve merge conflicts, conduct code reviews, search through your codebase, and handle the full spectrum of agentic coding workflowsâ€”everything flows through GitHub.

## Installation

Authorize Codegen to access your GitHub organizations and repositories.

&lt;Card
  title=&quot;Install Codegen GitHub App&quot;
  icon=&quot;github&quot;
  href=&quot;https://github.com/apps/codegen-sh&quot;
&gt;
  Click here to install the Codegen GitHub App and grant necessary permissions.
&lt;/Card&gt;

## Capabilities

The GitHub integration provides comprehensive development workflow capabilities:

- **Create and manage pull requests** - Generate, update, and manage PRs with detailed descriptions and context
- **Automated code reviews and feedback** - Provide intelligent code analysis and suggestions
- **Run checks and CI/CD workflows** - Execute automated testing and deployment processes
- **Sync repository changes** - Keep repositories up-to-date and coordinate between branches

## Permissions

The Codegen GitHub integration requires the following permissions to function as a full development team member:

- **Read and write repository contents** - Access code, files, and repository structure
- **Create and manage pull requests** - Generate, update, and merge pull requests
- **Write status checks and CI/CD results** - Report on automated testing and deployment status
- **Read and write issues and comments** - Interact with project issues and provide updates
- **Read repository metadata and settings** - Access repository configuration and settings
- **Read and write GitHub Actions workflows** - Manage automated workflows and CI/CD pipelines
- **Read organization projects and members** - Access team structure and project organization
- **Manage webhooks for real-time updates** - Enable real-time synchronization and notifications

## How Agents Use GitHub

Agents leverage the GitHub integration to:

- **Understand Context:** Read code and related issues/PRs to grasp the task requirements.
- **Implement Changes:** Create branches and commit code directly based on your prompts.
- **Request Reviews:** Open pull requests and automatically request reviews from specified team members.
- **Report Progress:** Comment on related issues or PRs with updates, results, or requests for clarification.

&lt;Tip&gt;
  You can manage repository access granularly through the GitHub App settings.
&lt;/Tip&gt;

&lt;Note&gt;
  Ensure the agent has access to the specific repositories it needs to work on.
&lt;/Note&gt;</file><file path="docs/integrations/integrations.mdx">---
title: &quot;Integrations&quot;
sidebarTitle: &quot;Overview&quot;
icon: &quot;plug&quot;
---

Codegen agents can work effectively with hundreds of &quot;tools&quot;, enabling them to work seamlessly across your existing development stack.

&lt;video
  controls
  src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1757885715/5-integrations_lxxt3i.mp4&quot;
  className=&quot;w-full aspect-[3456/2160] rounded-sm&quot;
/&gt;

Connect your favorite platforms to enable agents that understand your context and can work across multiple systems.

&lt;Card
  title=&quot;Manage Integrations&quot;
  icon=&quot;plug&quot;
  href=&quot;https://codegen.com/integrations&quot;
&gt;
  Give Codegen access to your stack via OAuth or MCP connections
&lt;/Card&gt;

## Core Development

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;GitHub&quot; icon=&quot;github&quot; href=&quot;/integrations/github&quot;&gt;
    Access repositories, create PRs, conduct code reviews, and manage the full development workflow through GitHub.
  &lt;/Card&gt;

  &lt;Card title=&quot;Slack&quot; icon=&quot;slack&quot; href=&quot;/integrations/slack&quot;&gt;
    Chat with Codegen directly in channels, get real-time notifications, and collaborate seamlessly within your workspace.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Project Management

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;Linear&quot; icon=&quot;moon&quot; href=&quot;/integrations/linear&quot;&gt;
    Track progress, create issues, and orchestrate teams of humans and agents working together on complex tasks.
  &lt;/Card&gt;

{&quot; &quot;}

&lt;Card title=&quot;Jira&quot; icon=&quot;jira&quot; href=&quot;/integrations/jira&quot;&gt;
  Manage issues, update project status, and coordinate development workflows
  across your team.
&lt;/Card&gt;

{&quot; &quot;}

&lt;Card title=&quot;ClickUp&quot; icon=&quot;feather&quot; href=&quot;/integrations/clickup&quot;&gt;
  Create tasks, manage dependencies, and coordinate development workflows with
  AI-powered project management.
&lt;/Card&gt;

  &lt;Card title=&quot;Monday.com&quot; icon=&quot;fan&quot; href=&quot;/integrations/monday&quot;&gt;
    Automate project management with intelligent task creation, status updates, and team coordination.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Design &amp; Documentation

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;Figma&quot; icon=&quot;figma&quot; href=&quot;/integrations/figma&quot;&gt;
    Convert designs to code, extract assets, and maintain design systems with seamless design-to-code workflows.
  &lt;/Card&gt;

  &lt;Card title=&quot;Notion&quot; icon=&quot;book&quot; href=&quot;/integrations/notion&quot;&gt;
    Access your knowledge base, analyze PRDs and specs, and bridge the gap between planning documents and code.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## DevOps &amp; Monitoring

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;CircleCI&quot; icon=&quot;circle-play&quot; href=&quot;/integrations/circleci&quot;&gt;
    Monitor CI checks, analyze build logs, and automatically fix failing tests and builds.
  &lt;/Card&gt;

  &lt;Card title=&quot;Sentry&quot; icon=&quot;triangle&quot; href=&quot;/integrations/sentry&quot;&gt;
    Analyze errors with automated root cause analysis and intelligent insights for faster issue resolution.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Data &amp; Search

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;PostgreSQL&quot; icon=&quot;database&quot; href=&quot;/integrations/postgres&quot;&gt;
    Query databases, analyze schemas, and generate data-driven reports with secure database access.
  &lt;/Card&gt;

  &lt;Card title=&quot;Web Search&quot; icon=&quot;globe&quot; href=&quot;/integrations/web-search&quot;&gt;
    Access real-time information from the internet with intelligent search and content analysis capabilities.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Extensibility

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;MCP Servers&quot; icon=&quot;server&quot; href=&quot;/integrations/mcp-servers&quot;&gt;
    Connect custom tools and services to extend agent capabilities through Model Context Protocol servers.
  &lt;/Card&gt;

  &lt;Card title=&quot;Remote MCP&quot; icon=&quot;server&quot; href=&quot;/integrations/mcp&quot;&gt;
    Access Codegen APIs through a hosted MCP server for seamless AI agent integration.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Getting Started

Most integrations require authentication and configuration through the [Codegen dashboard](https://codegen.com/integrations). Each integration provides specific capabilities that agents can leverage to assist with your development workflow.

&lt;Tip&gt;
  Start with GitHub and Slack for the most comprehensive development experience,
  then add project management tools like Linear or Jira based on your team&apos;s
  workflow.
&lt;/Tip&gt;</file><file path="docs/integrations/jira.mdx">---
title: &quot;Jira Integration&quot;
sidebarTitle: &quot;Jira&quot;
icon: &quot;jira&quot;
---

import { COMMUNITY_SLACK_URL } from &quot;/snippets/links.mdx&quot;;

Integrate Codegen with your Jira workspace to allow agents to interact with issues, manage projects, and keep your team updated.

&lt;img src=&quot;/images/jira.png&quot; className=&quot;rounded-lg&quot; /&gt;

## Installation

Connect your Jira workspace to Codegen to enable agent interactions.

&lt;Card
  title=&quot;Connect Jira Workspace&quot;
  icon=&quot;jira&quot;
  href=&quot;https://codegen.com/integrations/jira&quot;
&gt;
  Authorize Codegen to access your Jira workspace and project data.
&lt;/Card&gt;

&lt;Note&gt;
  The Jira integration is currently in &lt;b&gt;beta&lt;/b&gt;. Please reach out in the{&quot; &quot;}
  &lt;a href={COMMUNITY_SLACK_URL}&gt;community&lt;/a&gt; to have it enabled for your
  Codegen account.
&lt;/Note&gt;

## Step-by-Step Setup Guide

Follow these steps to successfully connect Codegen to your Jira workspace:

### 1. Enable User-Installed Apps in Jira

- In your Jira workspace, ensure that **user-installed apps** are enabled.
- Make sure the setting to allow user-installed apps is enabled. This is required for the Codegen integration to work properly.

&lt;Note&gt;
  If you don&apos;t have admin access to enable user-installed apps, contact your
  Jira administrator to enable this setting before proceeding.
&lt;/Note&gt;

### 2. Create a Dedicated Jira User for Codegen

- In your Jira workspace, create a new user account specifically for Codegen.
- **Email:** Use an address with `codegen` in it, like `yourname+codegen@company_domain.com` or `codegen@company_domain.com`.
- **Name:** Set the user&apos;s name to **Codegen**. This makes it easy to identify actions performed by Codegen in Jira.

### 3. Authorize Codegen with the New Jira User

- Log in to Jira as the new Codegen user.
- Go to [Codegen&apos;s Jira Integration page](https://codegen.com/integrations/jira).
- Click **Connect Jira Workspace** and complete the OAuth flow **using the Codegen Jira user** you just created.

&lt;Warning&gt;
  Make sure you are logged in as the Codegen Jira user when authorizing access.
  This is to ensure Codegen acts on behalf of the new user and not your personal
  account.
&lt;/Warning&gt;

### 4. Switch Back to Your Own Jira Account

- After connecting, log out of the Codegen Jira user in Jira.
- Log back in with your personal Jira account.

### 5. Use Codegen in Your Workflow

- On any Jira ticket, `@mention` the Codegen user (e.g., `@Codegen`) to assign or notify Codegen about the issue.
- Codegen will interact with the ticket, update statuses, add comments, and link PRs as needed.

## Capabilities

The Jira integration provides read and write access, enabling agents to manage tasks effectively:

- **Read Access:** Fetch issue details, read comments, view project status, list team members.
- **Write Access:** Update issue status (e.g., to &quot;In Progress&quot;, &quot;Done&quot;), add comments, link GitHub PRs to issues, create new issues, assign tasks.

## How Agents Use Jira

Agents use the Jira integration to streamline project management:

- **Track Work:** Automatically update the status of issues they are working on.
- **Link Code:** Connect implemented changes (GitHub PRs) directly to the relevant Jira issue.
- **Provide Updates:** Post comments on issues with progress reports, results, or questions.
- **Create Tasks:** Generate new issues for follow-up work, bugs discovered, or sub-tasks.</file><file path="docs/integrations/linear.mdx">---
title: &quot;Linear Integration&quot;
sidebarTitle: &quot;Linear&quot;
icon: &quot;moon&quot;
---

Linear is designed to orchestrate teams of humans and agents working together. It&apos;s the most efficient way to track progress and scale teams of agents to tackle large, complex tasks. Codegen can take a first pass at virtually any issue, breaking down work and making meaningful progress before human review. We recommend letting Codegen handle the initial exploration and implementation of most tasks.

&lt;img src=&quot;/images/linear.png&quot; className=&quot;rounded-lg&quot; /&gt;

## Installation

Connect your Linear workspace to Codegen to enable agent interactions.

&lt;Card
  title=&quot;Connect Linear Workspace&quot;
  icon=&quot;moon&quot;
  href=&quot;https://linear.app/integrations/codegen&quot;
&gt;
  Authorize Codegen to access your Linear workspace via the API settings.
&lt;/Card&gt;

&lt;Note&gt;
  API access allows agents to interact with issues and projects according to
  your permissions in Linear.
&lt;/Note&gt;

## Capabilities

The Linear integration provides comprehensive project management capabilities:

- **Create and update issues automatically** - Generate new tasks and update existing ones based on development needs
- **Track development progress** - Monitor and report on the status of ongoing work
- **Link code changes to tickets** - Connect GitHub pull requests and commits directly to Linear issues
- **Sync status updates** - Keep issue statuses current as work progresses through different stages
- **Multi Agent Systems:** Create sub-issues and assign child agents to break down complex tasks into manageable pieces. [Learn more](#multi-agent-systems).

## Permissions

The Codegen Linear integration requires the following permissions:

- **Create issues for your workspace** - Generate new tasks and tickets as needed
- **Create issue comments and discussions** - Provide updates, ask questions, and facilitate collaboration
- **Read access to your workspace data** - Access existing issues, projects, and team information
- **Write access to update issues and projects** - Modify issue status, assignees, and project details
- **Assign issues and projects to teams** - Route work to appropriate team members
- **Mention app in issues and documents** - Enable notifications and cross-references
- **Receive realtime updates about workspace changes** - Stay synchronized with workspace activity

## How Agents Use Linear

Agents use the Linear integration to streamline project management:

- **Track Work:** Automatically update the status of issues they are working on.
- **Link Code:** Connect implemented changes (GitHub PRs) directly to the relevant Linear issue.
- **Provide Updates:** Post comments on issues with progress reports, results, or questions.
- **Create Tasks:** Generate new issues for follow-up work, bugs discovered, or sub-tasks.

## Multi Agent Systems

### Overview

Once you&apos;ve enabled linear self-assign in the settings [page](https://www.codegen.com/integrations/linear), a codegen agent, that has been assigned to a linear issue (or has been tagged in one), can spawn child agents
by creating sub-issues and assigning itself to those sub-issues. For each sub-issue that codegen assigns to itself a child agent will be spawned and tasked with completing the sub-issue. Once the child agents are
finished with their tasks they will notify their parent by sending it a message. The parent will then incorporate the child&apos;s work into its own as appropriate.

### Best Practices

#### Triggering the Child Agents

If you&apos;d like to have codegen break up a linear issue into smaller issues and assign them to child agents you should instruct it to do so in the
description of the original linear issue.

#### Shared Context

Before creating sub-issues and assigning them to child agents the parent agent will produce scaffolding in the form of a git branch and include details
of this branch in the description of the sub-issues. The child agents will then work off of this scaffolding branch. If you have specific scaffolding requirements
or context you&apos;d like the child agents to share, please include them in the description of the parent issue.

#### Availability

This feature is only available on the Team Plan.</file><file path="docs/integrations/mcp-servers.mdx">---
title: &quot;MCP Servers&quot;
sidebarTitle: &quot;MCP Servers&quot;
icon: &quot;server&quot;
---

Connect external tools and services to enhance your AI agent capabilities through Model Context Protocol (MCP) servers. Codegen allows you to connect arbitrary MCP servers that we will run and manage for your agents.

## Installation

Configure MCP servers to extend your agent capabilities with custom tools and services.

&lt;Card
  title=&quot;Configure MCP Servers&quot;
  icon=&quot;server&quot;
  href=&quot;https://codegen.com/integrations/mcp&quot;
&gt;
  Connect custom MCP servers to enhance your agent workflows.
&lt;/Card&gt;

## Capabilities

The MCP integration provides comprehensive extensibility for your agents:

- **Connect custom tools and services** - Integrate any MCP-compatible server to extend agent functionality
- **Extend agent capabilities** - Add specialized tools, APIs, and data sources to your development workflow
- **Managed execution** - Codegen runs and manages your MCP servers, handling infrastructure and reliability
- **Secure integration** - Connect external services while maintaining security and access controls
- **Repository-specific configuration** - Configure different MCP servers for different repositories and projects
- **Real-time connectivity** - Agents can interact with MCP servers in real-time during task execution

## How It Works

Codegen&apos;s MCP server integration allows you to:

1. **Configure MCP Servers** - Add MCP server configurations through the Codegen interface
2. **Repository Integration** - Associate MCP servers with specific repositories for targeted functionality
3. **Agent Access** - Agents automatically discover and use available MCP server tools during execution
4. **Managed Infrastructure** - Codegen handles server deployment, scaling, and maintenance

## Supported MCP Servers

You can connect any MCP-compatible server, including:

- **Database connectors** - Connect to PostgreSQL, MySQL, MongoDB, and other databases
- **API integrations** - Access REST APIs, GraphQL endpoints, and web services
- **Development tools** - Integrate with testing frameworks, deployment tools, and CI/CD systems
- **Custom business logic** - Add company-specific tools and workflows
- **External services** - Connect to cloud services, monitoring tools, and third-party platforms

## Configuration

MCP servers are configured per repository using a JSON configuration file. The configuration includes:

- **Server details** - URL, authentication, and connection parameters
- **Tool mapping** - Define which tools are available to agents
- **Access controls** - Specify permissions and security settings
- **Environment variables** - Configure server-specific settings and secrets

## Permissions

The Codegen MCP integration requires the following permissions:

- **Connect to external MCP servers** - Establish connections to your configured servers
- **Execute custom tool functions** - Run tools and commands provided by MCP servers
- **Access server-provided resources** - Read and write data through MCP server interfaces
- **Manage server configurations** - Update and modify MCP server settings

## How Agents Use MCP Servers

Agents leverage MCP servers to:

- **Extend Functionality:** Access tools and capabilities beyond built-in agent features
- **Connect External Systems:** Interact with databases, APIs, and services specific to your workflow
- **Custom Workflows:** Execute company-specific processes and business logic
- **Data Integration:** Access and manipulate data from various sources and formats
- **Specialized Tools:** Use domain-specific tools for testing, deployment, monitoring, and more

&lt;Note&gt;
  MCP server integration allows for powerful extensibility but requires careful
  configuration to ensure security and proper access controls.
&lt;/Note&gt;</file><file path="docs/integrations/mcp.mdx">---
title: &quot;Remote MCP Server&quot;
description: &quot;Connect AI agents to Codegen using the hosted Model Context Protocol (MCP) server&quot;
icon: &quot;server&quot;
---

Codegen provides a hosted MCP server that allows AI agents to interact with the Codegen platform through the Model Context Protocol (MCP). This integration enables AI agents to access Codegen APIs, manage agent runs, and interact with your development workflow without running a local server.

## Overview

The remote MCP server provides:

- **Cloud-Based Integration**: Access Codegen services from anywhere without local setup
- **API Integration**: Direct access to Codegen platform APIs
- **Agent Management**: Create and monitor agent runs
- **Organization Management**: Access organization and user information
- **Workflow Integration**: Seamless integration with AI development tools

## Configuration

### For Claude Code

To configure the remote Codegen MCP server in Claude Code:

```bash
claude mcp add --transport http codegen-tools https://mcp.codegen.com/mcp/ \
  --header &quot;Authorization: Bearer &lt;auth token&gt;&quot; \
  --header &quot;x-organization-id: &lt;org-id&gt;&quot; \
  --header &quot;x-repo-id: &lt;repo-id&gt;&quot;
```

Replace:

- `&lt;auth token&gt;` with your Codegen API key
- `&lt;org-id&gt;` with your organization ID (optional, automatically added when using `codegen claude`)
- `&lt;repo-id&gt;` with your repository ID (optional, automatically added when using `codegen claude`)

### For Cursor/Windsurf/VSCode Forks

Add the following configuration to your settings:

```json
{
  &quot;mcp.servers&quot;: {
    &quot;codegen-remote&quot;: {
      &quot;transport&quot;: &quot;http&quot;,
      &quot;url&quot;: &quot;https://mcp.codegen.com/mcp/&quot;,
      &quot;headers&quot;: {
        &quot;Authorization&quot;: &quot;Bearer &lt;auth token&gt;&quot;,
        &quot;x-organization-id&quot;: &quot;&lt;org-id&gt;&quot;,
        &quot;x-repo-id&quot;: &quot;&lt;repo-id&gt;&quot;
      }
    }
  }
}
```

Replace:

- `&lt;auth token&gt;` with your Codegen API key
- `&lt;org-id&gt;` with your organization ID (optional)
- `&lt;repo-id&gt;` with your repository ID (optional)

### For VSCode with MCP Extension

If you&apos;re using VSCode with an MCP extension, add this to your settings.json:

```json
{
  &quot;mcp.servers&quot;: [
    {
      &quot;name&quot;: &quot;codegen-remote&quot;,
      &quot;transport&quot;: &quot;http&quot;,
      &quot;url&quot;: &quot;https://mcp.codegen.com/mcp/&quot;,
      &quot;headers&quot;: {
        &quot;Authorization&quot;: &quot;Bearer &lt;auth token&gt;&quot;,
        &quot;x-organization-id&quot;: &quot;&lt;org-id&gt;&quot;,
        &quot;x-repo-id&quot;: &quot;&lt;repo-id&gt;&quot;
      }
    }
  ]
}
```

Replace:

- `&lt;auth token&gt;` with your Codegen API key
- `&lt;org-id&gt;` with your organization ID (optional)
- `&lt;repo-id&gt;` with your repository ID (optional)

## Authentication

The remote MCP server uses your Codegen API key for authentication. You can obtain your API key from the [Codegen dashboard](https://codegen.com/settings).

## Available Tools

The remote MCP server provides the following tools for AI agents:

### Getting Help

If you encounter issues with the remote MCP server:

1. Check the [Codegen documentation](https://docs.codegen.com)
2. Join our [community Slack](https://community.codegen.com)
3. Report issues on [GitHub](https://github.com/codegen-sh/codegen)

The remote MCP server makes it easy to integrate Codegen&apos;s powerful AI development capabilities into your existing AI agent workflows without the need to run a local server.</file><file path="docs/integrations/monday.mdx">---
title: &quot;Monday.com Integration&quot;
sidebarTitle: &quot;Monday.com&quot;
icon: &quot;fan&quot;
---

Integrate Codegen with your Monday.com workspace to enable AI-powered project management with intelligent task automation. Codegen can create and update items, manage boards, and keep your team synchronized across development workflows.

## Installation

Connect your Monday.com workspace to Codegen to enable agent interactions.

&lt;Card
  title=&quot;Connect Monday.com Workspace&quot;
  icon=&quot;fan&quot;
  href=&quot;https://codegen.com/integrations/monday&quot;
&gt;
  Authorize Codegen to access your Monday.com workspace and project boards.
&lt;/Card&gt;

## Capabilities

The Monday.com integration provides comprehensive project management capabilities:

- **Create and update items** - Generate new tasks and update existing ones based on development needs
- **Read and update items** - Access and modify task details, status, and progress information
- **Manage boards and columns** - Organize work across different project boards and customize workflows
- **Team coordination** - Assign tasks to team members and manage workload distribution
- **Status synchronization** - Keep project status current as work progresses through different stages
- **Automated reporting** - Generate progress reports and project insights based on development activity

## Permissions

The Codegen Monday.com integration requires the following permissions:

- **Read and update items** - Access and modify task details and progress information
- **Read and update boards** - Manage project boards and organizational structure
- **Read and update columns** - Customize workflows and data fields
- **Read and update groups** - Organize tasks into logical groupings
- **Read and update users** - Access team member information for task assignment
- **Read and update workspaces** - Manage workspace-level settings and permissions

## How Agents Use Monday.com

Agents leverage the Monday.com integration to:

- **Track Work:** Automatically update the status of items they are working on
- **Create Tasks:** Generate new items for follow-up work, bugs discovered, or sub-tasks
- **Provide Updates:** Add updates to items with progress reports, results, or questions
- **Link Development:** Connect implemented changes and code work directly to relevant Monday.com items
- **Manage Workflows:** Update item status as work progresses through different development stages

&lt;Note&gt;
  The Monday.com integration requires feature flag access. Contact your team
  administrator to enable this integration.
&lt;/Note&gt;</file><file path="docs/integrations/notion.mdx">---
title: &quot;Notion Integration&quot;
sidebarTitle: &quot;Notion&quot;
icon: &quot;book&quot;
---

Notion is your team&apos;s knowledge base, and now Codegen can tap into it too. Share PRDs, specs, and documentation with Codegen for technical feedback and implementation. A common workflow: pass a PRD to Codegen and it will provide technical insights, comment directly on the document, and then go implement the features described.

## Installation

Connect your Notion workspace to Codegen to enable agent interactions with your knowledge base.

&lt;Card
  title=&quot;Connect Notion Workspace&quot;
  icon=&quot;books&quot;
  href=&quot;https://codegen.com/integrations/notion-mcp&quot;
&gt;
  Authorize Codegen to access your Notion workspace and documentation.
&lt;/Card&gt;

## Capabilities

The Notion integration enables seamless access to your team&apos;s knowledge base:

- **Access workspace documentation** - Read and analyze existing documentation, specs, and project requirements
- **Update pages and databases** - Modify content, add comments, and keep documentation current
- **Sync development information** - Bridge the gap between planning documents and code implementation
- **Generate knowledge base content** - Create new documentation based on development work and insights

## Permissions

The Codegen Notion integration requires the following permissions:

- **Read workspace content and documents** - Access existing pages, databases, and documentation
- **Update existing pages and documents** - Modify content and add comments for collaboration
- **Create new pages and content** - Generate new documentation and project materials
- **Access user information and emails** - Understand team structure and collaboration context
- **Read database entries and properties** - Access structured data and project information
- **Update database entries and values** - Modify project data and status information
- **Create new databases and structures** - Establish new organizational systems as needed

## How Agents Use Notion

Agents leverage the Notion integration to:

- **Analyze Requirements:** Read PRDs and technical specifications to understand project scope and requirements
- **Provide Technical Feedback:** Comment on documents with implementation insights and technical considerations
- **Update Documentation:** Keep project documentation current as development progresses
- **Bridge Planning and Code:** Connect high-level planning documents with actual code implementation

&lt;Note&gt;
  The Notion integration requires feature flag access. Contact your team
  administrator to enable this integration.
&lt;/Note&gt;</file><file path="docs/integrations/postgres.mdx">---
title: &quot;Postgres Integration&quot;
sidebarTitle: &quot;Postgres&quot;
icon: &quot;database&quot;
---

Integrate Codegen with your Postgres (or Postgres-compatible databases) to enable database querying capabilities.

## Installation

Connect your database to Codegen by configuring your database credentials in the settings.

&lt;Card
  title=&quot;Configure Database Access&quot;
  icon=&quot;shield&quot;
  href=&quot;https://codegen.com/integrations/postgresql&quot;
&gt;
  Set up your database connection credentials in the secure settings panel.
&lt;/Card&gt;

&lt;Note type=&quot;warning&quot;&gt;
  For security reasons, it is strongly recommended to configure credentials with READ-ONLY access.
  Providing write access to automated agents could potentially lead to unintended data modifications
  or other negative consequences.
&lt;/Note&gt;

## Capabilities

The Postgres integration provides secure database access enabling agents to:

- **Query Data:** Execute SELECT queries to fetch information from your database
- **Analyze Schema:** View table structures, relationships, and column definitions
- **Generate Reports:** Create data summaries and analysis based on query results

## How Agents Use Postgres

Agents leverage the Postgres integration to assist with data-related tasks:

- **Data Exploration:** Safely query your database to understand data structures and relationships
- **Report Generation:** Create data-driven reports and analytics
- **Schema Analysis:** Provide insights about database design and optimization</file><file path="docs/integrations/sentry.mdx">---
title: &quot;Sentry Integration&quot;
sidebarTitle: &quot;Sentry&quot;
icon: &quot;triangle&quot;
---

import { COMMUNITY_SLACK_URL } from &quot;/snippets/links.mdx&quot;;

Integrate Codegen with your Sentry workspace to enable AI-powered error tracking with automated root cause analysis. Codegen can analyze errors, investigate issues, and provide intelligent insights to help resolve production problems faster.

## Installation

Connect your Sentry organization to Codegen to enable agent interactions with error tracking data.

&lt;Card
  title=&quot;Connect Sentry Organization&quot;
  icon=&quot;triangle&quot;
  href=&quot;https://codegen.com/integrations/sentry&quot;
&gt;
  Authorize Codegen to access your Sentry organization and error data.
&lt;/Card&gt;

&lt;Note&gt;
  The Sentry integration is currently in &lt;b&gt;beta&lt;/b&gt;. Please reach out in the{&quot; &quot;}
  &lt;a href={COMMUNITY_SLACK_URL}&gt;community&lt;/a&gt; to have it enabled for your
  Codegen account.
&lt;/Note&gt;

## Capabilities

The Sentry integration provides comprehensive error tracking and analysis capabilities:

- **Automated root cause analysis** - Analyze error patterns and stack traces to identify underlying issues
- **Error investigation** - Deep dive into error contexts, user impact, and related code changes
- **Issue prioritization** - Help identify critical errors that need immediate attention
- **Performance monitoring** - Analyze performance issues and bottlenecks in your applications
- **Release tracking** - Connect errors to specific deployments and code changes
- **Team coordination** - Assign issues to appropriate team members based on expertise and ownership

## Permissions

The Codegen Sentry integration requires the following permissions:

- **Read organization information** - Access organization settings and configuration
- **Read/Write project information** - Access project details and modify project settings
- **Read/Write team information** - Access team structure and manage team assignments
- **Read/Write event information** - Analyze error events and update issue status

## How Agents Use Sentry

Agents leverage the Sentry integration to:

- **Analyze Errors:** Examine error patterns, stack traces, and user impact to understand root causes
- **Investigate Issues:** Deep dive into error contexts, related code changes, and deployment history
- **Provide Insights:** Generate intelligent analysis and recommendations for error resolution
- **Track Progress:** Update issue status and resolution progress as fixes are implemented
- **Link Development:** Connect error fixes to GitHub PRs and code changes
- **Prioritize Work:** Help identify critical errors that require immediate attention

&lt;Note&gt;
  The Sentry integration requires feature flag access. Contact your team
  administrator to enable this integration.
&lt;/Note&gt;</file><file path="docs/integrations/slack.mdx">---
title: &quot;Integration for Slack&quot;
sidebarTitle: &quot;Slack&quot;
icon: &quot;slack&quot;
---

Connect Codegen to your Slack workspace to enable seamless communication between agents and your team.

&lt;video
  controls
  src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1757886194/slack-happy-path_yjtx1c.mp4&quot;
  className=&quot;w-full aspect-[3456/2160] rounded-sm&quot;
/&gt;

Slack is the most fluid way to communicate with Codegen. Simply tag @codegen in any channel to collaborate directly and give it tasks that leverage all your other integrations. As an agent, Codegen can seamlessly work across platformsâ€”from GitHub to Linear to your databasesâ€”all initiated from Slack. We recommend Slack as the lowest barrier entry point for all users.

## Installation

To use this integration, follow the installation and configuration steps below.

&lt;Card
  title=&quot;Add Codegen to Slack&quot;
  icon=&quot;slack&quot;
  href=&quot;https://codegen.com/integrations&quot;
&gt;
  Create a Codegen account and visit Integrations &gt; Slack to connect your Slack
  workspace.
&lt;/Card&gt;

&lt;Note&gt;
  Configure channel access carefully to ensure agents communicate in the
  appropriate places.
&lt;/Note&gt;

After installation, proceed to the Configuration Instructions below to finish setup and begin using Codegen in your Slack workspace.

## Capabilities

The Slack integration enables seamless collaboration with Codegen directly within your workspace:

- **Chat with Codegen directly in channels** - Interact naturally through @mentions and direct messages
- **Get real-time notifications** - Stay updated on task progress and completion
- **Share code snippets and updates** - Collaborate on code changes and development tasks
- **Collaborate on development tasks** - Coordinate work across your entire development workflow

All of these capabilities are accessible through natural language interactions in your Slack workspace, allowing your team to leverage Codegen&apos;s assistance without context switching between different platforms.

## Configuration Instructions

After installing the integration from the Slack Marketplace, configure the bot by inviting it to relevant channels and setting up triggers so Codegen knows when and how to respond.

### Channel Setup

- **Invite the Codegen bot**: Type `/invite @codegen` in any channel where you want Codegen to participate.
- (Optional) **Create a dedicated channel**: Some Codegen users find creating a channel like `#codegen` helpful for general agent interactions and to encourage experimentation.

## What Triggers Slack Messages from Codegen

These triggers kick off new Codegen requests:

- **Direct mentions**: Type `@codegen` followed by your request in any channel where the bot is present.
- **Thread replies**: Tag `@codegen` in threads to continue the conversation.
- **Direct messages**: Send a DM to the Codegen bot for private conversations.

In addition, Codegen will send messages to Slack when:

- It starts work on a request you made
- It receives an additional message while working on a request
- It completes a task, code change, or research request

## How Codegen Responds to Slack Messages

Codegen only responds when tagged or messaged directly. Use these approaches to ensure your request reaches it:

- **Direct Messages:**

  - Responds to any DM sent to the Codegen integration for Slack
  - Codegen only sees messages in the direct message conversation where it has been invited
  - This provides a more natural conversation experience as many users don&apos;t thread messages in DMs

- **Channel Messages:**
  - Responds to any message that @mentions Codegen in channels where the integration for Slack is installed
  - Codegen only sees messages in threads that it has been invited into
  - Only has visibility into the local context of the thread/conversation
  - Sending subsequent messages within a thread routes to the same agent (tag `@codegen` to trigger)
  - New messages to `@codegen` in an active thread will interrupt the agent if it&apos;s currently working

## Permissions and Scopes

The Codegen Slack integration requires the following permissions to function effectively:

### Core Messaging Permissions

- **View messages that mention @codegen** - To respond to direct mentions and requests
- **Read message history in public and private channels** - To understand context and conversation flow
- **Read direct messages and group chats** (`mpim:read`) - To enable private conversations with the agent in group DMs and multi-person direct messages
- **Send messages** - To communicate responses and provide updates

### Enhanced Communication Features

- **View and react with emojis** - To acknowledge messages and provide feedback through reactions

### User and Workspace Access

- **View workspace members and email addresses** (`users:read.email`) - Used to map Slack user accounts to Codegen accounts for proper authentication and permission management. This ensures that when a user interacts with Codegen via Slack, their actions are properly attributed to their Codegen account and repository permissions
- **Access shared files and attachments** - To review and work with shared content like code snippets, images, and documents
- **Access basic channel information** - To operate appropriately within different channel contexts

### Why These Permissions Are Necessary

- **Email mapping** enables secure account linking between Slack and Codegen, ensuring proper access control
- **Group DM access** ensures Codegen can participate in team discussions and collaborative planning sessions

## Data Privacy and Security

**Message Content Handling:**

- **Third-Party LLM APIs:** To provide its core functionality, Codegen shares message content with third-party Large Language Model (LLM) APIs, specifically OpenAI and Anthropic.
- **Data Retention:** Outside of the LLM API interactions, message content is retained by Codegen solely for the purpose of displaying it within the Codegen user interface.
- **Metadata from Private Channels:** When messages from private Slack channels are processed, Codegen does not expose private metadata, such as the original author&apos;s name or username, in the Codegen web app. Private channel names are anonymized and displayed as &quot;Private channel&quot; to non-members.

**Data Scope and Context:**

- **Thread Context:** When Codegen is mentioned inside a thread, it will pull context from the entire thread, including the messages sent and media shared within that thread.
- **Single Message Context:** When Codegen is mentioned outside of a thread, it will only be scoped to the specific message in which it is mentioned.

**User Permissions and Access Control:**

Codegen&apos;s actions on connected repositories are governed by the permissions of the user who initiated the interaction via Slack. The bot itself does not have independent permissions to repositories. Access to repositories and the ability to trigger actions are determined by the Codegen user&apos;s authenticated account and their associated repository permissions. We recommend configuring channel access carefully during installation to ensure the Codegen integration for Slack is only present in channels where its use is appropriate.

**Audit Trail:**

Administrators can access a comprehensive audit trail through the [Recents page](https://codegen.com/recents) in the Codegen web app. This provides detailed logs of when and by whom Codegen was invoked in Slack, with filtering capabilities by integration, user, and other parameters.

**Privacy Policy:**

For complete details on how we collect, use, and protect your data, please review our [Privacy Policy](https://www.codegen.com/privacy-policy).

## AI Components and Usage

**AI-Powered Functionality:**

Codegen uses artificial intelligence to provide intelligent code assistance, automated development tasks, and natural language interactions. Our AI capabilities include:

- **Code Generation and Analysis:** AI models analyze your codebase and generate appropriate code changes, bug fixes, and improvements
- **Natural Language Processing:** AI interprets your requests in Slack and converts them into actionable development tasks
- **Context Understanding:** AI maintains conversation context to provide relevant and coherent responses across interactions

**AI Data Processing:**

- **Message Analysis:** Your Slack messages are processed by AI models to understand intent and generate appropriate responses
- **Code Context:** When working with repositories, AI models analyze relevant code to provide accurate assistance

**AI Limitations:**

- AI-generated code should be reviewed before deployment
- Complex tasks may require human oversight and validation
- AI responses are based on training data and may not always reflect the most current information

## Pricing and Plans

Codegen offers flexible pricing plans to accommodate teams of all sizes. The Slack integration is available across all plan tiers, with usage limits and features varying by plan.

For detailed pricing information and to choose the plan that best fits your team&apos;s needs, visit our [Pricing Page](https://www.codegen.com/pricing).

## Tips for Effective Use

- Use direct language when asking Codegen for help (e.g., &quot;Add pagination to the results view&quot;).
- Mention Codegen early in the message so it is triggered promptly.
- Use threads for ongoing conversations with Codegen so it has access to previous context.</file><file path="docs/integrations/web-search.mdx">---
title: &quot;Web Search Integration&quot;
sidebarTitle: &quot;Web Search&quot;
icon: &quot;globe&quot;
---

Connect Codegen to web search capabilities powered by exa to enable agents to search and retrieve information from the internet.

## Capabilities

Our web search integration, powered by exa, provides agents with the ability to search and understand web content:

- **Real-time Search:** Access up-to-date information from across the internet.
- **Content Analysis:** Parse and extract relevant information from web pages.
- **Source Verification:** Evaluate and cite reliable sources for information.
- **Context Integration:** Incorporate web-sourced information into responses and solutions.

## How Agents Use Web Search

Agents utilize web search capabilities to:

- **Research Solutions:** Find documentation, examples, and best practices for implementing features.
- **Stay Current:** Access the latest information about technologies, APIs, and development trends.
- **Verify Information:** Cross-reference facts and documentation from authoritative sources.
- **Gather Context:** Research domain-specific knowledge needed to better understand and solve problems.

## Implementation

Web search is automatically available to agents when needed, powered by exa&apos;s advanced search capabilities.

&lt;Card title=&quot;Learn more about Exa&quot; icon=&quot;globe&quot; href=&quot;https://exa.ai&quot;&gt;
  Discover how exa powers our web search capabilities with state-of-the-art
  search technology.
&lt;/Card&gt;

&lt;Note&gt;
  Agents automatically determine when to leverage web search to enhance their
  responses and solutions with current, relevant information.
&lt;/Note&gt;</file><file path="docs/introduction/about.mdx">---
title: &quot;Codegen, Inc.&quot;
sidebarTitle: &quot;About Us&quot;
icon: &quot;building&quot;
iconType: &quot;solid&quot;
---

&lt;Card
  img=&quot;/images/codegen.jpeg&quot;
  title=&quot;Codegen, Inc.&quot;
  href=&quot;https://codegen.com&quot;
/&gt;

## Our Mission

Our mission is to build fully-autonomous software engineering.

We believe the most effective path towards this goal is through intelligent AI agents that seamlessly integrate into existing developer workflows.

Our agents connect with tools developers use every day, like GitHub, Slack, and Linear, to automate tasks ranging from fixing bugs and implementing features to writing tests and improving documentation.

By handling routine development tasks, Codegen empowers engineers to focus on higher-level challenges and accelerates the entire software development lifecycle.

## The Team

Based in San Francisco, we&apos;re a team of engineers and researchers passionate about:

- Making large-scale code changes more accessible
- Building tools that work the way developers think
- Creating the infrastructure for AI-powered code manipulation
- Advancing the state of the art in program transformation

## Open Source

We believe in the power of open source software. Our core library, [codegen](https://github.com/codegen-sh/codegen-sdk), is freely available and open to contributions from the community.

## Join Us

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;Careers&quot; icon=&quot;briefcase&quot; href=&quot;https://codegen.com/careers&quot;&gt;
    We&apos;re hiring! Join us in building the future of code transformation.
  &lt;/Card&gt;
  &lt;Card title=&quot;Community&quot; icon=&quot;people-group&quot; href=&quot;/introduction/community&quot;&gt;
    Connect with other developers and share your Codegen experiences.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Connect with Us

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;X (Twitter)&quot; icon=&quot;twitter&quot; href=&quot;https://x.com/codegen&quot;&gt;
    Follow us for updates and announcements
  &lt;/Card&gt;
  &lt;Card
    title=&quot;LinkedIn&quot;
    icon=&quot;linkedin&quot;
    href=&quot;https://linkedin.com/company/codegen-dot-com&quot;
  &gt;
    Connect with our team and stay updated on company news
  &lt;/Card&gt;
&lt;/CardGroup&gt;

&lt;Note&gt;
  Want to learn more about what we&apos;re building? Check out our [getting started
  guide](/introduction/getting-started) or join our [community
  Slack](https://community.codegen.com).
&lt;/Note&gt;</file><file path="docs/introduction/cli.mdx">---
title: &quot;Codegen CLI&quot;
sidebarTitle: &quot;CLI&quot;
icon: &quot;terminal&quot;
iconType: &quot;solid&quot;
---

The `codegen` CLI is your terminal interface to Codegen agents. Use it to view agents, pull their work, create new agents, and run Claude Code with full telemetry and monitoring.

&lt;Frame&gt;
  &lt;video
    controls
    src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1757974837/CLI_pzot3r.mp4&quot;
    allowFullScreen
    className=&quot;aspect-[3840/2160]&quot;
  /&gt;
&lt;/Frame&gt;

It also wraps your local Claude Code, surfaces traces in the web UI for remote telemetry and analytics, and provides access to your Codegen integrations via MCP injection.

## Installation &amp; Setup

```bash
uv tool install codegen
```

The CLI uses your API token for authentication. Get your token and organization ID from the **[authentication guide](/api-reference/authentication)**.

```bash
codegen login
```

## Key Commands

### `codegen`

Launches the interactive terminal UI (TUI) for browsing agents, viewing runs, and managing your Codegen workflow from the terminal.

### `codegen login`

Store your API token for authentication. Supports both interactive login and direct token input.

```bash
# Interactive login
codegen login

# Direct token login
codegen login --token YOUR_API_TOKEN
```

### `codegen update`

Keep your CLI up to date with the latest features and improvements. The CLI automatically checks for updates daily and notifies you when new versions are available.

```bash
# Update to latest version
codegen update

# Check for updates without installing
codegen update --check

# Update to a specific version
codegen update --version 1.2.3

# Preview changes without updating
codegen update --dry-run
```

## What You Can Do

- **View and manage agents** - List agent runs, check status, and see detailed execution logs
- **Pull agent work** - Download branches and code changes created by agents directly to your local environment
- **Create new agents** - Trigger agent runs from the command line with custom prompts
- **Run Claude Code** - Execute Claude Code with OpenTelemetry monitoring and comprehensive logging
- **Manage organizations** - Switch between organizations and configure repositories
- **Stay up to date** - Built-in self-update system with automatic update notifications

&lt;Note&gt;
  The CLI provides the same capabilities as the web UI and API, optimized for
  terminal-based workflows and automation.
&lt;/Note&gt;

## Full Demo

&lt;iframe
  className=&quot;w-full aspect-video rounded-xl&quot;
  src=&quot;https://youtube.com/embed/sQ2XOonma0w&quot;
  title=&quot;YouTube video player&quot;
  frameBorder=&quot;0&quot;
  allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot;
  allowFullScreen
&gt;&lt;/iframe&gt;

## Get Started

import {
  COMMUNITY_SLACK_URL,
  CODEGEN_SDK_GITHUB_URL,
} from &quot;/snippets/links.mdx&quot;;

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;Create Account&quot; icon=&quot;user-plus&quot; href=&quot;https://codegen.sh/login&quot;&gt;
    Sign up for a free account and get your API token.
  &lt;/Card&gt;
  &lt;Card title=&quot;View on GitHub&quot; icon=&quot;github&quot; href={CODEGEN_SDK_GITHUB_URL}&gt;
    Star us on GitHub and contribute to the project.
  &lt;/Card&gt;
&lt;/CardGroup&gt;</file><file path="docs/introduction/community.mdx">---
title: &quot;Community &amp; Contributing&quot;
sidebarTitle: &quot;Community&quot;
icon: &quot;people-group&quot;
iconType: &quot;solid&quot;
---

import {
  COMMUNITY_SLACK_URL,
  CODEGEN_SDK_GITHUB_URL,
} from &quot;/snippets/links.mdx&quot;;

Join the growing Codegen community! We&apos;re excited to have you be part of our journey to make codebase manipulation and transformation more accessible.

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;Join our Slack&quot; icon=&quot;slack&quot; href={COMMUNITY_SLACK_URL}&gt;
    Connect with the community, get help, and share your Codegen projects in our
    active Slack workspace.
  &lt;/Card&gt;
  &lt;Card title=&quot;GitHub&quot; icon=&quot;github&quot; href={CODEGEN_SDK_GITHUB_URL}&gt;
    Star us on GitHub, report issues, submit PRs, and contribute to the project.
  &lt;/Card&gt;
  &lt;Card title=&quot;Twitter (X)&quot; icon=&quot;twitter&quot; href=&quot;https://twitter.com/codegen&quot;&gt;
    Follow us for updates, tips, and community highlights.
  &lt;/Card&gt;
  &lt;Card
    title=&quot;Documentation&quot;
    icon=&quot;book-open&quot;
    href=&quot;/introduction/getting-started&quot;
  &gt;
    Learn how to use Codegen effectively with our comprehensive guides.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

&lt;Tip&gt;
  Please help us improve this library and documentation by submitting a PR!
&lt;/Tip&gt;

## Contributing

We welcome contributions of all kinds! Whether you&apos;re fixing a typo in documentation, reporting a bug, or implementing a new feature, we appreciate your help in making Codegen better.

Check out our [Contributing Guide](https://github.com/codegen-sh/codegen-sdk/blob/develop/CONTRIBUTING.md) on GitHub to learn how to:

- Set up your development environment
- Submit pull requests
- Report issues
- Contribute to documentation</file><file path="docs/introduction/faq.mdx">---
title: &quot;Frequently Asked Questions&quot;
sidebarTitle: &quot;FAQ&quot;
icon: &quot;square-question&quot;
iconType: &quot;solid&quot;
---

&lt;AccordionGroup&gt;
  &lt;Accordion title=&quot;What languages does Codegen support?&quot; icon=&quot;code&quot;&gt;
    The Codegen AI agent leverages modern large language models (LLMs) for code
    understanding and generation. This means it can generally handle tasks
    involving any programming language, configuration format (like JSON, YAML),
    documentation (like Markdown), or other text-based files that current LLMs
    are proficient with. If you have specific needs or find limitations with a
    particular language or format, please let us know!
  &lt;/Accordion&gt;
  &lt;Accordion title=&quot;Is Codegen exact?&quot; icon=&quot;scale-balanced&quot;&gt;
    The Codegen agent uses large language models to understand and modify code.
    While powerful, its understanding isn&apos;t based on formal static analysis and
    may not always be perfectly exact or catch all edge cases like a traditional
    compiler or linter might. It aims for practical correctness based on the
    provided context and instructions.
  &lt;/Accordion&gt;
  &lt;Accordion title=&quot;Is Codegen suitable for large codebases?&quot; icon=&quot;database&quot;&gt;
    Yes! Codegen&apos;s agent is designed to work effectively on large, real-world
    codebases. You can provide context and specific instructions to help it
    navigate complex projects.
    &lt;Tip&gt;
      For enterprise use cases and support, please reach out to
      [team@codegen.com](mailto:team@codegen.com)
    &lt;/Tip&gt;
  &lt;/Accordion&gt;
  &lt;Accordion
    title=&quot;Can I use the Codegen SDK with my existing tools?&quot;
    icon=&quot;screwdriver-wrench&quot;
  &gt;
    Yes. The Codegen SDK is a standard Python package (`pip install codegen`).
    You can import and use it in your Python scripts, CI/CD pipelines, or any
    other development tool that can execute Python code.
  &lt;/Accordion&gt;
  &lt;Accordion
    title=&quot;How can I contribute if I&apos;m new to the project?&quot;
    icon=&quot;hand-holding-heart&quot;
  &gt;
    Start by trying out the Codegen agent and SDK, joining our [Slack
    community](https://community.codegen.com), and reporting any issues or
    feedback on [GitHub](https://github.com/codegen-sh/codegen-sdk). We welcome
    contributions to documentation, examples, and SDK improvements.
  &lt;/Accordion&gt;
  &lt;Accordion title=&quot;Where can I get help if I&apos;m stuck?&quot; icon=&quot;life-ring&quot;&gt;
    The best places to get help are: 1. Our community [Slack
    channel](https://community.codegen.com) 2. [GitHub
    issues](https://github.com/codegen-sh/codegen-sdk) for bug reports or SDK
    feature requests 3. Reach out to us on [Twitter](https://x.com/codegen)
  &lt;/Accordion&gt;
&lt;/AccordionGroup&gt;</file><file path="docs/introduction/guiding-principles.mdx">---
title: &quot;Guiding Principles&quot;
sidebarTitle: &quot;Principles&quot;
icon: &quot;compass&quot;
iconType: &quot;solid&quot;
---

Codegen was developed by working backwards from real-world, large-scale codebase migrations. Instead of starting with abstract syntax trees and parser theory, we started with the question: &quot;How do developers actually think about code changes?&quot;

This practical origin led to four core principles that shape Codegen&apos;s design:

## Intuitive APIs

Write code that reads like natural language, without worrying about abstract syntax trees or parser internals. Codegen provides high-level APIs that map directly to the transformations developers want to perform:

```python
# Methods that read like English
function.rename(&quot;new_name&quot;)  # Not ast.update_node(function_node, &quot;name&quot;, &quot;new_name&quot;)
function.move_to_file(&quot;new_file.py&quot;)  # Not ast.relocate_node(function_node, &quot;new_file.py&quot;)

# Clean, readable properties
if function.is_async:  # Not ast.get_node_attribute(function_node, &quot;async&quot;)
    print(function.name)  # Not ast.get_node_name(function_node)

# Natural iteration patterns
for usage in function.usages:  # Not ast.find_references(function_node)
    print(f&quot;Used in {usage.file.name}&quot;)
```

## No Sharp Edges

Focus on your high-level intent while Codegen handles the intricate details.

Codegen operations handle the edge cases - it should be hard to break lint.

```python
# Moving a function? Codegen handles:
function.move_to_file(&quot;new_file.py&quot;)
# âœ“ Updating all import statements
# âœ“ Preserving dependencies
# âœ“ Maintaining references
# âœ“ Fixing relative imports
# âœ“ Resolving naming conflicts

# Renaming a symbol? Codegen manages:
class_def.rename(&quot;NewName&quot;)
# âœ“ Updating all usages
# âœ“ Handling string references
# âœ“ Preserving docstrings
# âœ“ Maintaining inheritance
```

## Performance through Pre-Computation

Codegen frontloads as much as possible to enable fast, efficient transformations.

It is built with the insight that each codebase only needs to be parsed once per commit.

&lt;Tip&gt;
  Learn more about parsing the codebase graph in the [How it
  Works](/introduction/how-it-works) guide.
&lt;/Tip&gt;

## Python-First Composability

Codegen embraces Python&apos;s strength as a &quot;glue language&quot; - its ability to seamlessly integrate different tools and APIs. This makes it natural to compose Codegen with your existing toolchain:

- Build complex transforms by combining simpler operations
- Integrate Codegen with your existing tools (linters, type checkers, test frameworks, AI tools)

&lt;Note&gt;
  Python&apos;s rich ecosystem makes it ideal for code manipulation tasks. Codegen is
  designed to be one tool in your toolbox, not a replacement for your entire
  workflow.
&lt;/Note&gt;</file><file path="docs/introduction/how-it-works.mdx">---
title: &quot;Under the Hood&quot;
sidebarTitle: &quot;How it Works&quot;
icon: &quot;gear&quot;
iconType: &quot;solid&quot;
subtitle: &quot;How Codegen&apos;s codebase graph works&quot;
---

Codegen performs advanced static analysis to build a rich graph representation of your codebase. This pre-computation step analyzes dependencies, references, types, and control flow to enable fast and reliable code manipulation operations.

&lt;Note&gt;
  Codegen is built on top of
  [Tree-sitter](https://tree-sitter.github.io/tree-sitter/) and
  [rustworkx](https://github.com/Qiskit/rustworkx) and has implemented most
  language server features from scratch.
&lt;/Note&gt;
&lt;Info&gt;
  Codegen is open source. Check out the [source
  code](https://github.com/codegen-sh/codegen-sdk) to learn more!
&lt;/Info&gt;

## The Codebase Graph

At the heart of Codegen is a comprehensive graph representation of your code. When you initialize a [Codebase](/api-reference/core/Codebase), it performs static analysis to construct a rich graph structure connecting code elements:

```python
# Initialize and analyze the codebase
from codegen import Codebase
codebase = Codebase(&quot;./&quot;)

# Access pre-computed relationships
function = codebase.get_symbol(&quot;process_data&quot;)
print(f&quot;Dependencies: {function.dependencies}&quot;)  # Instant lookup
print(f&quot;Usages: {function.usages}&quot;)  # No parsing needed
```

### Building the Graph

Codegen&apos;s graph construction happens in two stages:

1. **AST Parsing**: We use [Tree-sitter](https://tree-sitter.github.io/tree-sitter/) as our foundation for parsing code into Abstract Syntax Trees. Tree-sitter provides fast, reliable parsing across multiple languages.

2. **Multi-file Graph Construction**: Custom parsing logic, implemented in [rustworkx](https://github.com/Qiskit/rustworkx) and Python, analyzes these ASTs to construct a more sophisticated graph structure. This graph captures relationships between [symbols](/building-with-codegen/symbol-api), [files](/building-with-codegen/files-and-directories), [imports](/building-with-codegen/imports), and more.

### Performance Through Pre-computation

Pre-computing a rich index enables Codegen to make certain operations very fast that that are relevant to refactors and code analysis:

- Finding all usages of a symbol
- Detecting circular dependencies
- Analyzing the dependency graphs
- Tracing call graphs
- Static analysis-based code retrieval for RAG
- ...etc.

&lt;Tip&gt;
  Pre-parsing the codebase enables constant-time lookups rather than requiring
  re-parsing or real-time analysis.
&lt;/Tip&gt;

## Multi-Language Support

One of Codegen&apos;s core principles is that many programming tasks are fundamentally similar across languages.

Currently, Codegen supports:

- [Python](/api-reference/python)
- [TypeScript](/api-reference/typescript)
- [React &amp; JSX](/building-with-codegen/react-and-jsx)

&lt;Note&gt;
  Learn about how Codegen handles language specifics in the [Language
  Support](/building-with-codegen/language-support) guide.
&lt;/Note&gt;

We&apos;ve started with these ecosystems but designed our architecture to be extensible. The graph-based approach provides a consistent interface across languages while handling language-specific details under the hood.

## Build with Us

Codegen is just getting started, and we&apos;re excited about the possibilities ahead. We enthusiastically welcome contributions from the community, whether it&apos;s:

- Adding support for new languages
- Implementing new analysis capabilities
- Improving performance
- Expanding the API
- Adding new transformations
- Improving documentation

Check out our [community guide](/introduction/community) to get involved!</file><file path="docs/introduction/overview.mdx">---
title: &quot;Codegen&quot;
sidebarTitle: &quot;Overview&quot;
icon: &quot;robot&quot;
iconType: &quot;solid&quot;
---

&lt;Frame&gt;
  &lt;video
    controls
    src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1758569401/Product_Demo_Video_x5kvaa.mp4&quot;
    className=&quot;aspect-[1920/1080]&quot;
  /&gt;
&lt;/Frame&gt;

[Codegen](https://codegen.com) helps you run frontier code agents at scale. It provides the necessary building blocks (sandboxes, integrations, telemetry) for successful enterprise code agent deployments across thousands of teams today.

&lt;Tip&gt;
  Focus on higher-level tasks and leverage Codegen agents to do the low-level
  labor of software engineering.
&lt;/Tip&gt;

Think of it as an AI coworker that can understand and solve coding challenges, access your codebase instantly, and interact directly with your development tools.

## What Can Codegen Agents Do?

Codegen agents come equipped with a versatile set of tools and capabilities:

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;Understand &amp; Solve Code Tasks&quot; icon=&quot;code-branch&quot;&gt;
    Analyze requirements, implement features, fix bugs, write tests, and improve
    documentation based on your prompts.
  &lt;/Card&gt;
  &lt;Card title=&quot;Chat in Slack&quot; icon=&quot;slack&quot; href=&quot;/integrations/slack&quot;&gt;
    Send notifications, ask for clarification, report progress, and interact
    directly with your team in Slack channels.
  &lt;/Card&gt;
  &lt;Card title=&quot;Manage Tickets&quot; icon=&quot;file-lines&quot; href=&quot;/integrations/linear&quot;&gt;
    Update statuses, add comments, link PRs to issues, and create new tasks.
    Support for Jira, Linear, Clickup and Monday.com.
  &lt;/Card&gt;
  &lt;Card
    title=&quot;Auto-Fix Broken Tests&quot;
    icon=&quot;github&quot;
    href=&quot;/capabilities/checks-autofixer&quot;
  &gt;
    Review PRs, suggest changes, comment on issues, create branches, commit
    code, and manage repositories.
  &lt;/Card&gt;
  &lt;Card title=&quot;Safely Execute Code&quot; icon=&quot;box&quot; href=&quot;/sandboxes/overview&quot;&gt;
    Safely run code, install dependencies, and test changes in robust isolated
    environments
  &lt;/Card&gt;
  &lt;Card
    title=&quot;Integrate with Your Dev Stack&quot;
    icon=&quot;plug&quot;
    href=&quot;/integrations/integrations&quot;
  &gt;
    Connect with Slack, Linear, Figma, databases, and extend capabilities with
    custom MCP tools.
  &lt;/Card&gt;
  &lt;Card title=&quot;Leave PR Reviews&quot; icon=&quot;plug&quot; href=&quot;/capabilities/pr-review&quot;&gt;
    Connect with Slack, Linear, Figma, databases, and extend capabilities with
    custom MCP tools.
  &lt;/Card&gt;
  &lt;Card
    title=&quot;Claude Code Integration&quot;
    icon=&quot;code&quot;
    href=&quot;/capabilities/claude-code&quot;
  &gt;
    Log local Claude Code instances to the cloud and provision MCP servers
    across your org.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Get Started in Minutes

Integrating Codegen into your workflow is designed to be quick and easy:

&lt;CardGroup cols={2}&gt;
  &lt;Card
    title=&quot;One-Click GitHub Install&quot;
    icon=&quot;github&quot;
    href=&quot;https://github.com/apps/codegen-sh&quot;
  &gt;
    Install the GitHub App to grant the agent access to your repositories. No
    complex setup required.
  &lt;/Card&gt;
  &lt;Card
    title=&quot;Connect Slack&quot;
    icon=&quot;slack&quot;
    href=&quot;https://codegen.sh/integrations&quot;
  &gt;
    Add the Codegen Slack App to communicate with the agent directly in your
    workspace.
  &lt;/Card&gt;
  &lt;Card
    title=&quot;Connect Linear&quot;
    icon=&quot;file-lines&quot;
    href=&quot;https://codegen.sh/integrations&quot;
  &gt;
    Connect your Linear workspace to enable agent interactions with your issues.
  &lt;/Card&gt;
  &lt;Card title=&quot;Use the API/SDK&quot; icon=&quot;code&quot; href=&quot;/introduction/api&quot;&gt;
    Programmatically interact with agents using the Python SDK for advanced
    automation.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Security &amp; Compliance

Codegen is [SOC 2 Type I &amp; II certified](https://codegen.com/security/soc2) and performs regular pen tests, ensuring your code and data are handled with the highest standards for security, privacy, and compliance.

Learn more about our security practices here.

&lt;CardGroup cols={2}&gt;
  &lt;Card
    title=&quot;Security Overview&quot;
    icon=&quot;shield&quot;
    href=&quot;https://codegen.com/security&quot;
  &gt;
    Details on Codegen&apos;s security practices and more
  &lt;/Card&gt;
  &lt;Card title=&quot;Trust Center&quot; icon=&quot;shield&quot; href=&quot;https://trust.codegen.com/&quot;&gt;
    View SOC-2 documents and pen test results
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Install Now

Create an account via Github OAuth and install our [Github application](https://github.com/apps/codegen-sh) to get started.

&lt;CardGroup cols={1}&gt;
  &lt;Card title=&quot;Codegen.com&quot; href=&quot;https://codegen.com/login&quot;&gt;
    Codegen&apos;s Github app is free to install. Get started in just a few clicks.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Learn More

&lt;CardGroup cols={2}&gt;
  &lt;Card
    title=&quot;Join the Community&quot;
    icon=&quot;people-group&quot;
    href=&quot;/introduction/community&quot;
  &gt;
    Connect with other developers, get help, and share your experiences in our
    active Slack workspace.
  &lt;/Card&gt;
  &lt;Card title=&quot;About Codegen&quot; icon=&quot;building&quot; href=&quot;/introduction/about&quot;&gt;
    Learn about our mission to build fully-autonomous software engineering and
    meet the team.
  &lt;/Card&gt;
&lt;/CardGroup&gt;</file><file path="docs/introduction/prompting.mdx">---
title: &quot;Effective Prompting&quot;
sidebarTitle: &quot;Prompting&quot;
icon: &quot;lightbulb&quot;
iconType: &quot;solid&quot;
---

To get the best results from Codegen, treat it like a skilled teammate: provide clear, specific instructions and sufficient context. Vague requests lead to ambiguous outcomes.

&lt;Tip&gt;
  Codegen is based on Anthropic&apos;s Claude 4 Sonnet. You can prompt it similarly to
  ChatGPT or other LLM-based assistants
&lt;/Tip&gt;

## The Core Principle: Specificity

Instead of &quot;Fix the user service,&quot; try:

&gt; In the `my-web-app` repo (PR #42), refactor the `UserService` class in `src/services/user.ts` to use the `UserRepository` pattern shown in `ProductService`/`ProductRepository`.

If there are specific implementation details you want included, make sure to specify. For example:

&gt; Ensure all tests in `tests/services/user.test.ts` pass and add new tests for the repository with 90%+ coverage. Update the diagram in `docs/architecture/user-service.md`.

## Elements of a Strong Prompt

1.  **Scope:** What repository, branch, or files are involved? (e.g., `my-web-app` repo, `PR #42`, `src/services/user.ts`)
2.  **Goal:** What is the high-level objective? (e.g., Refactor `UserService`, improve testability)
3.  **Tasks:** What specific actions should the agent take? Use a numbered or bulleted list for clarity. (e.g., Extract logic to `UserRepository`, use dependency injection, update tests, update diagram)
4.  **Context/Patterns:** Are there existing patterns, examples, or documentation to reference? (e.g., `ProductService`, `ProductRepository`)
5.  **Success Criteria:** How will you know the task is done correctly? (e.g., Tests pass, 90%+ coverage, diagram updated)

&lt;Note&gt;
  Clear, detailed prompts empower Codegen agents to deliver accurate results
  faster, significantly streamlining your workflow.
&lt;/Note&gt;</file><file path="docs/introduction/sdk.mdx">---
title: &quot;Python SDK&quot;
sidebarTitle: &quot;Python SDK&quot;
icon: &quot;python&quot;
---

The [Codegen SDK](https://github.com/codegen-sh/codegen-sdk) is a thin pythonic wrapper around the **[Codegen API](/api-reference/overview)** with all the same capabilities for creating and managing AI agents programmatically.

&lt;Tip&gt;
  Go to [developer settings](https://codegen.sh/token) to generate an API token
&lt;/Tip&gt;

```python
from codegen import Agent

# Initialize the Agent with your organization ID and API token
agent = Agent(org_id=&quot;...&quot;, token=&quot;...&quot;)

# Run an agent with a prompt
task = agent.run(prompt=&quot;Leave a review on PR #123&quot;)

# Check the initial status
print(task.status)

# Refresh the task to get updated status (tasks can take time)
task.refresh()

if task.status == &quot;completed&quot;:
    print(task.result)  # Result often contains code, summaries, or links
```

## Installation

Install the [codegen](https://pypi.org/project/codegen/) package from PyPI using your preferred package manager:

```bash
# Using pip
pip install codegen

# Using pipx (for CLI usage)
pipx install codegen

# Using uv
uv pip install codegen
# or
uv tool install codegen
```

### Keeping Up to Date

The CLI includes a built-in self-update system that checks for updates daily:

```bash
# Update to latest version
codegen update

# Check for updates
codegen update --check
```

## Get Started

import {
  COMMUNITY_SLACK_URL,
  CODEGEN_SDK_GITHUB_URL,
} from &quot;/snippets/links.mdx&quot;;

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;Create Account&quot; icon=&quot;user-plus&quot; href=&quot;https://codegen.sh/login&quot;&gt;
    Sign up for a free account and get your API token.
  &lt;/Card&gt;
  &lt;Card title=&quot;Join our Slack&quot; icon=&quot;slack&quot; href={COMMUNITY_SLACK_URL}&gt;
    Get help and connect with the Codegen community.
  &lt;/Card&gt;
  &lt;Card title=&quot;Tutorials&quot; icon=&quot;diagram-project&quot; href=&quot;/tutorials/at-a-glance&quot;&gt;
    Learn how to use Codegen for common code transformation tasks.
  &lt;/Card&gt;
  &lt;Card title=&quot;View on GitHub&quot; icon=&quot;github&quot; href={CODEGEN_SDK_GITHUB_URL}&gt;
    Star us on GitHub and contribute to the project.
  &lt;/Card&gt;
&lt;/CardGroup&gt;</file><file path="docs/introduction/support.mdx">---
title: &quot;Support&quot;
sidebarTitle: &quot;Support&quot;
icon: &quot;headset&quot;
---

Need help with Codegen? We&apos;re here to support you every step of the way.

## Get Help

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;Email Support&quot; icon=&quot;envelope&quot; href=&quot;mailto:support@codegen.com&quot;&gt;
    Email us directly at support@codegen.com for technical issues and questions.
  &lt;/Card&gt;

  &lt;Card
    title=&quot;Community Slack&quot;
    icon=&quot;slack&quot;
    href=&quot;https://community.codegen.com&quot;
  &gt;
    Join our active community for peer support, tips, and discussions.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Team Plans &amp; Above

All Team plans and above get a **shared Slack channel with our team** for direct access to Codegen engineers and priority support.

## Enterprise Support

&lt;Tip&gt;
  Codegen offers forward deployed engagements for organizations looking for
  hands-on implementation support. Get in touch if you need dedicated assistance
  with your Codegen deployment.
&lt;/Tip&gt;

&lt;Note&gt;
  Response times vary by plan level. Team and Enterprise customers receive
  priority support with faster response times.
&lt;/Note&gt;</file><file path="docs/introduction/use-cases.mdx">---
title: &quot;Use Cases&quot;
sidebarTitle: &quot;Use Cases&quot;
icon: &quot;lightbulb&quot;
iconType: &quot;solid&quot;
---

This page provides an LLM-generated summary of how teams are using Codegen agents, based on analysis of tens of thousands of customer agent runs. The data represents actual requests from users across different organizations and communication channels.

## ðŸ—ï¸ Code Development &amp; Implementation (35%)

The most common use case for Codegen agents is building new functionality and applications from scratch.

**Full-stack app creation**
- Complete Next.js/React applications with production-ready UI/UX
- End-to-end web applications with authentication, databases, and deployment
- Mobile and desktop applications across different platforms

**Feature implementation**
- Adding new functionality to existing codebases
- Implementing user stories and product requirements
- Building complex business logic and workflows

**API development**
- Creating REST and GraphQL endpoints
- Third-party service integrations
- Microservices architecture and implementation

**Database work**
- Schema design and migrations
- Complex queries and data analysis
- Database optimization and performance tuning

## ðŸ” Code Review &amp; Analysis (25%)

Teams heavily rely on Codegen for thorough code analysis and quality assurance.

**PR reviews**
- Deep code analysis with inline suggestions
- Bug detection and security vulnerability identification
- Code quality and best practices validation

**Codebase audits**
- Performance analysis and optimization recommendations
- Security reviews and compliance checks
- Technical debt assessment and prioritization

**Architecture reviews**
- Design pattern validation and improvements
- System architecture recommendations
- Code organization and structure analysis

**Migration analysis**
- Impact assessment for major changes
- Legacy system modernization planning
- Framework and library upgrade guidance

## ðŸ› ï¸ Bug Fixes &amp; Maintenance (20%)

Codegen agents excel at debugging and maintaining existing systems.

**Issue resolution**
- Debugging complex problems across the stack
- Root cause analysis and systematic fixes
- Error handling and edge case management

**Dependency updates**
- Package management and version conflict resolution
- Security patch application
- Breaking change migration assistance

**Configuration fixes**
- Build system troubleshooting
- Deployment pipeline optimization
- Environment setup and configuration management

**Performance optimization**
- Identifying and resolving bottlenecks
- Memory and CPU usage optimization
- Database query performance improvements

## ðŸ“‹ Project Management &amp; Documentation (10%)

Teams use Codegen to streamline project workflows and maintain documentation.

**Linear ticket management**
- Creating and organizing development tasks
- Sprint planning and backlog management
- Progress tracking and status updates

**Documentation creation**
- README files and setup instructions
- API documentation and guides
- Technical specifications and architecture docs

**Project scoping**
- Breaking down large features into manageable tasks
- Effort estimation and timeline planning
- Risk assessment and mitigation strategies

**Workflow automation**
- CI/CD pipeline setup and optimization
- Development process standardization
- Quality gates and automated checks

## ðŸ¤– AI/ML &amp; Specialized Tasks (5%)

Advanced use cases involving specialized tools and integrations.

**Feature flag cleanup**
- Statsig and A/B testing tool maintenance
- Experimental feature management
- Configuration cleanup and optimization

**Data analysis**
- SQL queries and business intelligence
- Performance metrics and analytics
- Data pipeline development and maintenance

**Integration work**
- Third-party API connections
- Webhook setup and management
- Service-to-service communication

**Custom tooling**
- Specialized utilities and automation scripts
- Developer productivity tools
- Internal service development

## ðŸ’¬ Communication Channels

**Linear (35%)**
- Primarily used for ticket management and feature requests
- Project planning and sprint organization
- Task assignment and progress tracking

**Chat/API (30%)**
- Development tasks and quick fixes
- Real-time problem solving
- Interactive debugging sessions

**Slack (20%)**
- Team collaboration and questions
- Code reviews and discussions
- Knowledge sharing and support

**GitHub (15%)**
- Pull request reviews and management
- Repository maintenance and organization
- Release planning and deployment

## ðŸŽ¯ Key Insights

1. **Most common request**: &quot;Review this PR&quot; - developers want thorough, automated code analysis
2. **Growing trend**: Full-stack application development from scratch with production-ready requirements
3. **High value tasks**: Complex debugging, architecture decisions, and system design
4. **Quick wins**: Documentation updates, simple feature additions, and configuration fixes
5. **Team efficiency**: Agents handle routine tasks, allowing developers to focus on creative problem-solving

## Getting Started

Ready to leverage these use cases for your team? Check out our [overview](/introduction/overview) to get started, or explore specific [capabilities](/capabilities/capabilities) that align with your needs.</file><file path="docs/logo/dark.svg">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;svg id=&quot;Layer_2&quot; data-name=&quot;Layer 2&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 416.62 84.74&quot;&gt;
  &lt;defs&gt;
    &lt;style&gt;
      .cls-1 {
        fill: #ffffff;
        stroke-width: 0px;
      }

      .cls-2 {
        isolation: isolate;
      }
    &lt;/style&gt;
  &lt;/defs&gt;
  &lt;g id=&quot;Layer_1-2&quot; data-name=&quot;Layer 1-2&quot;&gt;
    &lt;g class=&quot;cls-2&quot;&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M129.47,69.08c-4.86,0-9.31-1.2-13.35-3.6-4.05-2.4-7.25-5.74-9.6-10.03-2.35-4.28-3.52-9.14-3.52-14.57s1.18-10.29,3.52-14.57c2.35-4.28,5.55-7.62,9.6-10.03,4.05-2.4,8.5-3.6,13.35-3.6,4.44,0,8.39.94,11.87,2.82,3.47,1.88,6.29,4.35,8.46,7.4,2.17,3.06,3.64,6.33,4.43,9.83h-10.26c-.58-1.88-1.52-3.6-2.82-5.17-1.31-1.57-2.96-2.82-4.97-3.76-2.01-.94-4.24-1.41-6.7-1.41-3.03,0-5.8.77-8.3,2.31-2.51,1.54-4.48,3.71-5.91,6.5-1.44,2.79-2.15,6.02-2.15,9.67s.72,6.88,2.15,9.67c1.44,2.79,3.41,4.96,5.91,6.5,2.51,1.54,5.27,2.31,8.3,2.31,3.76,0,6.91-1.03,9.44-3.09,2.53-2.06,4.22-4.61,5.05-7.64h10.26c-.73,3.55-2.17,6.88-4.31,9.99-2.14,3.11-4.95,5.63-8.42,7.56-3.47,1.93-7.48,2.9-12.02,2.9Z&quot;/&gt;
      &lt;/g&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M178.08,69.08c-3.76,0-7.17-.89-10.22-2.66-3.05-1.77-5.46-4.23-7.21-7.36-1.75-3.13-2.62-6.66-2.62-10.57s.87-7.44,2.62-10.57c1.75-3.13,4.15-5.59,7.21-7.36,3.06-1.77,6.46-2.66,10.22-2.66s7.25.89,10.3,2.66c3.06,1.78,5.46,4.23,7.21,7.36,1.75,3.13,2.62,6.66,2.62,10.57s-.88,7.44-2.62,10.57c-1.75,3.13-4.15,5.59-7.21,7.36-3.05,1.78-6.49,2.66-10.3,2.66ZM178.08,60.22c1.93,0,3.71-.48,5.33-1.45,1.62-.96,2.91-2.35,3.88-4.15.97-1.8,1.45-3.85,1.45-6.15s-.48-4.35-1.45-6.15c-.97-1.8-2.26-3.18-3.88-4.15-1.62-.97-3.4-1.45-5.33-1.45s-3.71.48-5.33,1.45c-1.62.97-2.9,2.35-3.84,4.15-.94,1.8-1.41,3.85-1.41,6.15s.47,4.35,1.41,6.15c.94,1.8,2.22,3.19,3.84,4.15,1.62.97,3.39,1.45,5.33,1.45Z&quot;/&gt;
      &lt;/g&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M220.2,69.08c-3.39,0-6.49-.87-9.28-2.62-2.79-1.75-5-4.18-6.62-7.28-1.62-3.11-2.43-6.67-2.43-10.69s.81-7.58,2.43-10.69c1.62-3.11,3.82-5.53,6.62-7.28,2.79-1.75,5.89-2.62,9.28-2.62,2.56,0,4.82.48,6.78,1.45,1.96.97,3.51,2.15,4.66,3.56h.39V13.46h9.48v54.83h-8.22l-.78-4.54h-.39c-1.25,1.62-2.87,2.91-4.86,3.88-1.99.97-4.33,1.45-7.05,1.45ZM221.69,60.3c1.93,0,3.68-.5,5.25-1.49s2.81-2.38,3.72-4.15c.91-1.77,1.37-3.84,1.37-6.19s-.46-4.41-1.37-6.19c-.91-1.77-2.15-3.15-3.72-4.11-1.57-.97-3.32-1.45-5.25-1.45s-3.6.48-5.17,1.45c-1.57.97-2.81,2.34-3.72,4.11-.91,1.78-1.37,3.84-1.37,6.19s.46,4.41,1.37,6.19c.91,1.78,2.15,3.16,3.72,4.15s3.29,1.49,5.17,1.49Z&quot;/&gt;
      &lt;/g&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M267.43,69.08c-3.76,0-7.18-.89-10.26-2.66-3.08-1.77-5.5-4.23-7.25-7.36-1.75-3.13-2.62-6.66-2.62-10.57s.87-7.44,2.62-10.57c1.75-3.13,4.16-5.59,7.25-7.36,3.08-1.77,6.5-2.66,10.26-2.66s6.89.86,9.87,2.58c2.98,1.72,5.31,4.09,7.01,7.09,1.7,3,2.55,6.33,2.55,9.99,0,.89-.04,1.71-.12,2.47-.08.76-.17,1.29-.27,1.61h-29.69c.21,1.83.81,3.47,1.8,4.94.99,1.46,2.26,2.58,3.8,3.37,1.54.78,3.22,1.17,5.05,1.17,1.98,0,3.72-.42,5.21-1.25,1.49-.83,2.62-1.85,3.41-3.05h9.71c-.68,2.04-1.82,3.98-3.41,5.84s-3.64,3.39-6.15,4.62-5.43,1.84-8.77,1.84ZM277.46,45.19c-.21-1.77-.76-3.38-1.64-4.82-.89-1.44-2.05-2.57-3.49-3.41-1.44-.83-3.07-1.25-4.9-1.25-1.93,0-3.66.42-5.17,1.25-1.52.84-2.74,1.97-3.68,3.41-.94,1.44-1.54,3.04-1.8,4.82h20.68Z&quot;/&gt;
      &lt;/g&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M310.46,84.74c-4.13,0-7.59-.76-10.38-2.27-2.79-1.52-4.87-3.4-6.23-5.64-1.36-2.25-2.09-4.44-2.19-6.58h9.63c.16.99.57,1.96,1.25,2.9.68.94,1.68,1.71,3.02,2.31,1.33.6,2.96.9,4.9.9,2.87,0,5.17-.82,6.89-2.47,1.72-1.64,2.58-3.85,2.58-6.62v-5.64h-.39c-1.1,1.31-2.62,2.36-4.58,3.17-1.96.81-4.11,1.21-6.46,1.21-3.39,0-6.46-.81-9.2-2.43-2.74-1.62-4.9-3.88-6.46-6.78s-2.35-6.17-2.35-9.83.78-7.01,2.35-9.91c1.57-2.9,3.72-5.16,6.46-6.78,2.74-1.62,5.81-2.43,9.2-2.43,2.51,0,4.74.46,6.7,1.37,1.96.92,3.59,2.18,4.9,3.8h.39l.78-4.39h8.15v38.69c0,3.45-.74,6.49-2.23,9.13-1.49,2.64-3.67,4.67-6.54,6.11-2.87,1.44-6.27,2.15-10.18,2.15ZM309.98,57.64c1.83,0,3.51-.46,5.05-1.37,1.54-.91,2.74-2.18,3.6-3.8.86-1.62,1.29-3.45,1.29-5.48s-.43-3.86-1.29-5.48c-.86-1.62-2.06-2.88-3.6-3.8-1.54-.91-3.23-1.37-5.05-1.37s-3.51.46-5.05,1.37c-1.54.91-2.74,2.18-3.6,3.8-.86,1.62-1.29,3.45-1.29,5.48s.43,3.87,1.29,5.48c.86,1.62,2.06,2.89,3.6,3.8,1.54.91,3.22,1.37,5.05,1.37Z&quot;/&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M355.18,69.08c-3.76,0-7.18-.89-10.26-2.66-3.08-1.77-5.5-4.23-7.25-7.36-1.75-3.13-2.62-6.66-2.62-10.57s.87-7.44,2.62-10.57c1.75-3.13,4.16-5.59,7.25-7.36,3.08-1.77,6.5-2.66,10.26-2.66s6.89.86,9.87,2.58c2.98,1.72,5.31,4.09,7.01,7.09,1.7,3,2.55,6.33,2.55,9.99,0,.89-.04,1.71-.12,2.47-.08.76-.17,1.29-.27,1.61h-29.69c.21,1.83.81,3.47,1.8,4.94.99,1.46,2.26,2.58,3.8,3.37,1.54.78,3.22,1.17,5.05,1.17,1.98,0,3.72-.42,5.21-1.25,1.49-.83,2.62-1.85,3.41-3.05h9.71c-.68,2.04-1.82,3.98-3.41,5.84s-3.64,3.39-6.15,4.62c-2.51,1.23-5.43,1.84-8.77,1.84ZM365.21,45.19c-.21-1.77-.76-3.38-1.65-4.82-.89-1.44-2.05-2.57-3.49-3.41-1.44-.83-3.07-1.25-4.9-1.25-1.93,0-3.66.42-5.17,1.25-1.51.84-2.74,1.97-3.68,3.41-.94,1.44-1.54,3.04-1.8,4.82h20.68Z&quot;/&gt;
      &lt;/g&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M380.2,68.29V28.66h8.22l.78,3.84h.39c.94-1.2,2.4-2.27,4.39-3.21,1.98-.94,4.31-1.41,6.97-1.41,3.03,0,5.73.69,8.11,2.08,2.38,1.38,4.23,3.34,5.56,5.88,1.33,2.53,2,5.42,2,8.66v23.81h-9.48v-22.56c0-1.72-.37-3.25-1.1-4.58-.73-1.33-1.75-2.38-3.05-3.13-1.31-.76-2.77-1.14-4.39-1.14-1.72,0-3.26.39-4.62,1.17-1.36.78-2.42,1.84-3.17,3.17-.76,1.33-1.14,2.83-1.14,4.5v22.56h-9.48Z&quot;/&gt;
      &lt;/g&gt;
    &lt;/g&gt;
    &lt;g&gt;
      &lt;path class=&quot;cls-1&quot; d=&quot;M57.34,27.51c-.79.79-.79,2.07,0,2.86l8.64,8.64c.79.79.79,2.07,0,2.86l-8.64,8.64c-.79.79-.79,2.07,0,2.86l4.29,4.29c.79.79,2.07.79,2.86,0l15.79-15.79c.79-.79.79-2.07,0-2.86l-15.79-15.79c-.79-.79-2.07-.79-2.86,0,0,0-4.29,4.29-4.29,4.29Z&quot;/&gt;
      &lt;path class=&quot;cls-1&quot; d=&quot;M50.19,60.51c-.79-.79-2.07-.79-2.86,0l-5.47,5.47c-.79.79-2.07.79-2.86,0l-24.12-24.12c-.79-.79-.79-2.07,0-2.86l24.12-24.12c.79-.79,2.07-.79,2.86,0l5.47,5.47c.79.79,2.07.79,2.86,0l4.29-4.29c.79-.79.79-2.07,0-2.86L41.86.59c-.79-.79-2.07-.79-2.86,0L.59,39.01c-.79.79-.79,2.07,0,2.86l38.41,38.41c.79.79,2.07.79,2.86,0l12.62-12.62c.79-.79.79-2.07,0-2.86,0,0-4.29-4.29-4.29-4.29Z&quot;/&gt;
      &lt;path class=&quot;cls-1&quot; d=&quot;M50.54,40.44c0,5.58-4.53,10.11-10.11,10.11s-10.11-4.53-10.11-10.11,4.53-10.11,10.11-10.11,10.11,4.53,10.11,10.11Z&quot;/&gt;
    &lt;/g&gt;
  &lt;/g&gt;
&lt;/svg&gt;</file><file path="docs/logo/light.svg">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;svg id=&quot;Layer_2&quot; data-name=&quot;Layer 2&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 416.62 84.74&quot;&gt;
  &lt;defs&gt;
    &lt;style&gt;
      .cls-1 {
        fill: #000000;
        stroke-width: 0px;
      }

      .cls-2 {
        isolation: isolate;
      }
    &lt;/style&gt;
  &lt;/defs&gt;
  &lt;g id=&quot;Layer_1-2&quot; data-name=&quot;Layer 1-2&quot;&gt;
    &lt;g class=&quot;cls-2&quot;&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M129.47,69.08c-4.86,0-9.31-1.2-13.35-3.6-4.05-2.4-7.25-5.74-9.6-10.03-2.35-4.28-3.52-9.14-3.52-14.57s1.18-10.29,3.52-14.57c2.35-4.28,5.55-7.62,9.6-10.03,4.05-2.4,8.5-3.6,13.35-3.6,4.44,0,8.39.94,11.87,2.82,3.47,1.88,6.29,4.35,8.46,7.4,2.17,3.06,3.64,6.33,4.43,9.83h-10.26c-.58-1.88-1.52-3.6-2.82-5.17-1.31-1.57-2.96-2.82-4.97-3.76-2.01-.94-4.24-1.41-6.7-1.41-3.03,0-5.8.77-8.3,2.31-2.51,1.54-4.48,3.71-5.91,6.5-1.44,2.79-2.15,6.02-2.15,9.67s.72,6.88,2.15,9.67c1.44,2.79,3.41,4.96,5.91,6.5,2.51,1.54,5.27,2.31,8.3,2.31,3.76,0,6.91-1.03,9.44-3.09,2.53-2.06,4.22-4.61,5.05-7.64h10.26c-.73,3.55-2.17,6.88-4.31,9.99-2.14,3.11-4.95,5.63-8.42,7.56-3.47,1.93-7.48,2.9-12.02,2.9Z&quot;/&gt;
      &lt;/g&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M178.08,69.08c-3.76,0-7.17-.89-10.22-2.66-3.05-1.77-5.46-4.23-7.21-7.36-1.75-3.13-2.62-6.66-2.62-10.57s.87-7.44,2.62-10.57c1.75-3.13,4.15-5.59,7.21-7.36,3.06-1.77,6.46-2.66,10.22-2.66s7.25.89,10.3,2.66c3.06,1.78,5.46,4.23,7.21,7.36,1.75,3.13,2.62,6.66,2.62,10.57s-.88,7.44-2.62,10.57c-1.75,3.13-4.15,5.59-7.21,7.36-3.05,1.78-6.49,2.66-10.3,2.66ZM178.08,60.22c1.93,0,3.71-.48,5.33-1.45,1.62-.96,2.91-2.35,3.88-4.15.97-1.8,1.45-3.85,1.45-6.15s-.48-4.35-1.45-6.15c-.97-1.8-2.26-3.18-3.88-4.15-1.62-.97-3.4-1.45-5.33-1.45s-3.71.48-5.33,1.45c-1.62.97-2.9,2.35-3.84,4.15-.94,1.8-1.41,3.85-1.41,6.15s.47,4.35,1.41,6.15c.94,1.8,2.22,3.19,3.84,4.15,1.62.97,3.39,1.45,5.33,1.45Z&quot;/&gt;
      &lt;/g&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M220.2,69.08c-3.39,0-6.49-.87-9.28-2.62-2.79-1.75-5-4.18-6.62-7.28-1.62-3.11-2.43-6.67-2.43-10.69s.81-7.58,2.43-10.69c1.62-3.11,3.82-5.53,6.62-7.28,2.79-1.75,5.89-2.62,9.28-2.62,2.56,0,4.82.48,6.78,1.45,1.96.97,3.51,2.15,4.66,3.56h.39V13.46h9.48v54.83h-8.22l-.78-4.54h-.39c-1.25,1.62-2.87,2.91-4.86,3.88-1.99.97-4.33,1.45-7.05,1.45ZM221.69,60.3c1.93,0,3.68-.5,5.25-1.49s2.81-2.38,3.72-4.15c.91-1.77,1.37-3.84,1.37-6.19s-.46-4.41-1.37-6.19c-.91-1.77-2.15-3.15-3.72-4.11-1.57-.97-3.32-1.45-5.25-1.45s-3.6.48-5.17,1.45c-1.57.97-2.81,2.34-3.72,4.11-.91,1.78-1.37,3.84-1.37,6.19s.46,4.41,1.37,6.19c.91,1.78,2.15,3.16,3.72,4.15s3.29,1.49,5.17,1.49Z&quot;/&gt;
      &lt;/g&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M267.43,69.08c-3.76,0-7.18-.89-10.26-2.66-3.08-1.77-5.5-4.23-7.25-7.36-1.75-3.13-2.62-6.66-2.62-10.57s.87-7.44,2.62-10.57c1.75-3.13,4.16-5.59,7.25-7.36,3.08-1.77,6.5-2.66,10.26-2.66s6.89.86,9.87,2.58c2.98,1.72,5.31,4.09,7.01,7.09,1.7,3,2.55,6.33,2.55,9.99,0,.89-.04,1.71-.12,2.47-.08.76-.17,1.29-.27,1.61h-29.69c.21,1.83.81,3.47,1.8,4.94.99,1.46,2.26,2.58,3.8,3.37,1.54.78,3.22,1.17,5.05,1.17,1.98,0,3.72-.42,5.21-1.25,1.49-.83,2.62-1.85,3.41-3.05h9.71c-.68,2.04-1.82,3.98-3.41,5.84s-3.64,3.39-6.15,4.62-5.43,1.84-8.77,1.84ZM277.46,45.19c-.21-1.77-.76-3.38-1.64-4.82-.89-1.44-2.05-2.57-3.49-3.41-1.44-.83-3.07-1.25-4.9-1.25-1.93,0-3.66.42-5.17,1.25-1.52.84-2.74,1.97-3.68,3.41-.94,1.44-1.54,3.04-1.8,4.82h20.68Z&quot;/&gt;
      &lt;/g&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M310.46,84.74c-4.13,0-7.59-.76-10.38-2.27-2.79-1.52-4.87-3.4-6.23-5.64-1.36-2.25-2.09-4.44-2.19-6.58h9.63c.16.99.57,1.96,1.25,2.9.68.94,1.68,1.71,3.02,2.31,1.33.6,2.96.9,4.9.9,2.87,0,5.17-.82,6.89-2.47,1.72-1.64,2.58-3.85,2.58-6.62v-5.64h-.39c-1.1,1.31-2.62,2.36-4.58,3.17-1.96.81-4.11,1.21-6.46,1.21-3.39,0-6.46-.81-9.2-2.43-2.74-1.62-4.9-3.88-6.46-6.78s-2.35-6.17-2.35-9.83.78-7.01,2.35-9.91c1.57-2.9,3.72-5.16,6.46-6.78,2.74-1.62,5.81-2.43,9.2-2.43,2.51,0,4.74.46,6.7,1.37,1.96.92,3.59,2.18,4.9,3.8h.39l.78-4.39h8.15v38.69c0,3.45-.74,6.49-2.23,9.13-1.49,2.64-3.67,4.67-6.54,6.11-2.87,1.44-6.27,2.15-10.18,2.15ZM309.98,57.64c1.83,0,3.51-.46,5.05-1.37,1.54-.91,2.74-2.18,3.6-3.8.86-1.62,1.29-3.45,1.29-5.48s-.43-3.86-1.29-5.48c-.86-1.62-2.06-2.88-3.6-3.8-1.54-.91-3.23-1.37-5.05-1.37s-3.51.46-5.05,1.37c-1.54.91-2.74,2.18-3.6,3.8-.86,1.62-1.29,3.45-1.29,5.48s.43,3.87,1.29,5.48c.86,1.62,2.06,2.89,3.6,3.8,1.54.91,3.22,1.37,5.05,1.37Z&quot;/&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M355.18,69.08c-3.76,0-7.18-.89-10.26-2.66-3.08-1.77-5.5-4.23-7.25-7.36-1.75-3.13-2.62-6.66-2.62-10.57s.87-7.44,2.62-10.57c1.75-3.13,4.16-5.59,7.25-7.36,3.08-1.77,6.5-2.66,10.26-2.66s6.89.86,9.87,2.58c2.98,1.72,5.31,4.09,7.01,7.09,1.7,3,2.55,6.33,2.55,9.99,0,.89-.04,1.71-.12,2.47-.08.76-.17,1.29-.27,1.61h-29.69c.21,1.83.81,3.47,1.8,4.94.99,1.46,2.26,2.58,3.8,3.37,1.54.78,3.22,1.17,5.05,1.17,1.98,0,3.72-.42,5.21-1.25,1.49-.83,2.62-1.85,3.41-3.05h9.71c-.68,2.04-1.82,3.98-3.41,5.84s-3.64,3.39-6.15,4.62c-2.51,1.23-5.43,1.84-8.77,1.84ZM365.21,45.19c-.21-1.77-.76-3.38-1.65-4.82-.89-1.44-2.05-2.57-3.49-3.41-1.44-.83-3.07-1.25-4.9-1.25-1.93,0-3.66.42-5.17,1.25-1.51.84-2.74,1.97-3.68,3.41-.94,1.44-1.54,3.04-1.8,4.82h20.68Z&quot;/&gt;
      &lt;/g&gt;
      &lt;g class=&quot;cls-2&quot;&gt;
        &lt;path class=&quot;cls-1&quot; d=&quot;M380.2,68.29V28.66h8.22l.78,3.84h.39c.94-1.2,2.4-2.27,4.39-3.21,1.98-.94,4.31-1.41,6.97-1.41,3.03,0,5.73.69,8.11,2.08,2.38,1.38,4.23,3.34,5.56,5.88,1.33,2.53,2,5.42,2,8.66v23.81h-9.48v-22.56c0-1.72-.37-3.25-1.1-4.58-.73-1.33-1.75-2.38-3.05-3.13-1.31-.76-2.77-1.14-4.39-1.14-1.72,0-3.26.39-4.62,1.17-1.36.78-2.42,1.84-3.17,3.17-.76,1.33-1.14,2.83-1.14,4.5v22.56h-9.48Z&quot;/&gt;
      &lt;/g&gt;
    &lt;/g&gt;
    &lt;g&gt;
      &lt;path class=&quot;cls-1&quot; d=&quot;M57.34,27.51c-.79.79-.79,2.07,0,2.86l8.64,8.64c.79.79.79,2.07,0,2.86l-8.64,8.64c-.79.79-.79,2.07,0,2.86l4.29,4.29c.79.79,2.07.79,2.86,0l15.79-15.79c.79-.79.79-2.07,0-2.86l-15.79-15.79c-.79-.79-2.07-.79-2.86,0,0,0-4.29,4.29-4.29,4.29Z&quot;/&gt;
      &lt;path class=&quot;cls-1&quot; d=&quot;M50.19,60.51c-.79-.79-2.07-.79-2.86,0l-5.47,5.47c-.79.79-2.07.79-2.86,0l-24.12-24.12c-.79-.79-.79-2.07,0-2.86l24.12-24.12c.79-.79,2.07-.79,2.86,0l5.47,5.47c.79.79,2.07.79,2.86,0l4.29-4.29c.79-.79.79-2.07,0-2.86L41.86.59c-.79-.79-2.07-.79-2.86,0L.59,39.01c-.79.79-.79,2.07,0,2.86l38.41,38.41c.79.79,2.07.79,2.86,0l12.62-12.62c.79-.79.79-2.07,0-2.86,0,0-4.29-4.29-4.29-4.29Z&quot;/&gt;
      &lt;path class=&quot;cls-1&quot; d=&quot;M50.54,40.44c0,5.58-4.53,10.11-10.11,10.11s-10.11-4.53-10.11-10.11,4.53-10.11,10.11-10.11,10.11,4.53,10.11,10.11Z&quot;/&gt;
    &lt;/g&gt;
  &lt;/g&gt;
&lt;/svg&gt;</file><file path="docs/organizations/get-organizations.mdx">---
openapi: get /v1/organizations
---</file><file path="docs/samples/sample.py">import random
from dataclasses import dataclass
from typing import List, Dict
from datetime import datetime

@dataclass
class Kevin:
    name: str
    favorite_chili: str
    desk_location: str
    famous_quote: str

class KevinSecretSanta:
    def __init__(self):
        self.kevins: List[Kevin] = [
            Kevin(&quot;Kevin Malone&quot;, &quot;Famous Chili&quot;, &quot;Accounting Corner&quot;, &quot;Why waste time say lot word when few word do trick&quot;),
            Kevin(&quot;Kevin McCallister&quot;, &quot;Microwave Mac &amp; Chili&quot;, &quot;Home Alone&quot;, &quot;This is my house, I have to defend it&quot;),
            Kevin(&quot;Kevin Hart&quot;, &quot;Comedy Chili&quot;, &quot;Stage Left&quot;, &quot;Everybody wants to be famous, but nobody wants to do the work&quot;),
            Kevin(&quot;Kevin Bacon&quot;, &quot;Six Degrees of Chili&quot;, &quot;Hollywood&quot;, &quot;Everything is connected by six degrees of separation&quot;),
            Kevin(&quot;Kevin Durant&quot;, &quot;Championship Chili&quot;, &quot;Basketball Court&quot;, &quot;Hard work beats talent when talent fails to work hard&quot;),
            Kevin(&quot;Kevin James&quot;, &quot;Mall Cop Chili&quot;, &quot;Segway Station&quot;, &quot;Safety never takes a holiday&quot;),
        ]
        self.assignments: Dict[Kevin, Kevin] = {}

    def assign_secret_santas(self) -&gt; None:
        recipients = self.kevins.copy()
        for giver in self.kevins:
            while True:
                recipient = random.choice(recipients)
                if recipient != giver:
                    self.assignments[giver] = recipient
                    recipients.remove(recipient)
                    break

    def print_assignments(self) -&gt; None:
        print(&quot;\nðŸŽ… KEVIN-THEMED SECRET SANTA ASSIGNMENTS ðŸŽ…&quot;)
        print(&quot;=&quot; * 50)
        for giver, recipient in self.assignments.items():
            print(f&quot;\n{giver.name} is getting a gift for {recipient.name}&quot;)
            print(f&quot;Recipient&apos;s favorite chili: {recipient.favorite_chili}&quot;)
            print(f&quot;Find them at: {recipient.desk_location}&quot;)
            print(f&quot;Famous quote: &apos;{recipient.famous_quote}&apos;&quot;)

    def spill_chili(self) -&gt; str:
        return &quot;&quot;&quot;
        â €â €â €â €â €â €â €ðŸŒ¶ï¸ Oh no! The chili! ðŸŒ¶ï¸
        â €â €â €â €â €â €â €   ___________
        â €â €â €â €â €â €â €  /           \\
        â €â €â €â €â €â €â € |  * splat *  |
        â €â €â €â €â €â €â €  \\___________ /
        &quot;&quot;&quot;

if __name__ == &quot;__main__&quot;:
    santa = KevinSecretSanta()
    santa.assign_secret_santas()
    santa.print_assignments()
    print(santa.spill_chili())
    print(&quot;\nThe trick is to undercook the onions...&quot;)</file><file path="docs/samples/sample.tsx">import React, { useState, useEffect } from &quot;react&quot;;
import styled from &quot;styled-components&quot;;

interface Kevin {
	id: number;
	name: string;
	wishlist: string[];
	assignedKevin?: Kevin;
}

const Container = styled.div`
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  font-family: &apos;Home Alone Sans&apos;, Arial, sans-serif;
`;

const Title = styled.h1`
  color: #c41e3a; // Christmas red
  text-align: center;
`;

const KevinCard = styled.div`
  border: 2px solid #228B22; // Forest green
  border-radius: 8px;
  padding: 15px;
  margin: 10px 0;
  background: #fff;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
`;

const kevins: Kevin[] = [
	{
		id: 1,
		name: &quot;Kevin McCallister&quot;,
		wishlist: [&quot;BB Gun&quot;, &quot;Pizza&quot;, &quot;Micro Machines&quot;],
	},
	{
		id: 2,
		name: &quot;Kevin From Home Alone 2&quot;,
		wishlist: [&quot;Hotel Room&quot;, &quot;Turtle Doves&quot;, &quot;Camera&quot;],
	},
	{
		id: 3,
		name: &quot;Kevin From Work&quot;,
		wishlist: [&quot;Coffee Mug&quot;, &quot;Stapler&quot;, &quot;Post-its&quot;],
	},
	{
		id: 4,
		name: &quot;Evil Kevin&quot;,
		wishlist: [&quot;Paint Cans&quot;, &quot;Hot Doorknobs&quot;, &quot;Tar&quot;],
	},
	{
		id: 5,
		name: &quot;Future Kevin&quot;,
		wishlist: [&quot;Hoverboard&quot;, &quot;Time Machine&quot;, &quot;Robot Butler&quot;],
	},
];

const KevinSecretSanta: React.FC = () =&gt; {
	const [assignedKevins, setAssignedKevins] = useState&lt;Kevin[]&gt;([]);
	const [isShuffled, setIsShuffled] = useState(false);

	const shuffleKevins = () =&gt; {
		const shuffled = [...kevins];
		for (let i = shuffled.length - 1; i &gt; 0; i--) {
			const j = Math.floor(Math.random() * (i + 1));
			[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
		}

		// Assign each Kevin to another Kevin
		const assigned = shuffled.map((kevin, index) =&gt; ({
			...kevin,
			assignedKevin: shuffled[(index + 1) % shuffled.length],
		}));

		setAssignedKevins(assigned);
		setIsShuffled(true);
	};

	return (
		&lt;Container&gt;
			&lt;Title&gt;ðŸŽ„ Kevin&apos;s Secret Santa Exchange ðŸŽ…&lt;/Title&gt;

			&lt;button
				onClick={shuffleKevins}
				style={{
					padding: &quot;10px 20px&quot;,
					fontSize: &quot;18px&quot;,
					backgroundColor: !isShuffled ? &quot;#c41e3a&quot; : &quot;#228B22&quot;,
					color: &quot;white&quot;,
					border: &quot;none&quot;,
					borderRadius: &quot;4px&quot;,
					cursor: &quot;pointer&quot;,
					display: &quot;block&quot;,
					margin: &quot;20px auto&quot;,
				}}
			&gt;
				{!isShuffled ? &quot;Assign Secret Kevins!&quot; : &quot;Reassign Kevins!&quot;}
			&lt;/button&gt;

			{assignedKevins.map((kevin) =&gt; (
				&lt;KevinCard key={kevin.id}&gt;
					&lt;h3&gt;ðŸŽ {kevin.name}&lt;/h3&gt;
					&lt;p&gt;
						Will give a gift to: &lt;strong&gt;{kevin.assignedKevin?.name}&lt;/strong&gt;
					&lt;/p&gt;
					&lt;p&gt;Their wishlist:&lt;/p&gt;
					&lt;ul&gt;
						{kevin.assignedKevin?.wishlist.map((item, index) =&gt; (
							&lt;li key={index}&gt;{item}&lt;/li&gt;
						))}
					&lt;/ul&gt;
				&lt;/KevinCard&gt;
			))}
		&lt;/Container&gt;
	);
};

export default KevinSecretSanta;

// Types for API endpoints
export interface SecretSantaApiResponse {
	success: boolean;
	assignments: {
		giver: Kevin;
		receiver: Kevin;
	}[];
}

// API utility functions
export const fetchKevinAssignments =
	async (): Promise&lt;SecretSantaApiResponse&gt; =&gt; {
		// Simulated API call
		return new Promise((resolve) =&gt; {
			setTimeout(() =&gt; {
				resolve({
					success: true,
					assignments: kevins.map((kevin, index) =&gt; ({
						giver: kevin,
						receiver: kevins[(index + 1) % kevins.length],
					})),
				});
			}, 1000);
		});
	};
// A simple React component to display loading state
export class LoadingSpinner extends React.Component {
	render() {
		return (
			&lt;div
				style={{
					display: &quot;flex&quot;,
					justifyContent: &quot;center&quot;,
					alignItems: &quot;center&quot;,
					padding: &quot;20px&quot;,
				}}
			&gt;
				&lt;div
					style={{
						width: &quot;50px&quot;,
						height: &quot;50px&quot;,
						border: &quot;5px solid #f3f3f3&quot;,
						borderTop: &quot;5px solid #3498db&quot;,
						borderRadius: &quot;50%&quot;,
						animation: &quot;spin 1s linear infinite&quot;,
					}}
				/&gt;
				&lt;style&gt;
					{`
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    `}
				&lt;/style&gt;
			&lt;/div&gt;
		);
	}
}
class MyClass {
	constructor() {}
	render() {
		return (
			&lt;div&gt;
				&lt;h1&gt;My Component&lt;/h1&gt;
			&lt;/div&gt;
		);
	}
}
const handleClick = () =&gt; {
    console.log(&quot;Button clicked&quot;);
};</file><file path="docs/sandboxes/base-image.mdx">---
title: &quot;Base Image&quot;
sidebarTitle: &quot;Base Image&quot;
icon: &quot;docker&quot;
---

Codegen sandboxes are built on a custom Docker image that provides a comprehensive development environment. The base image includes:

- **Python 3.13** (via `ghcr.io/astral-sh/uv:python3.13-bookworm`)
- **Node.js 22.14.0** (managed via NVM)
- **Essential development tools**: git, curl, ripgrep, fd-find, gh (GitHub CLI)
- **Package managers**: uv, npm, yarn, pnpm
- **Editors**: nano, vim
- **System utilities**: tmux, supervisor, nginx

## Dockerfile

```dockerfile
ARG TARGETPLATFORM=linux/amd64
FROM --platform=$TARGETPLATFORM ghcr.io/astral-sh/uv:python3.13-bookworm

# Set environment variables to prevent interactive prompts during installation
ENV NVM_DIR=/usr/local/nvm \
    NODE_VERSION=22.14.0 \
    DEBIAN_FRONTEND=noninteractive \
    NODE_OPTIONS=&quot;--max-old-space-size=8192&quot; \
    PYTHONUNBUFFERED=1 \
    COREPACK_ENABLE_DOWNLOAD_PROMPT=0 \
    PYTHONPATH=&quot;/usr/local/lib/python3.13/site-packages&quot; \
    IS_SANDBOX=True

ENV PATH=$NVM_DIR/versions/node/$NODE_VERSION/bin:/usr/local/nvm:/usr/local/bin:$PATH

ARG INVALIDATE_FILES_LAYER=1
# Copy configuration files and set permissions
COPY sshd_config /etc/ssh/sshd_config
COPY ssh_config /etc/ssh/ssh_config
COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf
COPY start.sh /usr/local/bin/start.sh
COPY setup_ssh_user.sh /usr/local/bin/setup_ssh_user.sh
COPY setup_ssh_keys.sh /usr/local/bin/setup_ssh_keys.sh
COPY nginx.conf /etc/nginx/nginx.conf
COPY error.html /usr/share/nginx/html/error.html
COPY tmux_output_script.sh /usr/local/bin/tmux_output_script.sh

# Install dependencies and set up environment in a single layer
RUN apt-get update &amp;&amp; apt-get install -y -o Dpkg::Options::=&quot;--force-confold&quot; \
    git \
    curl \
    fd-find \
    gh \
    lsof \
    ripgrep \
    openssh-server \
    nginx-full \
    fcgiwrap \
    tmux \
    nano \
    vim \
    supervisor \
    netcat-openbsd \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; mkdir -p -m 755 /etc/apt/keyrings \
    &amp;&amp; wget -nv -O- https://cli.github.com/packages/githubcli-archive-keyring.gpg | tee /etc/apt/keyrings/githubcli-archive-keyring.gpg &gt; /dev/null \
    &amp;&amp; chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \
    &amp;&amp; echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main&quot; | tee /etc/apt/sources.list.d/github-cli.list &gt; /dev/null \
    # Set up environment variables and save it to /etc/profile.d/nvm.sh
    &amp;&amp; echo &quot;export NVM_DIR=\&quot;$NVM_DIR\&quot;&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;[ -s \&quot;$NVM_DIR/nvm.sh\&quot; ] &amp;&amp; \. \&quot;$NVM_DIR/nvm.sh\&quot;&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export PATH=\&quot;$NVM_DIR/versions/node/$NODE_VERSION/bin:\$PATH\&quot;&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export NVM_BIN=\&quot;$NVM_DIR/versions/node/$NODE_VERSION/bin\&quot;&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export NODE_VERSION=\&quot;$NODE_VERSION\&quot;&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export NODE_OPTIONS=\&quot;--max-old-space-size=8192\&quot;&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export DEBIAN_FRONTEND=noninteractive&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export PYTHONUNBUFFERED=1&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export COREPACK_ENABLE_DOWNLOAD_PROMPT=0&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export PYTHONPATH=\&quot;/usr/local/lib/python3.13/site-packages\&quot;&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export IS_SANDBOX=true&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export NPM_CONFIG_YES=true&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export PIP_NO_INPUT=1&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; echo &quot;export YARN_ENABLE_IMMUTABLE_INSTALLS=false&quot; &gt;&gt; /etc/profile.d/nvm.sh \
    &amp;&amp; chmod +x /etc/profile.d/nvm.sh \
    # Run the SSH setup script
    &amp;&amp; /usr/local/bin/setup_ssh_user.sh \
    # Install nvm, Node.js, and code-server
    &amp;&amp; mkdir -p $NVM_DIR \
    &amp;&amp; curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash \
    &amp;&amp; . $NVM_DIR/nvm.sh \
    &amp;&amp; nvm install $NODE_VERSION \
    &amp;&amp; nvm use $NODE_VERSION \
    &amp;&amp; npm install -g yarn pnpm \
    &amp;&amp; corepack enable \
    &amp;&amp; corepack prepare yarn@stable --activate \
    &amp;&amp; corepack prepare pnpm@latest --activate \
    &amp;&amp; curl -fsSL https://raw.githubusercontent.com/coder/code-server/refs/tags/v4.99.1/install.sh | sh \
    &amp;&amp; uv tool install uvicorn[standard]

ENTRYPOINT [&quot;/usr/local/bin/start.sh&quot;]
```

## Key Features

### Multi-Language Support
The base image supports both Python and Node.js development out of the box, making it suitable for full-stack applications and polyglot projects.

### Development Tools
Essential development tools are pre-installed, including:
- **Git** for version control
- **GitHub CLI** for GitHub integration
- **ripgrep** and **fd-find** for fast file searching
- **tmux** for terminal multiplexing
- **nginx** for web server capabilities

### Package Managers
Multiple package managers are available:
- **uv** for Python package management
- **npm**, **yarn**, and **pnpm** for Node.js packages
- **corepack** for managing package manager versions

### SSH and Remote Access
The image includes SSH server configuration for remote access and development, with proper user setup and key management.</file><file path="docs/sandboxes/editor.mdx">---
title: &quot;Remote Editor (VSCode)&quot;
sidebarTitle: &quot;Editor&quot;
icon: &quot;laptop-code&quot;
---

Codegen provides access to a remote VSCode editor instance that is directly connected to your active sandbox environment. This powerful feature allows for real-time interaction with the agent&apos;s workspace, offering capabilities for live debugging, manual intervention, and detailed progress monitoring.

## Accessing the Editor

When an agent is active and utilizing a sandbox, a link or button to access the Remote Editor will typically be available on the agent&apos;s trace page or within the Codegen UI.

&lt;Frame caption=&quot;Access the Remote Editor from the Codegen UI (example)&quot;&gt;
  &lt;img src=&quot;/images/sandbox-buttons.png&quot; alt=&quot;Remote VSCode Editor&quot; /&gt;
&lt;/Frame&gt;

Access to the editor is password-protected. A unique password will be dynamically generated at runtime for each session and provided to you, ensuring secure access to the sandbox environment.

## Capabilities

The Remote Editor offers several key benefits:

- **Run Arbitrary Commands:** Open a terminal directly within VSCode to execute any shell commands in the sandbox. This is useful for:
  - Manually running tests.
  - Inspecting file contents.
  - Trying out different commands or scripts.
  - Installing additional temporary tools or dependencies.
- **View Agent&apos;s Progress:** See the files the agent is creating or modifying in real-time. This provides a transparent view into the agent&apos;s operations and can help in understanding its decision-making process.
- **Live Debugging:** If the agent is running a service or script, you can use VSCode&apos;s debugging tools (if applicable to the language/runtime) to step through code, inspect variables, and diagnose issues.
- **Manual Edits:** While generally agents manage the codebase, you can make manual edits to files directly if needed for quick fixes or experiments. Be mindful that agent actions might overwrite manual changes if not coordinated.

## How it Works

The remote editor essentially provides a fully functional VSCode interface tunneled into the agent&apos;s sandbox. This means you are working directly within the same environment as the agent, with access to the same file system, installed tools, and [Environment Variables](./environment-variables).

&lt;Tip&gt;
  The Remote Editor is an excellent tool for gaining deeper insights into an
  agent&apos;s operations and for situations where you need to interact more directly
  with the sandbox environment than through standard agent commands.
&lt;/Tip&gt;

&lt;Note&gt;
  Like other sandbox features, the editor session is tied to the lifecycle of
  the sandbox. Changes made might be ephemeral if the sandbox is reset or a new
  snapshot is used for subsequent runs, unless those changes are committed back
  through the agent or other means.
&lt;/Note&gt;{&quot; &quot;}</file><file path="docs/sandboxes/environment-variables.mdx">---
title: &quot;Environment Variables&quot;
sidebarTitle: &quot;Env Variables&quot;
icon: &quot;code&quot;
---

Codegen sandboxes come pre-configured with a set of environment variables to facilitate common development tasks and ensure smooth operation of tools and package managers. Understanding these variables can be helpful when debugging or customizing setup scripts.

## Standard Environment Variables

The following environment variables are typically available within Codegen sandboxes:

| Variable                          | Default Value                                 | Description                                                                                                                                 |
| --------------------------------- | --------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| `NVM_DIR`                         | _Dynamic_                                     | Specifies the directory where Node Version Manager (NVM) is installed. The exact path is set during sandbox initialization.                 |
| `PATH`                            | _Dynamic (includes NVM Node version)_         | The system&apos;s execution search path. It&apos;s augmented to include the `bin` directory of the currently active Node.js version (managed by NVM). |
| `NVM_BIN`                         | _Dynamic (points to active Node version bin)_ | Points to the `bin` directory of the currently active Node.js version. This is also set dynamically by NVM.                                 |
| `NODE_VERSION`                    | _Dynamic (current NVM Node version)_          | Indicates the version of Node.js that is currently active in the sandbox, as managed by NVM.                                                |
| `NODE_OPTIONS`                    | `&quot;--max-old-space-size=8192&quot;`                 | Configures V8 to allow a max old space size of 8192MB. Useful for memory-intensive Node.js apps.                                            |
| `DEBIAN_FRONTEND`                 | `&quot;noninteractive&quot;`                            | Instructs Debian-based package managers (like `apt`) to run without interactive prompts.                                                    |
| `PYTHONUNBUFFERED`                | `&quot;1&quot;`                                         | Forces `stdout` and `stderr` for Python to be unbuffered, meaning output is written immediately.                                            |
| `COREPACK_ENABLE_DOWNLOAD_PROMPT` | `&quot;0&quot;`                                         | Disables the Corepack prompt when it needs to download a package manager (like Yarn or pnpm).                                               |
| `PYTHONPATH`                      | `&quot;/usr/local/lib/python3.13/site-packages&quot;`   | Adds the specified directory to Python&apos;s module search path. (Python version may vary).                                                     |
| `IS_SANDBOX`                      | `&quot;true&quot;`                                      | A boolean flag indicating the environment is a Codegen sandbox.                                                                             |
| `NPM_CONFIG_YES`                  | `&quot;true&quot;`                                      | Configures npm to automatically answer &quot;yes&quot; to prompts.                                                                                    |
| `PIP_NO_INPUT`                    | `&quot;1&quot;`                                         | Instructs pip (Python&apos;s package installer) to operate in non-interactive mode.                                                              |
| `YARN_ENABLE_IMMUTABLE_INSTALLS`  | `&quot;false&quot;`                                     | Disables Yarn&apos;s &quot;immutable installs&quot; feature, allowing `yarn install` to modify the lockfile.                                               |
| `CG_PREVIEW_URL`                  | _Dynamic (preview URL)_                       | Contains the URL where the web preview will be served. This is automatically set when Web Preview is configured.                            |

&lt;Note&gt;
  The values for variables like `NVM_DIR`, `PATH`, `NVM_BIN`, and `NODE_VERSION`
  are typically set dynamically during the sandbox setup process, depending on
  the specific NVM and Node.js versions being used. The `PYTHONPATH` may also
  vary based on the Python installation within the sandbox.
&lt;/Note&gt;</file><file path="docs/sandboxes/image-snapshots.mdx">---
title: &quot;Image Snapshots&quot;
sidebarTitle: &quot;Image Snapshots&quot;
icon: &quot;camera&quot;
---

Codegen automatically creates filesystem snapshots of your sandbox environment to enable faster initialization of new agent runs. These snapshots capture the state of your environment after setup commands have been executed.

## How It Works

After your [setup commands](/sandboxes/setup-commands) run successfully, Codegen takes a snapshot of the entire filesystem. This snapshot serves as a cached starting point for future agent interactions, eliminating the need to re-run setup commands each time.

**Lazy Population**: Image caches are populated automatically and lazily. If no cache exists or the cache has expired, Codegen will create a new snapshot during the next agent run. This means the first agent run (or runs after cache expiration) may be slower as they need to execute setup commands and create the snapshot.

## Cache TTL

By default, image snapshots are cached for **24 hours**. After this period expires, Codegen will automatically create a fresh snapshot the next time an agent runs against your repository.

## Managing Image Cache

You can manage your repository&apos;s image cache settings by navigating to:

```
https://codegen.com/repos/{repoName}/image-cache
```

From this page, you can:

- **Invalidate the current cache** - Force creation of a new snapshot on the next agent run
- **Set a custom TTL** - Adjust how long snapshots are cached before expiring

&lt;Tip&gt;
  Invalidating the cache is useful when you&apos;ve updated your setup commands or
  need to ensure agents are working with the latest environment configuration.
&lt;/Tip&gt;

&lt;Note&gt;
  Image snapshots significantly reduce the time it takes to start new agent runs
  by avoiding the need to repeatedly execute setup commands.
&lt;/Note&gt;{&quot; &quot;}</file><file path="docs/sandboxes/overview.mdx">---
title: &quot;Code Execution Sandboxes&quot;
sidebarTitle: &quot;Overview&quot;
icon: &quot;box&quot;
---

Codegen agents operate within secure, isolated sandbox environments where they can safely execute code and run commands without affecting your local machine or production systems.

&lt;Frame&gt;
  &lt;video
    controls
    src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1757979569/Sandbox_Configuration_uf9xt6.mp4&quot;
    className=&quot;aspect-[3312/2160]&quot;
  /&gt;
&lt;/Frame&gt;

&lt;Tip&gt;
  Codegen&apos;s sandbox environments are highly configurable and built for
  enterprise workloads
&lt;/Tip&gt;

&lt;Card
  title=&quot;Configure Sandbox Environments&quot;
  icon=&quot;code&quot;
  href=&quot;https://codegen.com/repos&quot;
&gt;
  Select VM resources, install dependencies, securely upload secrets and more.
&lt;/Card&gt;

## Capabilities

Each sandbox provides a controlled environment with:

- **File System Access:** Read, write, and modify files within the sandbox&apos;s temporary file system.
- **Terminal Access:** Execute shell commands (`bash`, `sh`, etc.) to run scripts, linters, formatters, build tools, and other necessary commands.
- **Process Execution:** Run code in various languages (Python, Node.js, etc., depending on the sandbox image).
- **Networking:** Controlled network access for tasks like installing packages or fetching data (can be restricted).

## How Agents Use Sandboxes

Agents utilize sandboxes for a variety of tasks:

- **Testing Code:** Running unit tests, integration tests, or linters against the code they&apos;ve written or modified.
- **Verifying Changes:** Executing the code to ensure it runs correctly before committing.
- **Installing Dependencies:** Using package managers (`pip`, `npm`, `yarn`) to install necessary libraries.
- **Running Tools:** Executing build scripts, code formatters, or other development utilities.

## Configuration

Sandboxes are typically configured per-agent run or defined within your Codegen settings. You often don&apos;t need to manage them directly, but advanced configurations might allow specifying Docker images or environment variables.

&lt;Note&gt;
  Sandboxes maintain file system persistence between agent interactions within
  the same context. For example, when continuing a conversation across different
  Slack messages or Linear comments, the sandbox state is preserved, allowing
  agents to seamlessly continue their work without losing context or having to
  reinstall dependencies.
&lt;/Note&gt;

## Sandbox Configuration

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;Setup Commands&quot; icon=&quot;terminal&quot; href=&quot;/sandboxes/setup-commands&quot;&gt;
    Configure custom setup commands that run when initializing your sandbox
    environment.
  &lt;/Card&gt;
  &lt;Card title=&quot;Repository Secrets&quot; icon=&quot;key&quot; href=&quot;/sandboxes/secrets&quot;&gt;
    Manage environment variables and secrets securely injected into your
    sandbox.
  &lt;/Card&gt;
  &lt;Card title=&quot;Image Snapshots&quot; icon=&quot;camera&quot; href=&quot;/sandboxes/image-snapshots&quot;&gt;
    Learn how Codegen creates filesystem snapshots for faster initialization.
  &lt;/Card&gt;
  &lt;Card title=&quot;Web Preview&quot; icon=&quot;browser&quot; href=&quot;/sandboxes/web-preview&quot;&gt;
    Start development servers and view your running applications through
    Codegen.
  &lt;/Card&gt;
  &lt;Card title=&quot;Base Image&quot; icon=&quot;docker&quot; href=&quot;/sandboxes/base-image&quot;&gt;
    Explore the comprehensive Docker image that powers Codegen sandboxes.
  &lt;/Card&gt;
  &lt;Card title=&quot;Remote Editor&quot; icon=&quot;laptop-code&quot; href=&quot;/sandboxes/editor&quot;&gt;
    Access a VSCode editor connected directly to your sandbox environment.
  &lt;/Card&gt;
&lt;/CardGroup&gt;</file><file path="docs/sandboxes/secrets.mdx">---
title: &quot;Repository Secrets&quot;
sidebarTitle: &quot;Secrets&quot;
icon: &quot;key&quot;
---

Manage environment variables and secrets for your repository. These are securely injected into the agent&apos;s sandbox environment during code execution.

&lt;Warning&gt;
  Only use staging credentials and non-production secrets. Never store
  production API keys, database passwords, or sensitive credentials.
&lt;/Warning&gt;

## How Secrets Work

Repository secrets are environment variables that get automatically injected into the sandbox when agents execute code:

- **Secure Storage:** Secrets are encrypted and stored securely per repository
- **Sandbox Injection:** Automatically available as environment variables during agent execution
- **Development Support:** Enable agents to run dev servers, connect to staging databases, and test integrations

## Common Use Cases

- **Development Server Credentials:** API keys for staging services and development APIs
- **Database Connections:** Connection strings for staging/test databases
- **Third-Party Integrations:** Non-production tokens for services like Stripe test mode, staging analytics
- **Build Configuration:** Environment-specific build variables and feature flags

## Managing Secrets

Add secrets through your repository settings:

1. Navigate to your repository settings
2. Go to the Secrets tab
3. Add key-value pairs for your environment variables
4. Secrets are immediately available to agents in the sandbox

&lt;Note&gt;
  Agents can access these secrets when running code, starting development
  servers, or executing tests that require environment configuration.
&lt;/Note&gt;{&quot; &quot;}</file><file path="docs/sandboxes/setup-commands.mdx">---
title: &quot;Setup Commands&quot;
sidebarTitle: &quot;Setup Commands&quot;
icon: &quot;terminal&quot;
---

Codegen lets you configure custom setup commands that run once when initializing a repository&apos;s sandbox environment. The resulting file system snapshot serves as the starting point for all future agent runs, ensuring consistency.

&lt;Tip&gt;
  The most common use cases for setup commands is installing dependencies, e.g.
  `npm install`
&lt;/Tip&gt;

## Base Image

Codegen sandboxes are built on a custom Docker image that provides a comprehensive development environment. For detailed information about the base image, including the complete Dockerfile and available tools, see the [Base Image](/sandboxes/base-image) documentation.

## Accessing Setup Commands

To configure setup commands for a repository:

1.  Navigate to [codegen.com/repos](https://codegen.com/repos).
2.  Click on the desired repository from the list.
3.  You will be taken to the repository&apos;s settings page. The setup commands can be found at a URL similar to `https://www.codegen.com/repos/{arepo_name}/setup-commands` 

&lt;Frame caption=&quot;Set setup commands at codegen.com/repos&quot;&gt;
  &lt;img src=&quot;/images/setup-commands-ui.png&quot; alt=&quot;Setup Commands UI&quot; /&gt;
&lt;/Frame&gt;

## How it Works

Enter your desired setup commands in the provided text area, with one command per line. These commands will be executed in sequence within the sandbox environment.

For example, you might want to:

- Switch to a specific Node.js version.
- Install project dependencies.
- Run any necessary build steps or pre-compilation tasks.

After the commands are executed successfully, Codegen takes a snapshot of the sandbox&apos;s file system. This snapshot then serves as the base environment for future agent interactions with this repository, meaning your setup commands don&apos;t need to be re-run every time, saving time and ensuring consistency.

## Common Examples

Here are a few common use cases for setup commands:

```bash
# Switch to Node.js version 20
nvm use 20

# Install npm dependencies
npm install
```

```bash
# Setup with specific Python version for compatibility
pyenv install 3.12.0
pyenv local 3.12.0
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

```bash
# Or a combination of commands
nvm use 18
npm ci
npm run build
```

### Working with Different Python Versions

The sandbox comes with Python 3.13 by default, but some packages may not yet be compatible with this version. Here are strategies for handling different Python versions:

#### Using pyenv for Multiple Python Versions

If you need to work with a different Python version, you can install and use `pyenv`:

```bash
# Install pyenv
curl https://pyenv.run | bash

# Add pyenv to PATH (for current session)
export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;
eval &quot;$(pyenv init -)&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;

# Install Python 3.12 (or your desired version)
pyenv install 3.12.0

# Set Python 3.12 as the local version for your project
pyenv local 3.12.0

# Create a virtual environment with Python 3.12
python -m venv venv
source venv/bin/activate

# Install your dependencies
pip install -r requirements.txt
```

#### Using uv with Specific Python Versions

The `uv` package manager (already installed) can also manage Python versions:

```bash
# Install Python 3.12 and create a virtual environment
uv venv --python=3.12

# Activate the virtual environment
source .venv/bin/activate

# Install dependencies
uv pip install -r requirements.txt --refresh --upgrade
```

#### Virtual Environment Best Practices

When working with packages that require older Python versions:

```bash
# Create a virtual environment with a specific Python version
python3.12 -m venv venv_312
source venv_312/bin/activate

# Verify the Python version
python --version

# Install packages that require Python 3.12
pip install argis==2.4.0  # Example package that needs older Python

# Deactivate when done
deactivate
```

&lt;Warning&gt;
  Remember to activate your virtual environment in your setup commands if you need specific Python versions for your project dependencies.
&lt;/Warning&gt;

&lt;Note&gt;
  Ensure your setup commands are non-interactive and can run to completion
  without user input.
&lt;/Note&gt;
&lt;Tip&gt;
  The environment variables listed in the &quot;Env Variables&quot; section are available
  during the execution of these setup commands.
&lt;/Tip&gt;</file><file path="docs/sandboxes/web-preview.mdx">---
title: &quot;Web Preview&quot;
sidebarTitle: &quot;Web Preview&quot;
icon: &quot;browser&quot;
---

Codegen&apos;s Web Preview feature lets you start a development server in your sandbox and view your running application directly in the Codegen interface.

## How it Works

Define your web server startup commands just like [Setup Commands](./setup-commands). Instead of taking a snapshot, Codegen keeps the server running as a long-lived process.

A &quot;View Web Preview&quot; button appears on the agent trace page once the server starts. Click it to open your running application in a new tab through Codegen&apos;s secure proxy.

&lt;Frame caption=&quot;Access the Web Preview from the agent trace page&quot;&gt;
  &lt;img
    src=&quot;/images/sandbox-buttons.png&quot;
    alt=&quot;Web Preview button on Trace Page&quot;
  /&gt;
&lt;/Frame&gt;

## Configuration

You configure Web Preview commands in a manner similar to Setup Commands, likely within the same repository settings area (e.g., `https://codegen.com/{your_org}/{repo_name}/settings/web-preview`).

You&apos;ll provide the command(s) necessary to start your development server. Ensure that your server is configured to listen on an appropriate host (often `127.0.0.1`) and a predictable port that Codegen can then expose.

&lt;Warning&gt;
  The web server started for Web Preview **MUST** listen on port 3000. Codegen
  is specifically configured to look for and expose applications running on this
  port within the sandbox.
&lt;/Warning&gt;

## Common Examples

The primary use case is starting a development web server:

```bash
# For a Node.js/npm project
npm run dev
```

```bash
# For a Python/Django project
python manage.py runserver 127.0.0.1:3000
```

```bash
# For a Ruby on Rails project
bundle exec rails server -b 127.0.0.1 -p 3000
```

&lt;Tip&gt;
  The Web Preview server runs within the same sandbox environment as your other
  agent tasks, meaning it has access to the same file system (including any
  changes made by the agent) and the [Environment
  Variables](./environment-variables).
&lt;/Tip&gt;

&lt;Tip&gt;
  The `CG_PREVIEW_URL` environment variable is automatically set and contains
  the URL where your web preview will be accessible. Use this in your
  application code when you need to reference the preview URL programmatically
  (e.g., for CORS configuration, webhooks, or generating absolute URLs).
&lt;/Tip&gt;

&lt;Note&gt;
  The web preview is intended for development and debugging purposes. The server
  is typically only accessible while the agent run is active or for a short
  period afterward, and it&apos;s not designed for public hosting.
&lt;/Note&gt;</file><file path="docs/settings/agent-behavior.mdx">---
title: &quot;Agent Behavior&quot;
sidebarTitle: &quot;Agent Behavior&quot;
icon: &quot;robot&quot;
---

Configure the types of behaviors you&apos;d like the AI agent to exhibit. These settings control how agents interact with users and approach code modifications to ensure they align with your team&apos;s workflow preferences.

&lt;Card
  title=&quot;Configure Agent Behavior&quot;
  icon=&quot;robot&quot;
  href=&quot;https://codegen.com/settings/behavioral&quot;
&gt;
  Customize how agents interact with your team and approach code modifications.
&lt;/Card&gt;

## Available Behaviors

### Propose Plan

Control whether the codegen agent should propose a detailed implementation plan to the user before executing **all** code modifications, regardless of size or complexity.

**When enabled:**

- Agents will present a structured plan showing each implementation step
- Users can review the proposed approach before any code changes are made
- Plans include confidence levels, relevant files, and detailed descriptions
- Provides transparency into the agent&apos;s decision-making process

**When disabled:**

- Agents proceed directly with code modifications
- Faster execution for straightforward tasks
- Users can still request plans explicitly when needed

&lt;Tip&gt;
  Enable this setting if you prefer to review and approve implementation
  approaches before code changes are made, especially for critical or complex
  repositories.
&lt;/Tip&gt;

### Require Explicit GitHub Mentions

Control whether the codegen agent should only respond to GitHub comments that explicitly mention `@codegen` or `@codegen-sh`.

**When enabled:**

- Agent only responds to comments containing explicit mentions
- Provides precise control over when agents activate
- Reduces unwanted agent responses on general discussions
- Recommended for busy repositories with frequent comments

**When disabled:**

- Agent may respond to relevant comments without explicit mentions
- More proactive agent engagement
- Convenient for smaller teams with focused discussions

&lt;Warning&gt;
  In busy repositories, disabling explicit mentions may result in agents
  responding to unintended comments. Consider your team&apos;s communication patterns
  when configuring this setting.
&lt;/Warning&gt;

## Configuration

These behavior settings are configured at the organization level and apply to all repositories within your organization. Individual repository settings may override some behaviors where supported.

## Best Practices

**For New Teams:**

- Start with &quot;Propose Plan&quot; enabled to understand how agents approach problems
- Use explicit GitHub mentions initially to control agent activation
- Gradually adjust settings as your team becomes comfortable with agent behavior

**For Experienced Teams:**

- Disable &quot;Propose Plan&quot; for routine tasks to increase velocity
- Consider allowing non-explicit mentions in trusted repositories
- Customize settings based on repository criticality and team preferences

**For Large Organizations:**

- Enable explicit mentions to prevent noise in high-traffic repositories
- Use &quot;Propose Plan&quot; for production or critical infrastructure repositories
- Consider different settings for different types of repositories

&lt;Note&gt;
  Agent behavior settings help ensure that AI assistance integrates smoothly
  with your existing development workflows and team communication patterns.
&lt;/Note&gt;</file><file path="docs/settings/agent-permissions.mdx">---
title: &quot;Agent Permissions&quot;
sidebarTitle: &quot;Agent Permissions&quot;
icon: &quot;shield-check&quot;
---

Configure what actions the AI agent is allowed to perform across your organization. These permission settings provide fine-grained control over agent capabilities to ensure they operate within your security and workflow requirements.

&lt;Card
  title=&quot;Configure Agent Permissions&quot;
  icon=&quot;shield-check&quot;
  href=&quot;https://codegen.com/settings/permissions&quot;
&gt;
  Control what actions agents are allowed to perform in your organization.
&lt;/Card&gt;

## Available Permissions

### Enable PR Creation

Control whether the codegen agent is able to create pull requests in your repositories in response to user requests.

**When enabled:**

- Agents can create new pull requests with code changes
- PRs include detailed descriptions and context
- Automatic linking to related issues and discussions
- Supports your standard code review workflow

**When disabled:**

- Agents can still analyze code and provide suggestions
- Code changes are proposed but not committed
- Manual PR creation required for implementing changes
- Useful for read-only or advisory agent roles

### Enable Rules Detection

Allow the agent to automatically detect and apply rules from various rule files in your repositories. You can also configure manual repository rules at [codegen.com/settings/repo-rules](http://localhost:3001/settings/repo-rules).

**Supported rule file formats:**

- `.cursorrules` - Cursor AI editor rules
- `.cursor/rules/*.mdc` - Structured rule files in Cursor directory
- `.windsurfrules` - Windsurf AI editor rules
- `CLAUDE.md` - Claude-specific instructions
- `AGENTS.md` - General agent instructions
- `AGENT.md` - Agent-specific rules

**When enabled:**

- Agents automatically discover and apply repository-specific rules
- Rules are version-controlled alongside your code
- Consistent behavior across team members and environments
- Supports existing AI editor workflows

**When disabled:**

- Only manually configured repository rules are applied
- No automatic file-based rule detection
- Simpler rule management through web interface only

### Enforce Organization-wide Signed Commits

When enabled, **ALL** repositories in this organization will be required to use signed commits via GitHub&apos;s API. Individual repositories cannot override this security policy.

**Security benefits:**

- Cryptographic verification of commit authenticity
- Enhanced audit trail for code changes
- Compliance with security policies requiring commit signing
- Protection against commit impersonation

**Important considerations:**

- This is an organization-wide enforcement policy
- Individual repositories cannot disable this requirement
- Ensures consistent security posture across all projects
- May require additional setup for team members&apos; GPG keys

&lt;Warning&gt;
  Enabling organization-wide signed commits affects all repositories and cannot
  be overridden at the repository level. Ensure your team is prepared for this
  requirement before enabling.
&lt;/Warning&gt;

## Configuration

Agent permissions are configured at the organization level and provide security boundaries for all agent operations within your organization.

Access your agent permissions at:

&lt;Card
  title=&quot;Configure Agent Permissions&quot;
  icon=&quot;shield-check&quot;
  href=&quot;https://codegen.com/settings/permissions&quot;
&gt;
  Control what actions agents are allowed to perform in your organization.
&lt;/Card&gt;

## Best Practices

**Start Conservative:**

- Begin with limited permissions and expand as trust builds
- Enable rules detection to leverage existing team practices
- Consider PR creation permissions based on repository criticality

**Security Considerations:**

- Enable signed commits for organizations with compliance requirements
- Review agent-created PRs before merging, especially initially
- Monitor agent activity through analytics and audit logs

**Team Alignment:**

- Ensure team understands which permissions are enabled
- Provide training on rule file formats if using rules detection
- Establish clear processes for agent-created PRs

&lt;Note&gt;
  Permission settings provide essential guardrails for agent operations while
  maintaining the flexibility to customize based on your organization&apos;s security
  and workflow requirements.
&lt;/Note&gt;</file><file path="docs/settings/model-configuration.mdx">---
title: &quot;LLM Configuration&quot;
sidebarTitle: &quot;Model Choice&quot;
icon: &quot;microchip&quot;
---

Codegen offers flexibility in choosing the Large Language Model (LLM) that powers your agent, allowing you to select from various providers and specific models. You can also configure custom API keys and base URLs if you have specific arrangements or need to use self-hosted models.

&lt;Frame&gt;
  &lt;video
    controls
    src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1757976620/Model_Choice_ogcic1.mp4&quot;
    className=&quot;aspect-[3324/2160]&quot;
  /&gt;
&lt;/Frame&gt;

&lt;Card
  title=&quot;Configure Model Settings&quot;
  icon=&quot;microchip&quot;
  href=&quot;https://codegen.com/settings/model&quot;
&gt;
  Choose your LLM provider, select models, and configure custom API keys for
  your organization.
&lt;/Card&gt;

## Accessing LLM Configuration

LLM Configuration settings are applied globally for your entire organization. You can access and modify these settings by navigating to:

&lt;Card
  title=&quot;Configure Model Settings&quot;
  icon=&quot;microchip&quot;
  href=&quot;https://codegen.com/settings/model&quot;
&gt;
  Choose your LLM provider, select models, and configure custom API keys for
  your organization.
&lt;/Card&gt;

This central location ensures that all agents operating under your organization adhere to the selected LLM provider and model, unless specific per-repository or per-agent overrides are explicitly configured (if supported by your plan).

&lt;Frame caption=&quot;LLM Configuration UI at codegen.com/settings/model&quot;&gt;
  &lt;img src=&quot;/images/llm-configuration.png&quot; alt=&quot;LLM Configuration UI&quot; /&gt;
&lt;/Frame&gt;

As shown in the UI, you can generally configure the following:

- **LLM Provider:** Select the primary LLM provider you wish to use. Codegen supports major providers such as:
  - Anthropic
  - OpenAI
  - Google (Gemini)
- **LLM Model:** Once a provider is selected, you can choose a specific model from that provider&apos;s offerings (e.g., Claude 4 Sonnet, GPT-4, Gemini Pro).

## Enhanced Agent Modes

For improved agent performance, you can enable Claude Code mode which runs agents in Anthropic&apos;s specialized coding environment:

&lt;Card title=&quot;Claude Code Mode&quot; icon=&quot;code&quot; href=&quot;/settings/claude-code&quot;&gt;
  Configure agents to run in Claude Code harness for enhanced coding
  capabilities and superior development assistance.
&lt;/Card&gt;

## Model Recommendation

&lt;Warning&gt;
  While Codegen provides access to a variety of models for experimentation and
  specific use cases, **we highly encourage the use of Anthropic&apos;s Claude 4
  Sonnet**. Our internal testing and prompt engineering are heavily optimized
  for Claude 4 Sonnet, and it consistently delivers the best performance,
  reliability, and cost-effectiveness for most software engineering tasks
  undertaken by Codegen agents. Other models are made available primarily for
  users who are curious or have unique, pre-existing workflows.
&lt;/Warning&gt;

## Custom API Keys and Base URLs

For advanced users or those with specific enterprise agreements with LLM providers, Codegen allows you to use your own API keys and, in some cases, custom base URLs (e.g., for Azure OpenAI deployments or other proxy/gateway services).

&lt;Card
  title=&quot;Configure API Keys&quot;
  icon=&quot;key&quot;
  href=&quot;https://codegen.com/settings/api-keys&quot;
&gt;
  Set up custom API keys for OpenAI, Anthropic, Google, and Grok models.
&lt;/Card&gt;

We currently support custom API keys for:

- **OpenAI** - GPT-4, GPT-4 Turbo, and other OpenAI models
- **Anthropic** - Claude 4 Sonnet, Claude 4 Opus, and Claude 4 Haiku
- **Google** - Gemini Pro and other Google AI models
- **Grok** - Grok models from xAI

**Benefits of custom API keys:**

- **Custom API Key:** If you provide your own API key, usage will be billed to your account with the respective LLM provider.
- **Custom Base URL:** This allows Codegen to route LLM requests through a different endpoint than the provider&apos;s default API.

&lt;Tip&gt;
  Using the default Codegen-managed LLM configuration (especially with Claude 4
  Sonnet) is recommended for most users to ensure optimal performance and to
  benefit from our continuous prompt improvements.
&lt;/Tip&gt;

&lt;Note&gt;
  The availability of specific models, providers, and custom configuration
  options may vary based on your Codegen plan and the current platform
  capabilities.
&lt;/Note&gt;</file><file path="docs/settings/on-prem-deployment.mdx">---
title: &quot;On-Premises Deployments&quot;
sidebarTitle: &quot;On-Prem&quot;
icon: &quot;box&quot;
---

Deploy Codegen on your own infrastructure with complete control over your data and development environment.

&lt;Warning&gt;
  On-premises deployment is available for [Enterprise
  tier](https://codegen.com/pricing) customers.
&lt;/Warning&gt;

## How It Works

Codegen is built as a cloud-native Kubernetes application designed for secure, self-hosted deployment. Our architecture allows you to run the entire platform within your own infrastructure while leveraging [your own AI models and API keys](/settings/model-configuration) for complete control over data processing. This deployment model is ideal for teams with stringent data sovereignty requirements, air-gapped environments, or compliance mandates that require all code and development activities to remain within corporate boundaries.

## Deployment Options

Choose the deployment method that best fits your infrastructure:

&lt;CardGroup cols={3}&gt;
  &lt;Card title=&quot;Docker Image&quot; icon=&quot;docker&quot;&gt;
    Deploy using our containerized solution on any Docker-compatible platform
  &lt;/Card&gt;
  &lt;Card title=&quot;AWS AMI&quot; icon=&quot;aws&quot;&gt;
    Launch pre-configured instances directly from Amazon Machine Images
  &lt;/Card&gt;
  &lt;Card title=&quot;Amazon EKS&quot; icon=&quot;kubernetes&quot;&gt;
    Deploy on managed Kubernetes with full AWS integration
  &lt;/Card&gt;
&lt;/CardGroup&gt;

&lt;Tip&gt;
  All deployment options are built on our Kubernetes-native architecture,
  ensuring seamless integration with your existing infrastructure.
&lt;/Tip&gt;

## Key Benefits

&lt;CardGroup cols={2}&gt;
  &lt;Card title=&quot;Complete Data Sovereignty&quot; icon=&quot;shield-check&quot;&gt;
    Your code and data never leave your infrastructure - maintain full control
    over your intellectual property
  &lt;/Card&gt;
  &lt;Card
    title=&quot;Your Own AI Models&quot;
    icon=&quot;cpu&quot;
    href=&quot;/settings/model-configuration&quot;
  &gt;
    Use your own API keys with AWS Bedrock, Google Vertex AI, and other
    providers
  &lt;/Card&gt;
&lt;/CardGroup&gt;

&lt;Note&gt;
  Coming soon: Deploy directly from AWS Marketplace with simplified billing and
  procurement.
&lt;/Note&gt;

## Enterprise Features

Enterprise customers receive comprehensive deployment support:

- **Priority Support** - Dedicated channels and faster response times
- **Custom Configuration** - Tailored deployment plans for your specific requirements
- **Security Integration** - Works with your existing security tools and compliance policies
- **Multi-Region Support** - High-availability configurations across multiple clusters

&lt;Warning&gt;
  Air-gapped environments and offline deployments are supported with special
  configuration.
&lt;/Warning&gt;

## Getting Started

&lt;Card
  title=&quot;Contact Enterprise Sales&quot;
  icon=&quot;phone&quot;
  href=&quot;https://codegen.com/contact&quot;
&gt;
  Ready to deploy on your infrastructure? Our enterprise team will create a
  custom deployment plan for your organization.
&lt;/Card&gt;

&lt;Tip&gt;
  Enterprise customers get direct access to our engineering team for deployment
  assistance and ongoing optimization reviews.
&lt;/Tip&gt;</file><file path="docs/settings/organization-rules.mdx">---
title: &quot;Organization Rules&quot;
description: &quot;Configure global rules that apply across all repositories in your organization&quot;
---

# Organization Rules

Organization Rules allow you to specify global instructions that the Codegen agent will follow across all repositories in your organization. These rules act as organization-wide guidelines that ensure consistent behavior and standards across your entire codebase.

## How Organization Rules Work

When you define Organization Rules, they are automatically applied to every agent run within your organization, regardless of which repository the agent is working on. This provides a centralized way to enforce:

- Coding standards and conventions
- Security practices
- Documentation requirements
- Git workflow preferences
- Communication styles

## Rule Hierarchy

Organization Rules work in conjunction with Repository Rules to provide flexible rule management:

1. **Organization Rules** are applied first as the baseline for all repositories
2. **Repository Rules** can override or extend Organization Rules for specific repositories
3. If both are defined, Repository Rules take precedence for conflicting instructions

This hierarchy allows you to set organization-wide defaults while still maintaining repository-specific customizations when needed.

## Setting Up Organization Rules

To configure Organization Rules:

1. Navigate to your organization settings
2. Select **Organization Rules** from the sidebar
3. Enter your rules in the text area provided
4. Click **Save** to apply the rules

## Example Organization Rules

Here are some common examples of Organization Rules:

### Git Workflow Standards

```
Always use git add . when staging changes for commit
Never use git push --force under any circumstances
Always create descriptive commit messages following conventional commit format
```

### Code Quality Standards

```
Always include comprehensive error handling in new functions
Follow the existing code style and formatting conventions
Add unit tests for any new functionality
Include JSDoc comments for all public functions
```

### Security Guidelines

```
Never commit sensitive information like API keys or passwords
Always validate user input before processing
Use environment variables for configuration values
```

### Documentation Requirements

```
Update README files when adding new features
Include inline comments for complex logic
Document any breaking changes in commit messages
```

## Best Practices

### Keep Rules Clear and Specific

- Write rules that are easy to understand and follow
- Be specific about what you want the agent to do or avoid
- Use clear, actionable language

### Avoid Conflicting Rules

- Ensure Organization Rules don&apos;t contradict each other
- Consider how they might interact with Repository Rules
- Test rules with different types of tasks

### Regular Review and Updates

- Periodically review your Organization Rules for relevance
- Update rules as your organization&apos;s practices evolve
- Remove outdated or unnecessary rules

### Balance Global vs Repository-Specific Rules

- Use Organization Rules for truly universal standards
- Reserve Repository Rules for project-specific requirements
- Avoid duplicating rules between levels

## Troubleshooting

### Rules Not Being Applied

If your Organization Rules don&apos;t seem to be working:

1. **Check Rule Syntax**: Ensure your rules are clearly written and unambiguous
2. **Verify Save**: Make sure you clicked &quot;Save&quot; after entering your rules
3. **Repository Override**: Check if Repository Rules are overriding your Organization Rules
4. **Rule Conflicts**: Look for contradictory instructions that might confuse the agent

### Agent Behavior Issues

If the agent isn&apos;t following your rules as expected:

1. **Simplify Rules**: Break complex rules into smaller, more specific instructions
2. **Add Context**: Provide more context about when and how rules should be applied
3. **Test Incrementally**: Add rules gradually to identify which ones work best

## Related Settings

- **[Repository Rules](/settings/repo-rules)**: Set repository-specific rules that can override Organization Rules
- **[Agent Permissions](/settings/agent-permissions)**: Control what actions the agent can perform
- **[Model Choice](/settings/model-configuration)**: Configure which AI model the agent uses

Organization Rules provide a powerful way to maintain consistency across your entire organization while still allowing flexibility for individual repositories. Use them to establish your organization&apos;s coding culture and ensure all agent interactions align with your standards.</file><file path="docs/settings/repo-rules.mdx">---
title: &quot;Agent Rules&quot;
sidebarTitle: &quot;Agent Rules&quot;
icon: &quot;shield-check&quot;
---

Agent rules are text prompts that provide instructions to AI agents about coding standards, conventions, and preferences. These text-based rules are automatically injected into the agent&apos;s context during each task.

&lt;Frame&gt;
  &lt;video
    controls
    src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1757977539/Rules_evkkhx.mp4&quot;
    className=&quot;aspect-[3356/2160]&quot;
  /&gt;
&lt;/Frame&gt;

## How Agent Rules Work

When an agent starts working, it receives all applicable rules as text prompts in its context:

1. **[User Rules](https://codegen.com/settings/personal-prompts)** - Your personal coding preferences and style
2. **[Organization Rules](https://codegen.com/settings/organization-rules)** - Organization-wide standards and conventions
3. **[Repository Rules](https://codegen.com/repos)** - Project-specific requirements and guidelines

The agent is instructed to prefer **User &gt; Repository &gt; Organization** rules when there are conflicts, but these are guidance rather than hard constraints. The agent considers all rules as context when making decisions.

&lt;Note&gt;
  Rules are text prompts, not strict settings. Agents use them as guidance
  alongside the specific task you&apos;ve given them.
&lt;/Note&gt;

&lt;Tip&gt;
  Codegen automatically detects `AGENTS.md` and other rules files. [Learn
  more](#automatic-rule-file-detection)
&lt;/Tip&gt;

## Automatic Rule File Detection

In addition to manual repository rules, Codegen automatically discovers and includes agent rule files from your repository when the agent starts working on it. This happens automatically whenever the `set_active_codebase` tool is used.

### Supported Rule File Patterns

Codegen automatically searches for the following types of rule files in your repository:

&lt;Note&gt;
  You can customize which rule file patterns to match by configuring glob
  patterns in your repository settings at
  [codegen.com/repos](https://codegen.com/repos) (select your repository, then
  configure rule file patterns).
&lt;/Note&gt;

- **`AGENTS.md`** - preferred default. [Learn more](https://agents.md)
- **`CLAUDE.md`** - Claude assistant rules
- **`.cursorrules`** - Cursor AI editor rules
- **`.clinerules`** - Cline AI assistant rules
- **`.windsurfrules`** - Windsurf AI editor rules
- **`**/\*.mdc`** - Markdown files with `.mdc` extension anywhere in the repository
- **`.cursor/rules/**/\*.mdc`** - Markdown files in the `.cursor/rules/` directory structure

### How Automatic Detection Works

1. **File Discovery**: When you switch to a repository, Codegen uses `ripgrep` to search for files matching the supported patterns
2. **Content Extraction**: The content of discovered files is read and processed

- **New**: The content is encoded to preserve formatting during transport, then decoded before being presented to the agent

3. **Size Limitation (25k global budget)**: All rule files combined are truncated to fit within a 25,000 character global budget to ensure optimal performance
4. **Context Integration**: The rule content is automatically included in the agent&apos;s context alongside any manual repository rules

### Example Rule Files

Here are examples of how you might structure agent rules in your repository:

**`AGENTS.md` example:**

```markdown
# Backend Development Rules

## Database

- Use Prisma for database operations
- Always use transactions for multi-step operations
- Include proper error handling for all database calls

## API Design

- Follow REST conventions
- Use proper HTTP status codes
- Include request/response validation
```

### Visibility in UI

When rules are discovered, they are displayed in the AgentTrace under the `SetActiveCodebase` tool card as &quot;Repository Rules (Filesystem)&quot;. You can expand each entry to preview the content and open the source file on GitHub.

### Benefits of Automatic Rule Files

- **Version Control**: Rule files are committed with your code, ensuring consistency across team members
- **Repository-Specific**: Different repositories can have different rule files without manual configuration
- **Developer-Friendly**: Developers can manage rules using familiar file-based workflows
- **Editor Integration**: Many AI-powered editors already support these file formats

&lt;Tip&gt;
  Automatic rule files work alongside manual repository rules. Both types of
  rules are combined and provided to the agent for maximum context.
&lt;/Tip&gt;

&lt;Warning&gt;
  If your rule files exceed the global 25,000 character budget, they will be
  truncated per-file and/or at the aggregate level. Keep rule files concise or
  split them into focused files.
&lt;/Warning&gt;

## Common Use Cases and Examples

Agent rules are flexible and can be used for various purposes across different levels:

### User-Level Rules Examples

Perfect for personal preferences that should apply across all your work:

- **Personal Coding Style:**
  - &quot;I prefer functional programming patterns over object-oriented when possible.&quot;
  - &quot;Always include detailed JSDoc comments for functions with more than 2 parameters.&quot;
- **Workflow Preferences:**
  - &quot;Include performance considerations in code reviews for any loops or database queries.&quot;
  - &quot;Prefer explicit error handling over try-catch blocks when the error is expected.&quot;
- **Tool Preferences:**
  - &quot;Use my preferred linting configuration and code formatting style.&quot;
  - &quot;Always suggest using TypeScript strict mode for new projects.&quot;

### Organization-Level Rules Examples

Perfect for organization-wide standards that should apply to all repositories:

- **Coding Standards:**
  - &quot;All code must follow our organization&apos;s style guide. Use Prettier for JavaScript/TypeScript formatting.&quot;
  - &quot;All API endpoints must include proper error handling and logging.&quot;
- **Security Requirements:**
  - &quot;Never commit API keys, passwords, or other secrets to the repository.&quot;
  - &quot;All database queries must use parameterized statements to prevent SQL injection.&quot;
- **Process Requirements:**
  - &quot;All commit messages must follow the Conventional Commits specification.&quot;
  - &quot;Every PR must include tests for new functionality.&quot;

### Repository-Level Rules Examples

Perfect for repository-specific requirements that may override organization defaults:

- **Technology-Specific Rules:**
  - &quot;This is a Python project. Use `black` for formatting and `pytest` for testing.&quot;
  - &quot;This legacy repository uses JavaScript instead of our organization&apos;s TypeScript standard.&quot;
- **Project-Specific Information:**
  - &quot;All new backend code should be in the `/server/src` directory.&quot;
  - &quot;Avoid using deprecated function `old_function()`. Use `new_function()` instead.&quot;
- **Build and Deployment:**
  - &quot;Run `npm run build` before committing to ensure the build passes.&quot;
  - &quot;This repository deploys automatically on merge to main - ensure all tests pass.&quot;</file><file path="docs/settings/repo-rules.tsx">---
title: &quot;Repository Rules&quot;
sidebarTitle: &quot;Repo Rules&quot;
icon: &quot;shield-check&quot;
---

Repository Rules in Codegen act as a persistent set of instructions or a &quot;system prompt&quot; for the AI agent whenever it operates on a specific repository. These rules are shown to the language model (LLM) every time it performs a task related to that repository, ensuring that certain guidelines, preferences, or constraints are consistently followed.

This feature is powerful for guiding the agent&apos;s behavior, enforcing coding standards, or reminding it of repository-specific conventions.

## How Repository Rules Work

When an agent is assigned a task on a repository with defined rules, those rules are automatically prepended or made available to the LLM as part of its context. This means the agent &quot;sees&quot; these rules alongside the actual task or prompt it receives.

For example, if you have a rule like &quot;Always use tabs for indentation,&quot; the agent will be reminded of this preference before it starts writing or modifying code in that repository.

## Automatic Rule File Detection

In addition to manual repository rules, Codegen automatically discovers and includes agent rule files from your repository when the agent starts working on it. This discovery happens whenever the `set_active_codebase` tool initializes work on a repo.

### Supported Rule File Patterns

Codegen searches for the following patterns:

- **`.cursorrules`** (Cursor)
- **`.clinerules`** (Cline)
- **`.windsurfrules`** (Windsurf)
- **`**/*.mdc`** (any `.mdc` file in the repo)
- **`.cursor/rules/**/*.mdc`** (files under `.cursor/rules/`)
- **`CLAUDE.md`**, **`AGENTS.md`**, **`AGENT.md`** (top-level agent instruction docs)

### How it works

1. Discovery via `ripgrep`
2. Content is read and encoded to preserve formatting during transport, then decoded
3. A global size budget of **25,000 characters** is enforced across all discovered files
4. The resulting content is combined with your manual Repository Rules and provided to the agent

### Visibility in the UI

Discovered rule files are rendered in AgentTrace under the `SetActiveCodebase` tool card as &quot;Repository Rules (Filesystem)&quot;. Expand entries to preview content and open the source on GitHub.

&lt;Tip&gt;
  Automatic rule files are merged with manual Repository Rules to give the agent repository-specific context.
&lt;/Tip&gt;

&lt;Warning&gt;
  If discovered rule files exceed the global 25,000 character budget, content will be truncated. Keep files concise or split by area of concern.
&lt;/Warning&gt;

## Accessing and Configuring Repository Rules

You can typically find and configure Repository Rules within the settings page for each specific repository in the Codegen web UI.

1.  Navigate to [codegen.com/repos](https://codegen.com/repos).
2.  Select the repository for which you want to set rules.
3.  Look for a section titled &quot;Repository rules&quot; or similar in the repository&apos;s settings.

&lt;Frame caption=&quot;Configuring Repository Rules in the UI&quot;&gt;
  &lt;img src=&quot;/images/repo-rules-ui.png&quot; alt=&quot;Repository Rules UI&quot; /&gt;
&lt;/Frame&gt;

In the text area provided (as shown in the image), you can specify any rules you want the agent to follow for this repository. Click &quot;Save&quot; to apply them.

## Common Use Cases and Examples

Repository rules are flexible and can be used for various purposes:

-   **Enforcing Linting/Formatting:**
    -   &quot;Remember to run the linter with `npm run lint` before committing.&quot;
    -   &quot;Ensure all Python code follows PEP 8 guidelines. Use `black` for formatting.&quot;
-   **Specifying Commit Message Conventions:**
    -   &quot;All commit messages must follow the Conventional Commits specification.&quot;
    -   &quot;Prefix commit messages with the related Linear issue ID (e.g., `ENG-123: ...`).&quot;
-   **Highlighting Project-Specific Information:**
    -   &quot;This repository uses TypeScript. All new backend code should be in the `/server/src` directory.&quot;
    -   &quot;Avoid using deprecated function `old_function()`. Use `new_function()` instead.&quot;
-   **Code Style Preferences:**
    -   &quot;Don&apos;t write super long strings, as this will break pre-commit. Do triple-quoted strings with newlines, non-indented, instead!&quot; (As seen in your example image)
    -   &quot;Prefer functional components over class components in React.&quot;
-   **Reminders for Testing:**
    -   &quot;Ensure all new features have corresponding unit tests.&quot;
    -   &quot;Run integration tests with `npm run test:integration` after significant changes.&quot;

&lt;Tip&gt;
  Keep your repository rules concise and clear. Overly complex or numerous rules might confuse the agent or lead to suboptimal performance. Focus on the most critical guidelines for each repository.
&lt;/Tip&gt;

&lt;Note&gt;
  Repository Rules are applied *in addition* to any global prompting strategies or agent capabilities. They provide a repository-specific layer of instruction.
&lt;/Note&gt;</file><file path="docs/settings/settings.mdx">---
title: &quot;Settings&quot;
sidebarTitle: &quot;Overview&quot;
icon: &quot;gear&quot;
---

Configure Codegen to work perfectly with your development workflow. Customize agent behavior, model selection, and repository-specific rules to optimize performance across your entire organization.

&lt;video
  controls
  src=&quot;https://res.cloudinary.com/dbikr6pew/video/upload/v1757886203/enterprise-configurability_agrhcn.mp4&quot;
  className=&quot;w-full aspect-[3456/2160] rounded-sm&quot;
/&gt;

## Agent &amp; Repository Settings

&lt;CardGroup cols={2}&gt;
  &lt;Card
    title=&quot;Agent Behavior&quot;
    icon=&quot;robot&quot;
    href=&quot;/settings/agent-behavior&quot;
  &gt;
    Configure how agents interact with users and approach code modifications to
    match your workflow preferences.
  &lt;/Card&gt;

  &lt;Card
    title=&quot;Agent Permissions&quot;
    icon=&quot;shield-check&quot;
    href=&quot;/settings/agent-permissions&quot;
  &gt;
    Control what actions agents are allowed to perform, including PR creation,
    rules detection, and security policies.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Organization Settings

&lt;CardGroup cols={2}&gt;
  &lt;Card
    title=&quot;Repository Rules&quot;
    icon=&quot;shield-check&quot;
    href=&quot;/settings/repo-rules&quot;
  &gt;
    Set repository-specific rules and coding standards that agents automatically
    follow when working on your codebase.
  &lt;/Card&gt;

  &lt;Card title=&quot;Team &amp; User Roles&quot; icon=&quot;users&quot; href=&quot;/settings/team-roles&quot;&gt;
    Manage team members and control access through hierarchical role permissions
    for admins, managers, and members.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Model Configuration

&lt;CardGroup cols={1}&gt;
  &lt;Card title=&quot;LLM Choice and API Keys&quot; href=&quot;/settings/model-configuration&quot;&gt;
    Choose your preferred LLM provider and model, configure custom API keys, and
    optimize performance settings.
  &lt;/Card&gt;
&lt;/CardGroup&gt;

## Getting Started

Settings are organized into logical groups for easy configuration:

- **Agent &amp; Repository Settings** - Core agent behavior and permissions that define how agents work
- **Organization Settings** - Repository rules and team management for organizational control
- **Model Configuration** - AI model selection and API key configuration for performance optimization

&lt;Tip&gt;
  Start by configuring repository rules for your most active repositories, then
  optimize model settings based on your team&apos;s performance and cost
  requirements.
&lt;/Tip&gt;

&lt;Note&gt;
  Some settings may require specific plan tiers or administrative permissions
  within your organization.
&lt;/Note&gt;</file><file path="docs/settings/team-roles.mdx">---
title: &quot;Team &amp; User Roles&quot;
sidebarTitle: &quot;Team Roles&quot;
icon: &quot;users&quot;
---

Manage your team members and control access to organization features through a hierarchical role system.

&lt;Card
  title=&quot;Manage Team Members&quot;
  icon=&quot;users&quot;
  href=&quot;https://codegen.com/users/members&quot;
&gt;
  Add, remove, and manage roles for team members in your organization.
&lt;/Card&gt;

## User Roles

Codegen uses three distinct roles to ensure proper access control while allowing teams to delegate responsibilities appropriately.

| Feature               | Member  | Manager | Admin |
| --------------------- | :-----: | :-----: | :---: |
| View repositories     |   âœ…    |   âœ…    |  âœ…   |
| Use agents            |   âœ…    |   âœ…    |  âœ…   |
| Manage integrations   |   âŒ    |   âœ…    |  âœ…   |
| Delete repositories   |   âŒ    |   âŒ    |  âœ…   |
| Access billing        |   âŒ    |   âŒ    |  âœ…   |
| Change user roles     |   âŒ    |   âŒ    |  âœ…   |
| Organization settings | Limited | Limited | Full  |

### ðŸ”´ ADMIN (Highest Level)

Full administrative access to the organization with complete control over all features and settings.

**Permissions:**

- Full administrative access to the organization
- Delete repositories (only admins can do this)
- Manage billing and subscription settings
- Change user roles (promote/demote team members)
- Manage integrations (GitHub, Linear, etc.)
- Access to all features and settings
- Organization-wide configuration control

### ðŸŸ¡ MANAGER (Middle Level)

Operational permissions for day-to-day management without administrative controls.

**Permissions:**

- Manage integrations (GitHub, Linear, etc.)
- Most operational permissions
- View and work with all repositories
- Configure agent settings and behaviors

**Restrictions:**

- Cannot delete repositories
- Cannot access billing settings
- Cannot change user roles
- Limited organization settings access

### ðŸŸ¢ MEMBER (Basic Level)

Basic access for individual contributors with limited administrative permissions.

**Permissions:**

- View and work with repositories
- Use agents and integrations
- Basic read/write access to projects

**Restrictions:**

- Cannot manage integrations
- Cannot delete repositories
- Cannot access billing
- Cannot change user roles
- Restricted administrative access

## Role Management

- **New team members** are assigned the **MEMBER** role by default
- **Only ADMIN users** can promote or demote other team members
- **Privilege escalation prevention** - you cannot give someone a higher role than your own

&lt;Note&gt;
  Role permissions apply across all Codegen features including agent
  interactions, integrations, and organizational settings. Changes to roles take
  effect immediately.
&lt;/Note&gt;</file><file path="docs/settings/trufflehog-integration.mdx">---
title: &quot;Trufflehog Secret Scanning&quot;
sidebarTitle: &quot;Trufflehog Integration&quot;
icon: &quot;shield-check&quot;
---

Codegen integrates [Trufflehog](https://github.com/trufflesecurity/trufflehog), an open-source secret scanning tool, to automatically detect and prevent sensitive information from being committed to your repositories. This security layer protects against accidental exposure of API keys, passwords, tokens, and other secrets.

&lt;Card
  title=&quot;Configure Repository Settings&quot;
  icon=&quot;gear&quot;
  href=&quot;https://codegen.com/repos&quot;
&gt;
  Manage Trufflehog scanning and other security settings for your repositories.
&lt;/Card&gt;

## How It Works

Trufflehog scanning operates at two key points in the development workflow:

### Pre-Push Hook Scanning

When you push code to a repository, Trufflehog automatically scans all modified and added files for potential secrets before the push completes.

**The scanning process:**

1. **File Detection** - Identifies all files that have been added, modified, or changed in the push
2. **Pattern Filtering** - Applies `.trufflehogignore` patterns to exclude files that shouldn&apos;t be scanned
3. **Secret Scanning** - Runs Trufflehog with comprehensive detection rules for verified, unknown, and unverified secrets
4. **Push Control** - Blocks the push if potential secrets are detected, allowing you to review and remediate

### Agent Commit Scanning

When Codegen agents create commits using the signed commit feature, Trufflehog scans all files before the commit is created.

**Agent scanning includes:**

- **Automatic Detection** - Scans all files being committed without manual intervention
- **Configurable Bypass** - Agents can skip scanning for confirmed false positives using the `skip_trufflehog` parameter
- **Error Reporting** - Provides detailed feedback about detected secrets with remediation guidance

## Configuration

### Ignore Patterns

Create a `.trufflehogignore` file in your repository root to exclude files from scanning:

```gitignore
# Documentation and configuration files
*.md
*.txt
docs/
README*

# Test fixtures and mock data
test/fixtures/
**/mocks/
*.test.js

# Build artifacts
dist/
build/
node_modules/
```

The ignore file supports:

- **Glob patterns** for matching file paths
- **Regular expressions** for complex matching rules
- **Comments** using `#` for documentation
- **Directory exclusions** with trailing slashes

### Scanning Scope

Trufflehog scans for multiple types of secrets:

- **API Keys** - AWS, Google Cloud, Azure, and hundreds of other services
- **Database Credentials** - Connection strings, passwords, and authentication tokens
- **Private Keys** - SSH keys, SSL certificates, and cryptographic material
- **Authentication Tokens** - JWT tokens, OAuth secrets, and session identifiers

## Working with Detections

### When Trufflehog Blocks a Push

If Trufflehog detects potential secrets during a push, you&apos;ll see output similar to:

```bash
âŒ Trufflehog found potential secrets or issues. Aborting push.
```

**To resolve:**

1. **Review the detected secrets** - Examine the flagged content carefully
2. **Remove actual secrets** - Replace real credentials with environment variables or configuration
3. **Update ignore patterns** - Add false positives to `.trufflehogignore` if appropriate
4. **Bypass if necessary** - Use `git push --no-verify` only for confirmed false positives

### Agent Commit Handling

When agents encounter Trufflehog detections, they receive detailed error messages:

```
ðŸ”’ TruffleHog security scan failed - potential secrets detected:
[Detection details]

Please review and remove any secrets before committing.
To skip this check (not recommended), set skip_trufflehog=true
```

Agents can bypass scanning using the `skip_trufflehog=true` parameter, but this should only be used for confirmed false positives.

## Best Practices

### Repository Setup

- **Add `.trufflehogignore` early** - Configure ignore patterns when setting up repositories
- **Document exceptions** - Comment ignore patterns to explain why files are excluded
- **Regular reviews** - Periodically audit ignore patterns to ensure they&apos;re still appropriate

### Secret Management

- **Use environment variables** - Store secrets in environment variables or secure configuration systems
- **Implement secret rotation** - Regularly rotate API keys and credentials
- **Monitor for exposure** - Set up alerts for any secrets that might be accidentally committed

### Team Workflow

- **Educate developers** - Ensure team members understand how Trufflehog works and why it&apos;s important
- **Handle false positives** - Establish clear processes for dealing with false positive detections
- **Emergency procedures** - Have plans for handling actual secret exposures if they occur

&lt;Warning&gt;
  Never use `--no-verify` or `skip_trufflehog=true` to bypass real secret
  detections. These options should only be used for confirmed false positives
  after careful review.
&lt;/Warning&gt;

## Troubleshooting

### Common Issues

**High false positive rate:**
- Review and update `.trufflehogignore` patterns
- Consider excluding test files, documentation, or configuration templates

**Scanning performance:**
- Large repositories may experience slower push times
- Consider excluding build artifacts and generated files

**Agent commit failures:**
- Review the specific detection details in error messages
- Update code to use proper secret management practices
- Use `skip_trufflehog=true` only for confirmed false positives

### Getting Help

If you encounter persistent issues with Trufflehog scanning:

1. **Check ignore patterns** - Verify `.trufflehogignore` syntax and coverage
2. **Review detection details** - Examine the specific content flagged by Trufflehog
3. **Contact support** - Reach out to Codegen support for assistance with configuration

&lt;Note&gt;
  Trufflehog integration helps maintain security best practices by preventing
  accidental secret exposure, but it should be part of a comprehensive security
  strategy that includes proper secret management and regular security reviews.
&lt;/Note&gt;</file><file path="docs/snippets/Attribute.mdx">export const Attribute = ({ type, description }) =&gt; (
  &lt;div className=&quot;pl-4 py-6 first:pt-3 dark:border-zinc-300/[0.06] text-sm font-normal&quot;&gt;
    &lt;div className=&quot;inline-grid grid-cols-[auto_auto] gap-1 font-mono py-2&quot;&gt;
      {type}
    &lt;/div&gt;
    &lt;p className=&quot;mt-2&quot;&gt;{description}&lt;/p&gt;
  &lt;/div&gt;
)</file><file path="docs/snippets/GithubLinkNote.mdx">export const GithubLinkNote = ({link}) =&gt; (
   &lt;Info&gt;
      &lt;div className=&quot;flex gap-2 items-center&quot;&gt;View Source on &lt;a target=&quot;_blank&quot;  rel=&quot;noopener noreferrer&quot; href={link}&gt;Github&lt;/a&gt;&lt;/div&gt;
   &lt;/Info&gt;
)</file><file path="docs/snippets/HorizontalDivider.mdx">export const HorizontalDivider = ({light=false}) =&gt; (
    &lt;div className=&quot;divide-y&quot;&gt;
        &lt;div className={`divide-y ${light ? &quot;dark:border-zinc-300/[0.06]&quot; : &quot;border-zinc-600&quot;}`}&gt;&lt;/div&gt;
        &lt;div className={`divide-y ${light ? &quot;dark:border-zinc-300/[0.06]&quot; : &quot;border-zinc-600&quot;}`}&gt;&lt;/div&gt;
    &lt;/div&gt;
)</file><file path="docs/snippets/links.mdx">export const COMMUNITY_SLACK_URL = &quot;https://community.codegen.com&quot;;

export const CODEGEN_SDK_GITHUB_URL =
  &quot;https://github.com/codegen-sh/codegen-sdk&quot;;

export const CODEGEN_SDK_EXAMPLES_GITHUB_URL =
  &quot;https://github.com/codegen-sh/codegen-examples&quot;;

export const CODEGEN_SYSTEM_PROMPT = &quot;https://raw.githubusercontent.com/codegen-sh/codegen-sdk/refs/heads/develop/src/codegen/sdk/system-prompt.txt&quot;</file><file path="docs/snippets/Parameter.mdx">export const Parameter = ({name, type, description, defaultValue}) =&gt; (
  &lt;div className=&quot;py-6 first:pt-3 dark:border-zinc-300/[0.06] text-sm font-normal&quot;&gt;
    &lt;div className=&quot;flex justify-between items-start font-mono&quot;&gt;
      &lt;div className=&quot;flex gap-4 items-start&quot;&gt;
        &lt;div className=&quot;flex gap-1 items-center text-sm text-primary mt-2&quot;&gt;
          {name}
        &lt;/div&gt;
        &lt;div className=&quot;inline-grid grid-cols-[auto_auto] gap-1 py-2&quot;&gt;
          {type}
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div className=&quot;flex-shrink-0 mt-2&quot;&gt;
        {defaultValue ? (
          &lt;div className=&quot;flex gap-1 items-center text-sm border border-purple-500 px-2 py-0.5 rounded&quot;&gt;
            &lt;span className=&quot;text-zinc-500&quot;&gt;default:&lt;/span&gt;
            &lt;span className=&quot;text-purple-500&quot;&gt;{defaultValue}&lt;/span&gt;
          &lt;/div&gt;
        ) : (
          &lt;span className=&quot;text-sm border border-purple-500 px-2 py-0.5 rounded&quot;&gt;
            required
          &lt;/span&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;p className=&quot;mt-2&quot;&gt;{description}&lt;/p&gt;
  &lt;/div&gt;
)</file><file path="docs/snippets/ParameterWrapper.mdx">export const ParameterWrapper = ({ children }) =&gt; (
  &lt;div className=&quot;pl-6 divide-y&quot;&gt;
    &lt;h4 className=&quot;font-bold&quot;&gt;Parameters&lt;/h4&gt;
    &lt;div className=&quot;divide-y dark:border-zinc-300/[0.06]&quot;&gt;
      {children}
    &lt;/div&gt;
  &lt;/div&gt;
)</file><file path="docs/snippets/Return.mdx">export const Return = ({return_type, description}) =&gt; (
  &lt;div className=&quot;pl-6 divide-y&quot;&gt;
    &lt;h4 className=&quot;font-bold&quot;&gt;Returns&lt;/h4&gt;
    &lt;div className=&quot;dark:border-zinc-300/[0.06] &quot;&gt;
        &lt;div className=&quot;py-6 first:pt-3 text-sm font-normal&quot;&gt;
            &lt;div className=&quot;flex gap-4 items-center&quot;&gt;
                &lt;div className=&quot;inline-grid grid-cols-[auto_auto] gap-1 font-mono py-2&quot;&gt;
                    {return_type}
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;p className=&quot;mt-2&quot;&gt;{description}&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
)</file><file path="docs/users/get-user.mdx">---
openapi: get /v1/organizations/{org_id}/users/{user_id}
---</file><file path="docs/users/get-users.mdx">---
openapi: get /v1/organizations/{org_id}/users
---</file><file path="docs/.gitignore">OLD/*</file><file path="docs/docs.json">{
  &quot;$schema&quot;: &quot;https://mintlify.com/docs.json&quot;,
  &quot;theme&quot;: &quot;maple&quot;,
  &quot;name&quot;: &quot;Codegen&quot;,
  &quot;colors&quot;: {
    &quot;primary&quot;: &quot;#a277ff&quot;,
    &quot;light&quot;: &quot;#a277ff&quot;,
    &quot;dark&quot;: &quot;#a277ff&quot;
  },
  &quot;favicon&quot;: &quot;/favicon.svg&quot;,
  &quot;navigation&quot;: {
    &quot;tabs&quot;: [
      {
        &quot;tab&quot;: &quot;Documentation&quot;,
        &quot;groups&quot;: [
          {
            &quot;group&quot;: &quot;Overview&quot;,
            &quot;pages&quot;: [
              &quot;introduction/overview&quot;,
              &quot;introduction/use-cases&quot;,
              &quot;introduction/support&quot;,
              &quot;introduction/community&quot;,
              &quot;introduction/about&quot;,
              &quot;introduction/prompting&quot;,
              &quot;introduction/faq&quot;
            ]
          },
          {
            &quot;group&quot;: &quot;Guides&quot;,
            &quot;pages&quot;: [
              &quot;capabilities/capabilities&quot;,
              &quot;capabilities/triggering-codegen&quot;,
              &quot;capabilities/checks-autofixer&quot;,
              &quot;capabilities/pr-review&quot;,
              &quot;capabilities/claude-code&quot;,
              &quot;capabilities/analytics&quot;,
              &quot;introduction/cli&quot;,
              &quot;introduction/sdk&quot;,
              &quot;settings/on-prem-deployment&quot;
            ]
          },
          {
            &quot;group&quot;: &quot;Settings&quot;,
            &quot;pages&quot;: [
              &quot;settings/settings&quot;,
              &quot;settings/repo-rules&quot;,
              &quot;settings/model-configuration&quot;,
              &quot;settings/agent-behavior&quot;,
              &quot;settings/agent-permissions&quot;,
              &quot;settings/team-roles&quot;,
              &quot;settings/trufflehog-integration&quot;
            ]
          },
          {
            &quot;group&quot;: &quot;Integrations&quot;,
            &quot;pages&quot;: [
              &quot;integrations/integrations&quot;,
              &quot;integrations/github&quot;,
              &quot;integrations/slack&quot;,
              &quot;integrations/linear&quot;,
              &quot;integrations/notion&quot;,
              &quot;integrations/figma&quot;,
              &quot;integrations/jira&quot;,
              &quot;integrations/clickup&quot;,
              &quot;integrations/monday&quot;,
              &quot;integrations/sentry&quot;,
              &quot;integrations/circleci&quot;,
              &quot;integrations/web-search&quot;,
              &quot;integrations/postgres&quot;,
              &quot;integrations/mcp-servers&quot;
            ]
          },
          {
            &quot;group&quot;: &quot;Sandboxes&quot;,
            &quot;pages&quot;: [
              &quot;sandboxes/overview&quot;,
              &quot;sandboxes/setup-commands&quot;,
              &quot;sandboxes/environment-variables&quot;,
              &quot;sandboxes/secrets&quot;,
              &quot;sandboxes/editor&quot;,
              &quot;sandboxes/web-preview&quot;
            ]
          }
        ]
      },
      {
        &quot;tab&quot;: &quot;API Reference&quot;,
        &quot;groups&quot;: [
          {
            &quot;group&quot;: &quot;Guides&quot;,
            &quot;pages&quot;: [
              &quot;api-reference/overview&quot;,
              &quot;api-reference/authentication&quot;,
              &quot;api-reference/agent-run-logs&quot;
            ]
          },
          {
            &quot;group&quot;: &quot;Endpoints&quot;,
            &quot;openapi&quot;: {
              &quot;source&quot;: &quot;/api-reference/openapi3.json&quot;,
              &quot;directory&quot;: &quot;api-reference&quot;
            }
          }
        ]
      }
    ]
  },
  &quot;logo&quot;: {
    &quot;light&quot;: &quot;https://cdn.prod.website-files.com/67070304751b9b01bf6a161c/679bcf45bf55446746125835_Codegen_Logomark_Light.svg&quot;,
    &quot;dark&quot;: &quot;https://cdn.prod.website-files.com/67070304751b9b01bf6a161c/679bcf45a3e32761c42b324b_Codegen_Logomark_Dark.svg&quot;
  },
  &quot;appearance&quot;: {
    &quot;default&quot;: &quot;dark&quot;
  },
  &quot;background&quot;: {
    &quot;decoration&quot;: &quot;gradient&quot;
  },
  &quot;navbar&quot;: {
    &quot;primary&quot;: {
      &quot;type&quot;: &quot;button&quot;,
      &quot;label&quot;: &quot;GitHub&quot;,
      &quot;href&quot;: &quot;https://github.com/codegen-sh/codegen-sdk&quot;
    }
  },
  &quot;seo&quot;: {
    &quot;metatags&quot;: {
      &quot;og:site_name&quot;: &quot;Codegen&quot;,
      &quot;og:title&quot;: &quot;Codegen - The SWE that Never Sleeps&quot;,
      &quot;og:description&quot;: &quot;Code agents accessible via API, Slack, Linear, Github, and more.&quot;,
      &quot;og:url&quot;: &quot;https://docs.codegen.com&quot;,
      &quot;og:locale&quot;: &quot;en_US&quot;,
      &quot;og:logo&quot;: &quot;https://i.imgur.com/f4OVOqI.png&quot;,
      &quot;article:publisher&quot;: &quot;Codegen, Inc.&quot;,
      &quot;twitter:site&quot;: &quot;@codegen&quot;
    },
    &quot;indexing&quot;: &quot;navigable&quot;
  },
  &quot;footer&quot;: {
    &quot;socials&quot;: {
      &quot;x&quot;: &quot;https://x.com/codegen&quot;,
      &quot;linkedin&quot;: &quot;https://linkedin.com/company/codegen-dot-com&quot;
    }
  },
  &quot;integrations&quot;: {
    &quot;posthog&quot;: {
      &quot;apiKey&quot;: &quot;phc_GLxaINoQJnuyCyxDmTciQqzdKBYFVDkY7bRBO4bDdso&quot;
    }
  }
}</file><file path="docs/favicon.svg">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;svg id=&quot;Layer_2&quot; width=&quot;20&quot; height=&quot;20&quot; data-name=&quot;Layer 2&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 80.87 80.87&quot;&gt;
  &lt;defs&gt;
    &lt;style&gt;
      .cls-1 {
        fill: #ffffff;
        stroke-width: 0px;
      }
      .background {
        fill: #2700E5;
      }
    &lt;/style&gt;
  &lt;/defs&gt;
  &lt;rect class=&quot;background&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;80.87&quot; height=&quot;80.87&quot; /&gt;
  &lt;g id=&quot;Layer_1-2&quot; data-name=&quot;Layer 1&quot; transform=&quot;scale(0.8) translate(8.087, 8.087)&quot;&gt;
    &lt;g&gt;
      &lt;path class=&quot;cls-1&quot; d=&quot;M57.34,27.51c-.79.79-.79,2.07,0,2.86l8.64,8.64c.79.79.79,2.07,0,2.86l-8.64,8.64c-.79.79-.79,2.07,0,2.86l4.29,4.29c.79.79,2.07.79,2.86,0l15.79-15.79c.79-.79.79-2.07,0-2.86l-15.79-15.79c-.79-.79-2.07-.79-2.86,0l-4.29,4.29Z&quot;/&gt;
      &lt;path class=&quot;cls-1&quot; d=&quot;M50.19,60.51c-.79-.79-2.07-.79-2.86,0l-5.47,5.47c-.79.79-2.07.79-2.86,0l-24.12-24.12c-.79-.79-.79-2.07,0-2.86l24.12-24.12c.79-.79,2.07-.79,2.86,0l5.47,5.47c.79.79,2.07.79,2.86,0l4.29-4.29c.79-.79.79-2.07,0-2.86L41.86.59c-.79-.79-2.07-.79-2.86,0L.59,39.01c-.79.79-.79,2.07,0,2.86l38.41,38.41c.79.79,2.07.79,2.86,0l12.62-12.62c.79-.79.79-2.07,0-2.86l-4.29-4.29Z&quot;/&gt;
      &lt;path class=&quot;cls-1&quot; d=&quot;M50.54,40.44c0,5.58-4.53,10.11-10.11,10.11-5.58,0-10.11-4.53-10.11-10.11s4.53-10.11,10.11-10.11c5.58,0,10.11,4.53,10.11,10.11Z&quot;/&gt;
    &lt;/g&gt;
  &lt;/g&gt;
&lt;/svg&gt;</file><file path="docs/prism.css">/* Override font variables */
:root {
	--font-jetbrains-mono: Menlo, Monaco, &quot;Courier New&quot;, monospace !important;
	/* --font-jetbrains-mono: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace !important; */
}

pre[class*=&quot;language-&quot;],
code[class*=&quot;language-&quot;],
pre,
code,
kbd,
samp {
	font-family: Menlo, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace !important;
	--font-jetbrains-mono: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;,
		monospace !important;
	font-weight: 500 !important;
}

pre[class*=&quot;language-&quot;] {
	font-family: Menlo, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace !important;
	font-weight: 500 !important;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;
	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;
	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}
pre[class*=&quot;language-&quot;]::-moz-selection,
pre[class*=&quot;language-&quot;] ::-moz-selection,
code[class*=&quot;language-&quot;]::-moz-selection,
code[class*=&quot;language-&quot;] ::-moz-selection {
	text-shadow: none;
	background: #362d45;
}
pre[class*=&quot;language-&quot;]::selection,
pre[class*=&quot;language-&quot;] ::selection,
code[class*=&quot;language-&quot;]::selection,
code[class*=&quot;language-&quot;] ::selection {
	text-shadow: none;
	background: #362d45;
}
@media print {
	code[class*=&quot;language-&quot;],
	pre[class*=&quot;language-&quot;] {
		text-shadow: none;
	}
}
/* Code blocks */
pre[class*=&quot;language-&quot;] {
	padding: 1em;
	margin: 0.5em 0;
	overflow: auto;
}
:not(pre) &gt; code[class*=&quot;language-&quot;],
pre[class*=&quot;language-&quot;] {
	color: white;
}
:not(pre) &gt; code[class*=&quot;language-&quot;] {
	padding: 0.1em;
	border-radius: 0.3em;
	white-space: normal;
}

.language-python .language-bash {
	background-color: #15141b !important;
	font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace !important;
	font-weight: 600 !important;
	font-size: 16px !important;
}

.dark\:bg-codeblock:is(.dark *) {
	background-color: #15141b !important;
}

.dark\:ring-gray-800\/50:is(.dark *) {
	--tw-ring-color: #15141b !important;
}

.codeblock-dark {
	background-color: #15141b !important;
	color: #edecee !important;
	font-size: 20px !important;
}

.dark .prose {
	color: #edecee !important;
	font-size: 16px !important;
}

/* single backticks are orange */
.dark .prose p code {
	color: #ffca85 !important;
}
.dark .prose p code .comment {
	color: #6d6d6d !important;
}
.dark .prose ul code {
	color: #ffca85 !important;
}
.dark .prose ul code .comment {
	color: #6d6d6d !important;
}

/* Comments in code blocks should be gray */
.token.comment {
	color: #6d6d6d !important;
}
pre .token.comment {
	color: #6d6d6d !important;
}
code .token.comment {
	color: #6d6d6d !important;
}

/* links are purple */
.prose a {
	color: #a277ff !important;
}

.token.tag {
	color: #a277ff !important;
}
.token.variable {
	color: #a277ff !important;
}
.token.keyword {
	color: #a277ff !important;
}
.token.operator {
	color: #a277ff !important;
}
.token.attr-name {
	color: #a277ff !important;
}
.token.punctuation {
	color: #a277ff !important;
}
.token.constant {
	color: #a277ff !important;
}
.token.string {
	color: #61ffca !important;
}
.token.inserted {
	color: #61ffca !important;
}
.token.changed {
	color: #ffca85 !important;
}
.token.function {
	color: #ffca85 !important;
}
.token.deleted {
	color: #ff6767 !important;
}
.token.builtin {
	color: #ffca85 !important;
}
.token.property {
	color: #ffca85 !important;
}
.token.class-name {
	color: #82e2ff !important;
}
.token.important,
.token.bold {
	font-weight: bold !important;
}
.token.italic {
	font-style: italic !important;
}

.language-bash {
	color: #ffca85 !important;
}

.language-bash .token {
	color: #ffca85 !important;
	font-weight: 700 !important;
}</file><file path="docs/README.md"># Codegen Docs

## Development

From within the `docs/` subdirectory:

```bash
npm i -g mintlify
mintlify dev --port 3333
```

You should then get hot reloading. Also recommend installing the `MDX` extension for VSCode.

## Adding New Pages

- Edit the page as a `.mdx` doc
- Make sure to edit `mint.json` so it appears in the UI</file><file path="docs/self-update.md"># Self-Update System for Codegen CLI

The Codegen CLI includes a simplified self-update system that allows users to easily update to the latest version.

## Features

### ðŸš€ Smart Update Detection
- Automatically detects installation method (pip, pipx, uv tool, homebrew, development)
- Checks for updates periodically (once per day by default)
- Shows update notifications when new versions are available
- Fetches stable releases from PyPI

### ðŸ”„ Update Management
- Update to latest stable version
- Update to specific versions
- Dry-run mode to preview changes
- Legacy mode for simple pip upgrades

### ðŸ›¡ï¸ Safety Features
- Pre-update validation checks
- Major version update warnings
- Post-update tips and guidance

### ðŸ“Š Version Information
- List available versions
- Check for updates without installing
- View current and latest versions

## Usage

### Basic Commands

```bash
# Update to latest stable version
codegen update

# Check for available updates without installing
codegen update --check

# List available versions
codegen update --list

# Show version history
codegen update --history
```

### Advanced Options

```bash
# Update to specific version
codegen update --version 1.2.3

# Preview update without making changes
codegen update --dry-run

# Force update check (bypass cache)
codegen update --force

# Use legacy pip upgrade method
codegen update --legacy
```

## Release Information

The update system fetches stable releases from PyPI. Pre-release versions are automatically filtered out to ensure stability. Only production-ready versions are shown and available for installation through the update command.

## Installation Methods

The update system automatically detects how Codegen was installed and uses the appropriate update method:

### pip Installation
```bash
pip install codegen
# Updates via: pip install --upgrade codegen
```

### pipx Installation
```bash
pipx install codegen
# Updates via: pipx upgrade codegen
```

### UV Tool Installation
```bash
uv tool install codegen
# Updates via: uv tool install --upgrade codegen
```

### Homebrew Installation (macOS)
```bash
brew install codegen
# Updates via: brew upgrade codegen
```

### Development Installation
For development/editable installs, the update system will notify you to update via git:
```bash
git pull origin main
pip install -e .
```

## Update Process

The update system performs a streamlined update process:

### How Updates Work

1. **Version Check**: Fetches available versions from PyPI
2. **Comparison**: Compares current version with available versions
3. **Confirmation**: Asks for user confirmation before proceeding
4. **Installation**: Uses the appropriate package manager to update
5. **Verification**: Displays success message and restart instructions

### Major Version Updates

When updating to a new major version:
- The system warns about potential breaking changes
- Post-update tips are displayed
- Users are encouraged to check the changelog

## Update Notifications

The CLI checks for updates periodically and shows notifications when new versions are available:

```
â„¹ï¸  A new version of Codegen CLI is available: 1.2.3
Run &apos;codegen update&apos; to upgrade
```

### Disable Update Checks

To disable automatic update checks, set the environment variable:

```bash
export CODEGEN_DISABLE_UPDATE_CHECK=1
```

## Downgrading

If an update causes issues, you can downgrade to a previous version:

```bash
# Downgrade to a specific version
codegen update --version 1.2.2

# Or use your package manager directly
pip install codegen==1.2.2
pipx install codegen==1.2.2 --force
uv tool install codegen==1.2.2 --upgrade
```

## Configuration

Update settings are stored in `~/.codegen/`:

- `update_check.json` - Last update check timestamp and cache

## Troubleshooting

### Update Fails

1. Try using the legacy update method:
   ```bash
   codegen update --legacy
   ```

2. Manually update via pip:
   ```bash
   pip install --upgrade codegen
   ```

3. Check installation method:
   ```bash
   which codegen
   pip show codegen
   ```

### Permission Errors

If you get permission errors, you may need to use sudo (not recommended) or update your user installation:

```bash
# For user installation
pip install --user --upgrade codegen

# For pipx
pipx upgrade codegen
```

### Downgrade Issues

If you need to downgrade:

1. Use the update command with a specific version:
   ```bash
   codegen update --version 1.2.2
   ```

2. Or manually install the desired version:
   ```bash
   pip install codegen==1.2.2
   pipx install codegen==1.2.2 --force
   uv tool install codegen==1.2.2 --upgrade
   ```

## Development

### Testing Updates

Test the update system in development:

```bash
# Check current version
codegen --version

# Test update check
codegen update --check --force

# Test dry-run update
codegen update --dry-run

# Test specific version
codegen update --version 1.2.3 --dry-run
```

### Adding New Features

To add new update features:

1. Modify `updater.py` for core functionality
2. Update command options in `main.py`
3. Add tests for new functionality

## API Reference

### UpdateManager Class

```python
from codegen.cli.commands.update import UpdateManager

manager = UpdateManager()

# Check for updates
result = manager.check_for_updates(force=True)

# Perform update
success = manager.perform_update(target_version=&quot;1.2.3&quot;, dry_run=False)

# Check installation method
print(manager.install_method)
```

### Installation Methods

```python
from codegen.cli.commands.update.updater import InstallMethod

methods = [
    InstallMethod.PIP,
    InstallMethod.PIPX,
    InstallMethod.UV_TOOL,
    InstallMethod.HOMEBREW,
    InstallMethod.DEVELOPMENT,
    InstallMethod.UNKNOWN
]
```

## Best Practices

1. **Regular Updates**: Keep your CLI updated for latest features and security fixes
2. **Check Changelog**: Review breaking changes before major version updates
3. **Test in Dev**: Test updates in development environment first
4. **Use Dry Run**: Preview updates with `--dry-run` before applying
5. **Report Issues**: Report update issues to help improve the system

## Security

- Updates are fetched over HTTPS from PyPI
- Package signatures are verified by pip/pipx/uv
- Pre-release versions are filtered out automatically
- Major version updates require confirmation

## Future Enhancements

- [ ] Automatic rollback on update failure
- [ ] Configuration migration system
- [ ] Release notes integration
- [ ] Beta and nightly release channels
- [ ] Binary distribution for faster updates
- [ ] Automatic security update installation
- [ ] Update progress with detailed logging
- [ ] Network proxy support
- [ ] Offline update packages</file><file path="docs/style.css">.dark .bg-codeblock {
	background-color: #15141b !important;
}</file><file path="scripts/profiling/profile.py">import os
import subprocess
from subprocess import Popen

import typer


def profile(repo: str, memory: bool = False, extra_repos: bool = True):
    type = &quot;mem&quot; if memory else &quot;cpu&quot;
    base = f&quot;.profiles/{type}/{repo}&quot;
    os.makedirs(base, exist_ok=True)
    output = f&quot;{base}/raw.austin&quot;
    compressed = f&quot;{base}/compressed.austin&quot;
    image = f&quot;{base}/parse.svg&quot;
    test = Popen([&quot;pytest&quot;, &quot;tests/integration/codemod/test_parse.py&quot;, &quot;--durations=100&quot;, &quot;-k&quot;, repo, &quot;--extra-repos=True&quot; if extra_repos else &quot;&quot;])
    try:
        command = [&quot;sudo&quot;, &quot;austin&quot;, &quot;-p&quot;, str(test.pid), &quot;-o&quot;, output]
        if memory:
            command.append(&quot;-m&quot;)
        subprocess.run(command)
        for_flamegraph = output
        # try:
        #     print(&quot;Compressing output&quot;)
        #     subprocess.run([&quot;austin-compress&quot;, output, compressed], check=True)
        #     for_flamegraph = compressed
        # except subprocess.CalledProcessError as e:
        #     print(&quot;Error compressing:&quot;, e)
        if compressed == for_flamegraph:
            print(&quot;Opening image with speedscope&quot;)
            os.system(f&quot;speedscope {compressed}&quot;)
        else:
            print(&quot;Converting to svg&quot;)
            os.system(f&quot;flamegraph.pl {for_flamegraph} &gt; {image}&quot;)
            print(&quot;Opening image&quot;)
            os.system(f&quot;open {image}&quot;)
    finally:
        test.kill()


def main():
    typer.run(profile)


if __name__ == &quot;__main__&quot;:
    main()</file><file path="scripts/disallowed-words-check.sh">#!/usr/bin/env bash

DISALLOWED_WORDS_FILE=&quot;.github/disallowed-words.txt&quot;

# 1) If the file doesn&apos;t exist, fail the commit.
if [[ ! -f &quot;$DISALLOWED_WORDS_FILE&quot; ]]; then
  echo &quot;ERROR: $DISALLOWED_WORDS_FILE not found.&quot;
  echo &quot;Cannot proceed with disallowed word checks.&quot;
  exit 1
fi

# 2) If Git LFS isn&apos;t installed, fail the commit.
if ! command -v git-lfs &amp;&gt;/dev/null; then
  echo &quot;ERROR: Git LFS not installed or not in PATH.&quot;
  echo &quot;Cannot proceed with disallowed word checks.&quot;
  exit 1
fi

# 3) If the file is still an LFS pointer (not synced), fail the commit.
if grep -q &quot;https://git-lfs.github.com/spec/v1&quot; &quot;$DISALLOWED_WORDS_FILE&quot;; then
  echo &quot;ERROR: $DISALLOWED_WORDS_FILE is an LFS pointer but not synced.&quot;
  echo &quot;Cannot proceed with disallowed word checks.&quot;
  exit 1
fi

# 4) Read the disallowed words (one per line).
DISALLOWED_WORDS=&quot;$(grep -v &apos;^[[:space:]]*$&apos; &quot;$DISALLOWED_WORDS_FILE&quot;)&quot;
if [[ -z &quot;$DISALLOWED_WORDS&quot; ]]; then
  echo &quot;ERROR: No disallowed words found in $DISALLOWED_WORDS_FILE.&quot;
  echo &quot;Cannot proceed with disallowed word checks.&quot;
  exit 1
fi

# Build a single regex WITHOUT word boundaries.
# NOTE: This is intentionally strict. For example, banning &quot;cat&quot; also flags &quot;catastrophic&quot;.
# Will tweak and change this to a more lenient regex later.
DISALLOWED_REGEX=&quot;($(echo &quot;$DISALLOWED_WORDS&quot; | paste -s -d &apos;|&apos; -))&quot;

# 5) Find staged files that are Added (A) or Modified (M).
FILES_TO_CHECK=$(git diff --cached --name-status | egrep &apos;^[AM]&apos; | cut -f2)
# FILES_TO_CHECK=$(git ls-files)  # Uncomment this to check ALL files - CAUTION: SLOW!

FAILED=0

# 6) For each file:
#    - Check the filename itself.
#    - Check the file contents (if it exists).
for FILE in $FILES_TO_CHECK; do
  FILENAME_MATCHES=$(echo &quot;$FILE&quot; | grep -i -E -o &quot;$DISALLOWED_REGEX&quot;)
  if [[ -n &quot;$FILENAME_MATCHES&quot; ]]; then
    echo &quot;ERROR: Filename &apos;$FILE&apos; contains these disallowed words:&quot;
    echo &quot;$FILENAME_MATCHES&quot;
    FAILED=1
  fi

  if [[ -f &quot;$FILE&quot; ]]; then
    CONTENT_MATCHES=$(grep -I -i -E -o &quot;$DISALLOWED_REGEX&quot; &quot;$FILE&quot; | sort -u)
    if [[ -n &quot;$CONTENT_MATCHES&quot; ]]; then
      echo &quot;ERROR: File &apos;$FILE&apos; contains these disallowed words:&quot;
      echo &quot;$CONTENT_MATCHES&quot;
      FAILED=1
    fi
  fi
done

# 7) Block commit if any violations were found.
if [[ $FAILED -eq 1 ]]; then
  exit 1
fi

exit 0</file><file path="scripts/install-deps.sh">#!/usr/bin/env bash
SUDO=&quot;&quot;
if command -v sudo &amp;&gt; /dev/null; then
    SUDO=&quot;sudo&quot;
fi

if command -v apt &amp;&gt; /dev/null; then
    if ! (command -v clang &amp;&gt; /dev/null || command -v gcc &amp;&gt; /dev/null); then
        echo &quot;Neither clang nor gcc found. Installing gcc...&quot;
        $SUDO apt update &amp;&amp; $SUDO apt install -y gcc build-essential python3-dev
    fi

    $SUDO apt update &amp;&amp; $SUDO apt install -y jq \
        build-essential \
        python3-dev \
        libpixman-1-dev \
        libcairo2-dev \
        libpango1.0-dev \
        libjpeg-dev \
        libgif-dev \
        librsvg2-dev
elif command -v brew &amp;&gt; /dev/null; then
    brew install jq
elif command -v dnf &amp;&gt; /dev/null; then
    $SUDO dnf install -y jq
else
    echo &quot;Error: Could not find package manager to install jq&quot;
    exit 1
fi</file><file path="scripts/setup.sh">#!/usr/bin/env bash
uv tool install pre-commit --with pre-commit-uv
uv tool install deptry
uv tool update-shell
uv venv &amp;&amp; source .venv/bin/activate
uv sync
pre-commit install
pre-commit install-hooks</file><file path="src/codegen/agents/__init__.py">&quot;&quot;&quot;Codegen Agent API module.&quot;&quot;&quot;

from codegen.agents.agent import Agent

__all__ = [&quot;Agent&quot;]</file><file path="src/codegen/agents/agent.py">import os
from typing import Any

from codegen_api_client.api.agents_api import AgentsApi
from codegen_api_client.api_client import ApiClient
from codegen_api_client.configuration import Configuration
from codegen_api_client.models.agent_run_response import AgentRunResponse
from codegen_api_client.models.create_agent_run_input import CreateAgentRunInput

from codegen.agents.constants import CODEGEN_BASE_API_URL
from codegen.cli.utils.org import resolve_org_id


class AgentTask:
    &quot;&quot;&quot;Represents an agent run job.&quot;&quot;&quot;

    def __init__(self, task_data: AgentRunResponse, api_client: ApiClient, org_id: int):
        self.id = task_data.id
        self.org_id = org_id
        self.status = task_data.status
        self.result = task_data.result
        self.web_url = task_data.web_url
        self._api_client = api_client
        self._agents_api = AgentsApi(api_client)

    def refresh(self) -&gt; None:
        &quot;&quot;&quot;Refresh the job status from the API.&quot;&quot;&quot;
        if self.id is None:
            return

        job_data = self._agents_api.get_agent_run_v1_organizations_org_id_agent_run_agent_run_id_get(
            agent_run_id=int(self.id), org_id=int(self.org_id), authorization=f&quot;Bearer {self._api_client.configuration.access_token}&quot;
        )

        # Convert API response to dict for attribute access
        job_dict = {}
        if hasattr(job_data, &quot;__dict__&quot;):
            job_dict = job_data.__dict__
        elif isinstance(job_data, dict):
            job_dict = job_data

        self.status = job_dict.get(&quot;status&quot;)
        self.result = job_dict.get(&quot;result&quot;)


class Agent:
    &quot;&quot;&quot;API client for interacting with Codegen AI agents.&quot;&quot;&quot;

    def __init__(self, token: str | None, org_id: int | None = None, base_url: str | None = CODEGEN_BASE_API_URL):
        &quot;&quot;&quot;Initialize a new Agent client.

        Args:
            token: API authentication token
            org_id: Optional organization ID. If not provided, default org will be used.
        &quot;&quot;&quot;
        self.token = token
        resolved_org = resolve_org_id(org_id)
        if resolved_org is None:
            # Keep previous behavior only as last resort to avoid exceptions in legacy paths
            resolved_org = int(os.environ.get(&quot;CODEGEN_ORG_ID&quot;, &quot;1&quot;))
        self.org_id = resolved_org

        # Configure API client
        config = Configuration(host=base_url, access_token=token)
        self.api_client = ApiClient(configuration=config)
        self.agents_api = AgentsApi(self.api_client)

        # Current job
        self.current_job: AgentTask | None = None

    def run(self, prompt: str) -&gt; AgentTask:
        &quot;&quot;&quot;Run an agent with the given prompt.

        Args:
            prompt: The instruction for the agent to execute

        Returns:
            Job: A job object representing the agent run
        &quot;&quot;&quot;
        run_input = CreateAgentRunInput(prompt=prompt)
        agent_run_response = self.agents_api.create_agent_run_v1_organizations_org_id_agent_run_post(
            org_id=int(self.org_id), create_agent_run_input=run_input, authorization=f&quot;Bearer {self.token}&quot;, _headers={&quot;Content-Type&quot;: &quot;application/json&quot;}
        )
        # Convert API response to dict for Job initialization

        job = AgentTask(agent_run_response, self.api_client, self.org_id)
        self.current_job = job
        return job

    def get_status(self) -&gt; dict[str, Any] | None:
        &quot;&quot;&quot;Get the status of the current job.

        Returns:
            dict: A dictionary containing job status information,
                  or None if no job has been run.
        &quot;&quot;&quot;
        if self.current_job:
            self.current_job.refresh()
            return {&quot;id&quot;: self.current_job.id, &quot;status&quot;: self.current_job.status, &quot;result&quot;: self.current_job.result, &quot;web_url&quot;: self.current_job.web_url}
        return None</file><file path="src/codegen/agents/constants.py">import os

from codegen.cli.api.endpoints import API_ENDPOINT

# Prefer explicit override; fall back to the CLI&apos;s unified API endpoint
CODEGEN_BASE_API_URL = os.environ.get(&quot;CODEGEN_API_BASE_URL&quot;, API_ENDPOINT.rstrip(&quot;/&quot;))</file><file path="src/codegen/agents/README.md"># Codegen Agents - Python SDK

This module provides a Python client for interacting with the Codegen AI agents API.

## Installation

The Codegen Agent SDK is included as part of the Codegen package. Ensure you have the latest version installed:

```bash
pip install codegen
```

## Usage

### Basic Example

```python
from codegen.agents.agent import Agent

# Initialize the Agent with your organization ID and API token
agent = Agent(
    org_id=&quot;11&quot;,  # Your organization ID
    token=&quot;your_api_token_here&quot;,  # Your API authentication token
    base_url=&quot;https://codegen-sh-rest-api.modal.run&quot;,  # Optional - defaults to this URL
)

# Run an agent with a prompt
task = agent.run(prompt=&quot;Which github repos can you currently access?&quot;)

# Check the initial status
print(task.status)  # Returns the current status of the task (e.g., &quot;queued&quot;, &quot;in_progress&quot;, etc.)

# Refresh the task to get updated status
task.refresh()

# Check the updated status
print(task.status)

# Once task is complete, you can access the result
if task.status == &quot;completed&quot;:
    print(task.result)
```

### Agent Class

The `Agent` class is the main entry point for interacting with Codegen AI agents:

```python
Agent(token: str, org_id: Optional[int] = None, base_url: Optional[str] = CODEGEN_BASE_API_URL)
```

Parameters:

- `token` (required): Your API authentication token
- `org_id` (optional): Your organization ID. If not provided, defaults to environment variable `CODEGEN_ORG_ID` or &quot;1&quot;
- `base_url` (optional): API base URL. Defaults to &quot;https://codegen-sh-rest-api.modal.run&quot;

### Methods

#### run()

```python
run(prompt: str) -&gt; AgentTask
```

Runs an agent with the given prompt.

Parameters:

- `prompt` (required): The instruction for the agent to execute

Returns:

- An `AgentTask` object representing the running task

#### get_status()

```python
get_status() -&gt; Optional[Dict[str, Any]]
```

Gets the status of the current task.

Returns:

- A dictionary containing task status information (`id`, `status`, `result`), or `None` if no task has been run

### AgentTask Class

The `AgentTask` class represents a running or completed agent task:

#### Attributes

- `id`: The unique identifier for the task
- `org_id`: The organization ID
- `status`: Current status of the task (e.g., &quot;queued&quot;, &quot;in_progress&quot;, &quot;completed&quot;, &quot;failed&quot;)
- `result`: The task result (available when status is &quot;completed&quot;)

#### Methods

##### refresh()

```python
refresh() -&gt; None
```

Refreshes the task status from the API.

## Environment Variables

- `CODEGEN_ORG_ID`: Default organization ID (used if `org_id` is not provided)

## Error Handling

Handle potential API errors using standard try/except blocks:

```python
try:
    task = agent.run(prompt=&quot;Your prompt here&quot;)
    task.refresh()
    print(task.status)
except Exception as e:
    print(f&quot;Error: {e}&quot;)
```</file><file path="src/codegen/cli/api/client.py">import json
from typing import ClassVar, TypeVar

import requests
from pydantic import BaseModel
from rich import print as rprint

from codegen.cli.env.global_env import global_env
from codegen.cli.errors import InvalidTokenError, ServerError

InputT = TypeVar(&quot;InputT&quot;, bound=BaseModel)
OutputT = TypeVar(&quot;OutputT&quot;, bound=BaseModel)


class AuthContext(BaseModel):
    &quot;&quot;&quot;Authentication context model.&quot;&quot;&quot;

    status: str


class Identity(BaseModel):
    &quot;&quot;&quot;User identity model.&quot;&quot;&quot;

    auth_context: AuthContext


class RestAPI:
    &quot;&quot;&quot;Handles auth + validation with the codegen API.&quot;&quot;&quot;

    _session: ClassVar[requests.Session] = requests.Session()

    auth_token: str

    def __init__(self, auth_token: str):
        self.auth_token = auth_token

    def _get_headers(self) -&gt; dict[str, str]:
        &quot;&quot;&quot;Get headers with authentication token.&quot;&quot;&quot;
        return {&quot;Authorization&quot;: f&quot;Bearer {self.auth_token}&quot;}

    def _make_request(
        self,
        method: str,
        endpoint: str,
        input_data: InputT | None,
        output_model: type[OutputT],
    ) -&gt; OutputT:
        &quot;&quot;&quot;Make an API request with input validation and response handling.&quot;&quot;&quot;
        if global_env.DEBUG:
            rprint(f&quot;[purple]{method}[/purple] {endpoint}&quot;)
            if input_data:
                rprint(f&quot;{json.dumps(input_data.model_dump(), indent=4)}&quot;)

        try:
            headers = self._get_headers()

            json_data = input_data.model_dump() if input_data else None

            response = self._session.request(
                method,
                endpoint,
                json=json_data,
                headers=headers,
            )

            if response.status_code == 200:
                try:
                    return output_model.model_validate(response.json())
                except ValueError as e:
                    msg = f&quot;Invalid response format: {e}&quot;
                    raise ServerError(msg)
            elif response.status_code == 401:
                msg = &quot;Invalid or expired authentication token&quot;
                raise InvalidTokenError(msg)
            elif response.status_code == 500:
                msg = &quot;The server encountered an error while processing your request&quot;
                raise ServerError(msg)
            else:
                try:
                    error_json = response.json()
                    error_msg = error_json.get(&quot;detail&quot;, error_json)
                except Exception:
                    error_msg = response.text
                msg = f&quot;Error ({response.status_code}): {error_msg}&quot;
                raise ServerError(msg)

        except requests.RequestException as e:
            msg = f&quot;Network error: {e!s}&quot;
            raise ServerError(msg)</file><file path="src/codegen/cli/api/endpoints.py">import os

from codegen.cli.api.modal import MODAL_PREFIX

RUN_ENDPOINT = f&quot;https://{MODAL_PREFIX}--cli-run.modal.run&quot;
DOCS_ENDPOINT = f&quot;https://{MODAL_PREFIX}--cli-docs.modal.run&quot;
EXPERT_ENDPOINT = f&quot;https://{MODAL_PREFIX}--cli-ask-expert.modal.run&quot;
IDENTIFY_ENDPOINT = f&quot;https://{MODAL_PREFIX}--cli-identify.modal.run&quot;
CREATE_ENDPOINT = f&quot;https://{MODAL_PREFIX}--cli-create.modal.run&quot;
DEPLOY_ENDPOINT = f&quot;https://{MODAL_PREFIX}--cli-deploy.modal.run&quot;
LOOKUP_ENDPOINT = f&quot;https://{MODAL_PREFIX}--cli-lookup.modal.run&quot;
RUN_ON_PR_ENDPOINT = f&quot;https://{MODAL_PREFIX}--cli-run-on-pull-request.modal.run&quot;
PR_LOOKUP_ENDPOINT = f&quot;https://{MODAL_PREFIX}--cli-pr-lookup.modal.run&quot;
CODEGEN_SYSTEM_PROMPT_URL = &quot;https://gist.githubusercontent.com/jayhack/15681a2ceaccd726f19e6fdb3a44738b/raw/17c08054e3931b3b7fdf424458269c9e607541e8/codegen-system-prompt.txt&quot;
IMPROVE_ENDPOINT = f&quot;https://{MODAL_PREFIX}--cli-improve.modal.run&quot;
MCP_SERVER_ENDPOINT = f&quot;https://{MODAL_PREFIX}--codegen-mcp-server.modal.run/mcp&quot;

# API ENDPOINT
# Prefer explicit override via CODEGEN_API_BASE_URL; fallback to Modal-derived URL for current ENV
API_ENDPOINT = os.environ.get(&quot;CODEGEN_API_BASE_URL&quot;, f&quot;https://{MODAL_PREFIX}--rest-api.modal.run/&quot;)</file><file path="src/codegen/cli/api/modal.py">from codegen.cli.env.enums import Environment
from codegen.cli.env.global_env import global_env


def get_modal_workspace():
    match global_env.ENV:
        case Environment.PRODUCTION:
            return &quot;codegen-sh&quot;
        case Environment.STAGING:
            return &quot;codegen-sh-staging&quot;
        case Environment.DEVELOP:
            return &quot;codegen-sh-develop&quot;
        case _:
            msg = f&quot;Invalid environment: {global_env.ENV}&quot;
            raise ValueError(msg)


def get_modal_prefix():
    workspace = get_modal_workspace()
    if global_env.ENV == Environment.DEVELOP and global_env.MODAL_ENVIRONMENT:
        return f&quot;{workspace}-{global_env.MODAL_ENVIRONMENT}&quot;
    return workspace


MODAL_PREFIX = get_modal_prefix()</file><file path="src/codegen/cli/api/schemas.py">from enum import Enum
from typing import TypeVar

from pydantic import BaseModel
from pydantic.fields import Field

from codegen.cli.utils.schema import SafeBaseModel
from codegen.shared.enums.programming_language import ProgrammingLanguage

T = TypeVar(&quot;T&quot;)


###########################################################################
# RUN
###########################################################################


class CodemodRunType(str, Enum):
    &quot;&quot;&quot;Type of codemod run.&quot;&quot;&quot;

    DIFF = &quot;diff&quot;
    PR = &quot;pr&quot;


class RunCodemodInput(SafeBaseModel):
    class BaseRunCodemodInput(SafeBaseModel):
        repo_full_name: str
        codemod_id: int | None = None
        codemod_name: str | None = None
        codemod_source: str | None = None
        codemod_run_type: CodemodRunType = CodemodRunType.DIFF
        template_context: dict[str, str] = Field(default_factory=dict)

    input: BaseRunCodemodInput


class RunCodemodOutput(SafeBaseModel):
    success: bool = False
    web_link: str | None = None
    logs: str | None = None
    observation: str | None = None
    error: str | None = None


###########################################################################
# EXPERT
###########################################################################


class AskExpertInput(SafeBaseModel):
    class BaseAskExpertInput(SafeBaseModel):
        query: str

    input: BaseAskExpertInput


class AskExpertResponse(SafeBaseModel):
    response: str
    success: bool


###########################################################################
# DOCS
###########################################################################


class SerializedExample(SafeBaseModel):
    name: str | None = None
    description: str | None = None
    source: str
    language: ProgrammingLanguage
    docstring: str = &quot;&quot;


class DocsInput(SafeBaseModel):
    class BaseDocsInput(SafeBaseModel):
        repo_full_name: str

    docs_input: BaseDocsInput


class DocsResponse(SafeBaseModel):
    docs: dict[str, str]
    examples: list[SerializedExample]
    language: ProgrammingLanguage


###########################################################################
# CREATE
###########################################################################


class CreateInput(SafeBaseModel):
    class BaseCreateInput(SafeBaseModel):
        name: str
        query: str
        language: ProgrammingLanguage

    input: BaseCreateInput


class CreateResponse(SafeBaseModel):
    success: bool
    response: str
    code: str
    context: str


###########################################################################
# IDENTIFY
###########################################################################


class IdentifyResponse(SafeBaseModel):
    class AuthContext(SafeBaseModel):
        token_id: int
        expires_at: str
        status: str
        user_id: int

    class User(SafeBaseModel):
        github_user_id: str
        avatar_url: str
        auth_user_id: str
        created_at: str
        email: str
        is_contractor: str | None = None
        github_username: str
        full_name: str | None = None
        id: int
        last_updated_at: str | None = None

    auth_context: AuthContext
    user: User


###########################################################################
# DEPLOY
###########################################################################


class DeployInput(BaseModel):
    &quot;&quot;&quot;Input for deploying a codemod.&quot;&quot;&quot;

    class BaseDeployInput(BaseModel):
        codemod_name: str = Field(..., description=&quot;Name of the codemod to deploy&quot;)
        codemod_source: str = Field(..., description=&quot;Source code of the codemod&quot;)
        repo_full_name: str = Field(..., description=&quot;Full name of the repository&quot;)
        lint_mode: bool = Field(default=False, description=&quot;Whether this is a PR check/lint mode function&quot;)
        lint_user_whitelist: list[str] = Field(default_factory=list, description=&quot;List of GitHub usernames to notify&quot;)
        message: str | None = Field(default=None, description=&quot;Optional message describing the codemod being deployed.&quot;)
        arguments_schema: dict | None = Field(default=None, description=&quot;Schema of the arguments parameter&quot;)

    input: BaseDeployInput = Field(..., description=&quot;Input data for deployment&quot;)


class DeployResponse(BaseModel):
    &quot;&quot;&quot;Response from deploying a codemod.&quot;&quot;&quot;

    success: bool = Field(..., description=&quot;Whether the deployment was successful&quot;)
    new: bool = Field(..., description=&quot;Whether the codemod is newly created&quot;)
    codemod_id: int = Field(..., description=&quot;ID of the deployed codemod&quot;)
    version_id: int = Field(..., description=&quot;Version ID of the deployed codemod&quot;)
    url: str = Field(..., description=&quot;URL of the deployed codemod&quot;)


###########################################################################
# LOOKUP
###########################################################################


class LookupInput(BaseModel):
    &quot;&quot;&quot;Input for looking up a codemod.&quot;&quot;&quot;

    class BaseLookupInput(BaseModel):
        codemod_name: str = Field(..., description=&quot;Name of the codemod to look up&quot;)
        repo_full_name: str = Field(..., description=&quot;Full name of the repository&quot;)

    input: BaseLookupInput = Field(..., description=&quot;Input data for lookup&quot;)


class LookupOutput(BaseModel):
    &quot;&quot;&quot;Response from looking up a codemod.&quot;&quot;&quot;

    codemod_id: int = Field(..., description=&quot;ID of the codemod&quot;)
    version_id: int = Field(..., description=&quot;Version ID of the codemod&quot;)


###########################################################################
# PR LOOKUP
###########################################################################


class PRSchema(BaseModel):
    url: str
    title: str
    body: str
    github_pr_number: int
    codegen_pr_id: int


class PRLookupInput(BaseModel):
    class BasePRLookupInput(BaseModel):
        repo_full_name: str
        github_pr_number: int

    input: BasePRLookupInput


class PRLookupResponse(BaseModel):
    pr: PRSchema


###########################################################################
# TEST WEBHOOK
###########################################################################


class RunOnPRInput(BaseModel):
    &quot;&quot;&quot;Input for testing a webhook against a PR.&quot;&quot;&quot;

    class BaseRunOnPRInput(BaseModel):
        codemod_name: str = Field(..., description=&quot;Name of the codemod to test&quot;)
        repo_full_name: str = Field(..., description=&quot;Full name of the repository&quot;)
        github_pr_number: int = Field(..., description=&quot;GitHub PR number to test against&quot;)
        language: str | None = Field(..., description=&quot;Language of the codemod&quot;)

    input: BaseRunOnPRInput = Field(..., description=&quot;Input data for webhook test&quot;)


class RunOnPRResponse(BaseModel):
    &quot;&quot;&quot;Response from testing a webhook.&quot;&quot;&quot;

    codemod_id: int = Field(..., description=&quot;ID of the codemod&quot;)
    codemod_run_id: int = Field(..., description=&quot;ID of the codemod run&quot;)
    web_url: str = Field(..., description=&quot;URL to view the test results&quot;)


###########################################################################
# IMPROVE
###########################################################################


class ImproveCodemodInput(BaseModel):
    class BaseImproveCodemodInput(BaseModel):
        codemod: str = Field(..., description=&quot;Source code of the codemod to improve&quot;)
        task: str = Field(..., description=&quot;Task to which the codemod should implement to solve&quot;)
        concerns: list[str] = Field(..., description=&quot;A list of issues that were discovered with the current codemod that need to be considered in the next iteration&quot;)
        context: dict[str, str] = Field(..., description=&quot;Additional context for the codemod this can be a list of files that are related, additional information about the task, etc.&quot;)
        language: ProgrammingLanguage = Field(..., description=&quot;Language of the codemod&quot;)

    input: BaseImproveCodemodInput = Field(..., description=&quot;Input data for improvement&quot;)


class ImproveCodemodResponse(BaseModel):
    success: bool = Field(..., description=&quot;Whether the improvement was successful&quot;)
    codemod_source: str = Field(..., description=&quot;Source code of the improved codemod&quot;)</file><file path="src/codegen/cli/api/webapp_routes.py"># Urls linking to the webapp
from codegen.cli.utils.url import generate_webapp_url

USER_SECRETS_ROUTE = generate_webapp_url(path=&quot;cli-token&quot;)</file><file path="src/codegen/cli/auth/constants.py">from pathlib import Path

# Base directories
CONFIG_DIR = Path(&quot;~/.codegen&quot;).expanduser()
CODEGEN_DIR = Path(&quot;.codegen&quot;)
PROMPTS_DIR = CODEGEN_DIR / &quot;prompts&quot;

# Subdirectories
DOCS_DIR = CODEGEN_DIR / &quot;docs&quot;
EXAMPLES_DIR = CODEGEN_DIR / &quot;examples&quot;

# Files
AUTH_FILE = CONFIG_DIR / &quot;auth.json&quot;</file><file path="src/codegen/cli/auth/decorators.py">import functools
import inspect
from collections.abc import Callable

import rich
import typer

from codegen.cli.auth.login import login_routine
from codegen.cli.auth.session import CodegenSession
from codegen.cli.auth.token_manager import TokenManager, get_current_token
from codegen.cli.errors import AuthError
from codegen.cli.rich.pretty_print import pretty_print_error


def requires_auth(f: Callable) -&gt; Callable:
    &quot;&quot;&quot;Decorator that ensures a user is authenticated and injects a CodegenSession.&quot;&quot;&quot;

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        session = CodegenSession.from_active_session()

        # Check for valid session
        if session is None:
            pretty_print_error(&quot;There is currently no active session.\nPlease run &apos;codegen init&apos; to initialize the project.&quot;)
            raise typer.Abort()

        if (token := get_current_token()) is None:
            rich.print(&quot;[yellow]Not authenticated. Let&apos;s get you logged in first![/yellow]\n&quot;)
            login_routine()
        else:
            try:
                token_manager = TokenManager()
                token_manager.authenticate_token(token)
            except AuthError:
                rich.print(&quot;[yellow]Authentication token is invalid or expired. Let&apos;s get you logged in again![/yellow]\n&quot;)
                login_routine()

        return f(*args, session=session, **kwargs)

    # Remove the session parameter from the wrapper&apos;s signature so Typer doesn&apos;t see it
    sig = inspect.signature(f)
    new_params = [param for name, param in sig.parameters.items() if name != &quot;session&quot;]
    new_sig = sig.replace(parameters=new_params)
    wrapper.__signature__ = new_sig  # type: ignore[attr-defined]

    return wrapper</file><file path="src/codegen/cli/auth/login.py">import webbrowser

import rich
import typer

from codegen.cli.api.webapp_routes import USER_SECRETS_ROUTE
from codegen.cli.auth.token_manager import TokenManager, get_cached_organizations, set_default_organization
from codegen.cli.env.global_env import global_env
from codegen.cli.errors import AuthError
from codegen.cli.utils.simple_selector import simple_org_selector


def login_routine(token: str | None = None) -&gt; str:
    &quot;&quot;&quot;Guide user through login flow and return authenticated session.

    Args:
        token: Codegen user access token associated with github account

    Returns:
        str: The authenticated token

    Raises:
        typer.Exit: If login fails

    &quot;&quot;&quot;
    # Display header like in the main TUI
    print(&quot;\033[38;2;82;19;217m&quot; + &quot;/&quot; * 20 + &quot; Codegen\033[0m&quot;)
    print()

    # Try environment variable first
    token = token or global_env.CODEGEN_USER_ACCESS_TOKEN

    # If no token provided, guide user through browser flow
    if not token:
        webbrowser.open_new(USER_SECRETS_ROUTE)
        token = typer.prompt(f&quot;Enter your token from {USER_SECRETS_ROUTE}&quot;, hide_input=False)

    if not token:
        rich.print(&quot;[red]Error:[/red] Token must be provided via CODEGEN_USER_ACCESS_TOKEN environment variable or manual input&quot;)
        raise typer.Exit(1)

    # Validate and store token
    try:
        token_manager = TokenManager()
        token_manager.authenticate_token(token)
        rich.print(f&quot;[dim]âœ“ Stored token and profile to:[/dim] [#ffca85]{token_manager.token_file}[/#ffca85]&quot;)

        # Show organization selector if multiple organizations available
        organizations = get_cached_organizations()
        if organizations and len(organizations) &gt; 1:
            rich.print(&quot;\n[blue]Multiple organizations found. Please select your default:[/blue]&quot;)
            selected_org = simple_org_selector(organizations, title=&quot;ðŸ¢ Select Default Organization&quot;)

            if selected_org:
                org_id = selected_org.get(&quot;id&quot;)
                org_name = selected_org.get(&quot;name&quot;)
                try:
                    set_default_organization(org_id, org_name)
                    rich.print(f&quot;[green]âœ“ Set default organization:[/green] {org_name}&quot;)
                except Exception as e:
                    rich.print(f&quot;[yellow]Warning: Could not set default organization: {e}[/yellow]&quot;)
                    rich.print(&quot;[yellow]You can set it later with &apos;codegen profile&apos;[/yellow]&quot;)
            else:
                rich.print(&quot;[yellow]No organization selected. You can set it later with &apos;codegen profile&apos;[/yellow]&quot;)
        elif organizations and len(organizations) == 1:
            # Single organization - set it automatically
            org = organizations[0]
            org_id = org.get(&quot;id&quot;)
            org_name = org.get(&quot;name&quot;)
            try:
                set_default_organization(org_id, org_name)
                rich.print(f&quot;[green]âœ“ Set default organization:[/green] {org_name}&quot;)
            except Exception as e:
                rich.print(f&quot;[yellow]Warning: Could not set default organization: {e}[/yellow]&quot;)

        # After successful login, launch the TUI
        print()  # Add some space
        from codegen.cli.tui.app import run_tui

        run_tui()

        return token
    except AuthError as e:
        rich.print(f&quot;[red]Error:[/red] {e!s}&quot;)
        raise typer.Exit(1)</file><file path="src/codegen/cli/auth/session.ipynb">{
 &quot;cells&quot;: [
  {
   &quot;cell_type&quot;: &quot;code&quot;,
   &quot;execution_count&quot;: null,
   &quot;metadata&quot;: {},
   &quot;outputs&quot;: [],
   &quot;source&quot;: [
    &quot;from pathlib import Path\n&quot;,
    &quot;from codegen.cli.auth.session import CodegenSession\n&quot;,
    &quot;\n&quot;,
    &quot;\n&quot;,
    &quot;# Create a session with the current directory as repo_path\n&quot;,
    &quot;session = CodegenSession(repo_path=Path(\&quot;.\&quot;))\n&quot;,
    &quot;print(f\&quot;Session: {session}\&quot;)\n&quot;,
    &quot;print(f\&quot;Repo path: {session.repo_path}\&quot;)\n&quot;,
    &quot;print(f\&quot;Config: {session.config}\&quot;)\n&quot;,
    &quot;print(f\&quot;Existing session: {session.existing}\&quot;)&quot;
   ]
  }
 ],
 &quot;metadata&quot;: {
  &quot;kernelspec&quot;: {
   &quot;display_name&quot;: &quot;.venv&quot;,
   &quot;language&quot;: &quot;python&quot;,
   &quot;name&quot;: &quot;python3&quot;
  },
  &quot;language_info&quot;: {
   &quot;codemirror_mode&quot;: {
    &quot;name&quot;: &quot;ipython&quot;,
    &quot;version&quot;: 3
   },
   &quot;file_extension&quot;: &quot;.py&quot;,
   &quot;mimetype&quot;: &quot;text/x-python&quot;,
   &quot;name&quot;: &quot;python&quot;,
   &quot;nbconvert_exporter&quot;: &quot;python&quot;,
   &quot;pygments_lexer&quot;: &quot;ipython3&quot;,
   &quot;version&quot;: &quot;3.13.0&quot;
  }
 },
 &quot;nbformat&quot;: 4,
 &quot;nbformat_minor&quot;: 2
}</file><file path="src/codegen/cli/auth/session.py">from pathlib import Path

import rich
import typer
from github import BadCredentialsException
from github.MainClass import Github

from codegen.cli.rich.codeblocks import format_command
from codegen.configs.constants import CODEGEN_DIR_NAME, ENV_FILENAME
from codegen.configs.session_manager import session_manager
from codegen.configs.user_config import UserConfig
from codegen.git.repo_operator.local_git_repo import LocalGitRepo


class CodegenSession:
    &quot;&quot;&quot;Represents an authenticated codegen session with user and repository context&quot;&quot;&quot;

    repo_path: Path
    local_git: LocalGitRepo
    codegen_dir: Path
    config: UserConfig
    existing: bool

    def __init__(self, repo_path: Path, git_token: str | None = None) -&gt; None:
        if not repo_path.exists():
            rich.print(f&quot;\n[bold red]Error:[/bold red] Path to git repo does not exist at {repo_path}&quot;)
            raise typer.Abort()

        # Check if it&apos;s a valid git repository
        try:
            LocalGitRepo(repo_path=repo_path)
        except Exception:
            rich.print(f&quot;\n[bold red]Error:[/bold red] Path {repo_path} is not a valid git repository&quot;)
            raise typer.Abort()

        self.repo_path = repo_path
        self.local_git = LocalGitRepo(repo_path=repo_path)
        self.codegen_dir = repo_path / CODEGEN_DIR_NAME
        self.config = UserConfig(env_filepath=repo_path / ENV_FILENAME)
        self.config.secrets.github_token = git_token or self.config.secrets.github_token
        self.existing = session_manager.get_session(repo_path) is not None

        self._initialize()
        session_manager.set_active_session(repo_path)

    @classmethod
    def from_active_session(cls) -&gt; &quot;CodegenSession | None&quot;:
        active_session = session_manager.get_active_session()
        if not active_session:
            return None

        return cls(active_session)

    def _initialize(self) -&gt; None:
        &quot;&quot;&quot;Initialize the codegen session&quot;&quot;&quot;
        self._validate()

        self.config.repository.path = self.config.repository.path or str(self.local_git.repo_path)
        self.config.repository.owner = self.config.repository.owner or self.local_git.owner
        self.config.repository.user_name = self.config.repository.user_name or self.local_git.user_name
        self.config.repository.user_email = self.config.repository.user_email or self.local_git.user_email
        self.config.repository.language = self.config.repository.language or self.local_git.get_language(access_token=self.config.secrets.github_token).upper()
        self.config.save()

    def _validate(self) -&gt; None:
        &quot;&quot;&quot;Validates that the session configuration is correct, otherwise raises an error&quot;&quot;&quot;
        if not self.codegen_dir.exists():
            self.codegen_dir.mkdir(parents=True, exist_ok=True)

        git_token = self.config.secrets.github_token
        if git_token is None:
            rich.print(&quot;\n[bold yellow]Warning:[/bold yellow] GitHub token not found&quot;)
            rich.print(&quot;To enable full functionality, please set your GitHub token:&quot;)
            rich.print(format_command(&quot;export GITHUB_TOKEN=&lt;your-token&gt;&quot;))
            rich.print(&quot;Or pass in as a parameter:&quot;)
            rich.print(format_command(&quot;codegen init --token &lt;your-token&gt;&quot;))

        if self.local_git.origin_remote is None:
            rich.print(&quot;\n[bold yellow]Warning:[/bold yellow] No remote found for repository&quot;)
            rich.print(&quot;[white]To enable full functionality, please add a remote to the repository[/white]&quot;)
            rich.print(&quot;\n[dim]To add a remote to the repository:[/dim]&quot;)
            rich.print(format_command(&quot;git remote add origin &lt;your-repo-url&gt;&quot;))

        try:
            if git_token is not None and self.local_git.full_name is not None:
                Github(login_or_token=git_token).get_repo(self.local_git.full_name)
        except BadCredentialsException:
            rich.print(format_command(f&quot;\n[bold red]Error:[/bold red] Invalid GitHub token={git_token} for repo={self.local_git.full_name}&quot;))
            rich.print(&quot;[white]Please provide a valid GitHub token for this repository.[/white]&quot;)
            raise typer.Abort()

    def __str__(self) -&gt; str:
        return f&quot;CodegenSession(user={self.config.repository.user_name}, repo={self.config.repository.name})&quot;</file><file path="src/codegen/cli/auth/token_manager.ipynb">{
 &quot;cells&quot;: [
  {
   &quot;cell_type&quot;: &quot;code&quot;,
   &quot;execution_count&quot;: null,
   &quot;metadata&quot;: {},
   &quot;outputs&quot;: [],
   &quot;source&quot;: [
    &quot;from codegen.cli.auth.token_manager import TokenManager\n&quot;,
    &quot;\n&quot;,
    &quot;\n&quot;,
    &quot;token_manager = TokenManager()\n&quot;,
    &quot;print(token_manager.get_token())&quot;
   ]
  }
 ],
 &quot;metadata&quot;: {
  &quot;kernelspec&quot;: {
   &quot;display_name&quot;: &quot;.venv&quot;,
   &quot;language&quot;: &quot;python&quot;,
   &quot;name&quot;: &quot;python3&quot;
  },
  &quot;language_info&quot;: {
   &quot;codemirror_mode&quot;: {
    &quot;name&quot;: &quot;ipython&quot;,
    &quot;version&quot;: 3
   },
   &quot;file_extension&quot;: &quot;.py&quot;,
   &quot;mimetype&quot;: &quot;text/x-python&quot;,
   &quot;name&quot;: &quot;python&quot;,
   &quot;nbconvert_exporter&quot;: &quot;python&quot;,
   &quot;pygments_lexer&quot;: &quot;ipython3&quot;,
   &quot;version&quot;: &quot;3.13.0&quot;
  }
 },
 &quot;nbformat&quot;: 4,
 &quot;nbformat_minor&quot;: 2
}</file><file path="src/codegen/cli/auth/token_manager.py">import json
import os
from pathlib import Path

from codegen.cli.auth.constants import AUTH_FILE, CONFIG_DIR

# Simple cache to avoid repeated file I/O
_token_cache = None
_cache_mtime = None


class TokenManager:
    # Simple token manager to store and retrieve tokens.
    # This manager checks if the token is expired before retrieval.
    # TODO: add support for refreshing token and re authorization via supabase oauth
    def __init__(self):
        self.config_dir = CONFIG_DIR
        self.token_file = AUTH_FILE
        self._ensure_config_dir()

    def _ensure_config_dir(self):
        &quot;&quot;&quot;Create config directory if it doesn&apos;t exist.&quot;&quot;&quot;
        if not os.path.exists(self.config_dir):
            Path(self.config_dir).mkdir(parents=True, exist_ok=True)

    def authenticate_token(self, token: str) -&gt; None:
        &quot;&quot;&quot;Store the token locally and fetch organization info.&quot;&quot;&quot;
        self.save_token_with_org_info(token)

    def save_token_with_org_info(self, token: str) -&gt; None:
        &quot;&quot;&quot;Save api token to disk along with organization info.&quot;&quot;&quot;
        global _token_cache, _cache_mtime

        # First fetch organization info using the token
        try:
            import requests

            from codegen.cli.api.endpoints import API_ENDPOINT

            headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}

            # Test token by getting user info
            user_response = requests.get(f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/users/me&quot;, headers=headers, timeout=10)
            user_response.raise_for_status()
            user_data = user_response.json()

            # Get organizations
            org_response = requests.get(f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations&quot;, headers=headers, timeout=10)
            org_response.raise_for_status()
            org_data = org_response.json()

            # Prepare auth data with org info
            auth_data = {
                &quot;token&quot;: token,
                &quot;user&quot;: {&quot;id&quot;: user_data.get(&quot;id&quot;), &quot;email&quot;: user_data.get(&quot;email&quot;), &quot;full_name&quot;: user_data.get(&quot;full_name&quot;), &quot;github_username&quot;: user_data.get(&quot;github_username&quot;)},
            }

            # Add organization info if available
            orgs = org_data.get(&quot;items&quot;, [])
            if orgs and len(orgs) &gt; 0:
                # Store ALL organizations in cache for local resolution
                all_orgs = [{&quot;id&quot;: org.get(&quot;id&quot;), &quot;name&quot;: org.get(&quot;name&quot;)} for org in orgs]
                primary_org = orgs[0]  # Use first org as primary/default
                auth_data[&quot;organization&quot;] = {&quot;id&quot;: primary_org.get(&quot;id&quot;), &quot;name&quot;: primary_org.get(&quot;name&quot;), &quot;all_orgs&quot;: all_orgs}
                auth_data[&quot;organizations_cache&quot;] = all_orgs  # Separate cache for easy access

        except requests.RequestException as e:
            # If we can&apos;t fetch org info, still save the token but without org data
            print(f&quot;Warning: Could not fetch organization info: {e}&quot;)
            auth_data = {&quot;token&quot;: token}
        except Exception as e:
            print(f&quot;Warning: Error fetching user/org info: {e}&quot;)
            auth_data = {&quot;token&quot;: token}

        # Save to file
        try:
            with open(self.token_file, &quot;w&quot;) as f:
                json.dump(auth_data, f, indent=2)

            # Secure the file permissions (read/write for owner only)
            os.chmod(self.token_file, 0o600)

            # Invalidate cache
            _token_cache = None
            _cache_mtime = None
        except Exception as e:
            print(f&quot;Error saving token: {e!s}&quot;)
            raise

    def save_token(self, token: str) -&gt; None:
        &quot;&quot;&quot;Save api token to disk (legacy method - just saves token).&quot;&quot;&quot;
        global _token_cache, _cache_mtime
        try:
            with open(self.token_file, &quot;w&quot;) as f:
                json.dump({&quot;token&quot;: token}, f)

            # Secure the file permissions (read/write for owner only)
            os.chmod(self.token_file, 0o600)

            # Invalidate cache
            _token_cache = None
            _cache_mtime = None
        except Exception as e:
            print(f&quot;Error saving token: {e!s}&quot;)
            raise

    def get_token(self) -&gt; str | None:
        &quot;&quot;&quot;Retrieve token from disk if it exists and is valid.&quot;&quot;&quot;
        try:
            if not os.access(self.config_dir, os.R_OK):
                return None

            if not os.path.exists(self.token_file):
                return None

            with open(self.token_file) as f:
                data = json.load(f)
                token = data.get(&quot;token&quot;)
                if not token:
                    return None

                return token

        except (KeyError, OSError) as e:
            print(e)
            return None

    def clear_token(self) -&gt; None:
        &quot;&quot;&quot;Remove stored token.&quot;&quot;&quot;
        global _token_cache, _cache_mtime
        if os.path.exists(self.token_file):
            os.remove(self.token_file)
            # Invalidate cache
            _token_cache = None
            _cache_mtime = None

    def get_auth_data(self) -&gt; dict | None:
        &quot;&quot;&quot;Retrieve complete auth data from disk.&quot;&quot;&quot;
        try:
            if not os.access(self.config_dir, os.R_OK):
                return None

            if not os.path.exists(self.token_file):
                return None

            with open(self.token_file) as f:
                return json.load(f)
        except Exception:
            return None

    def get_org_id(self) -&gt; int | None:
        &quot;&quot;&quot;Get the stored organization ID.&quot;&quot;&quot;
        auth_data = self.get_auth_data()
        if auth_data and &quot;organization&quot; in auth_data:
            org_id = auth_data[&quot;organization&quot;].get(&quot;id&quot;)
            if org_id:
                try:
                    return int(org_id)
                except (ValueError, TypeError):
                    return None
        return None

    def get_org_name(self) -&gt; str | None:
        &quot;&quot;&quot;Get the stored organization name.&quot;&quot;&quot;
        auth_data = self.get_auth_data()
        if auth_data and &quot;organization&quot; in auth_data:
            return auth_data[&quot;organization&quot;].get(&quot;name&quot;)
        return None

    def get_user_info(self) -&gt; dict | None:
        &quot;&quot;&quot;Get the stored user info.&quot;&quot;&quot;
        auth_data = self.get_auth_data()
        if auth_data and &quot;user&quot; in auth_data:
            return auth_data[&quot;user&quot;]
        return None

    def get_cached_organizations(self) -&gt; list[dict] | None:
        &quot;&quot;&quot;Get all cached organizations.

        Returns:
            List of organization dictionaries with &apos;id&apos; and &apos;name&apos; keys, or None if no cache.
        &quot;&quot;&quot;
        auth_data = self.get_auth_data()
        if auth_data and &quot;organizations_cache&quot; in auth_data:
            return auth_data[&quot;organizations_cache&quot;]
        # Fallback to legacy format
        if auth_data and &quot;organization&quot; in auth_data and &quot;all_orgs&quot; in auth_data[&quot;organization&quot;]:
            return auth_data[&quot;organization&quot;][&quot;all_orgs&quot;]
        return None

    def is_org_id_in_cache(self, org_id: int) -&gt; bool:
        &quot;&quot;&quot;Check if an organization ID exists in the local cache.

        Args:
            org_id: The organization ID to check

        Returns:
            True if the organization ID is found in cache, False otherwise.
        &quot;&quot;&quot;
        cached_orgs = self.get_cached_organizations()
        if not cached_orgs:
            return False

        return any(org.get(&quot;id&quot;) == org_id for org in cached_orgs)

    def get_org_name_from_cache(self, org_id: int) -&gt; str | None:
        &quot;&quot;&quot;Get organization name from cache by ID.

        Args:
            org_id: The organization ID to look up

        Returns:
            Organization name if found in cache, None otherwise.
        &quot;&quot;&quot;
        cached_orgs = self.get_cached_organizations()
        if not cached_orgs:
            return None

        for org in cached_orgs:
            if org.get(&quot;id&quot;) == org_id:
                return org.get(&quot;name&quot;)
        return None

    def set_default_organization(self, org_id: int, org_name: str) -&gt; None:
        &quot;&quot;&quot;Set the default organization in auth.json.

        Args:
            org_id: The organization ID to set as default
            org_name: The organization name
        &quot;&quot;&quot;
        auth_data = self.get_auth_data()
        if not auth_data:
            msg = &quot;No authentication data found. Please run &apos;codegen login&apos; first.&quot;
            raise ValueError(msg)

        # Verify the org exists in cache
        if not self.is_org_id_in_cache(org_id):
            msg = f&quot;Organization {org_id} not found in cache. Please run &apos;codegen login&apos; to refresh.&quot;
            raise ValueError(msg)

        # Update the organization info
        auth_data[&quot;organization&quot;] = {&quot;id&quot;: org_id, &quot;name&quot;: org_name, &quot;all_orgs&quot;: auth_data.get(&quot;organization&quot;, {}).get(&quot;all_orgs&quot;, [])}

        # Save to file
        try:
            import json

            with open(self.token_file, &quot;w&quot;) as f:
                json.dump(auth_data, f, indent=2)

            # Secure the file permissions (read/write for owner only)
            os.chmod(self.token_file, 0o600)

            # Invalidate cache
            global _token_cache, _cache_mtime
            _token_cache = None
            _cache_mtime = None
        except Exception as e:
            msg = f&quot;Error saving default organization: {e}&quot;
            raise ValueError(msg)


def get_current_token() -&gt; str | None:
    &quot;&quot;&quot;Get the current authentication token if one exists.

    This is a helper function that creates a TokenManager instance and retrieves
    the stored token. The token is validated before being returned.
    Uses a simple cache to avoid repeated file I/O.

    Returns:
        Optional[str]: The current valid api token if one exists.
                      Returns None if no token exists.

    &quot;&quot;&quot;
    global _token_cache, _cache_mtime

    try:
        # Check if token file exists
        if not os.path.exists(AUTH_FILE):
            return None

        # Get file modification time
        current_mtime = os.path.getmtime(AUTH_FILE)

        # Use cache if file hasn&apos;t changed
        if _token_cache is not None and _cache_mtime == current_mtime:
            return _token_cache

        # Read token from file
        token_manager = TokenManager()
        token = token_manager.get_token()

        # Update cache
        _token_cache = token
        _cache_mtime = current_mtime

        return token
    except Exception:
        # Fall back to uncached version on any error
        token_manager = TokenManager()
        return token_manager.get_token()


def get_current_org_id() -&gt; int | None:
    &quot;&quot;&quot;Get the stored organization ID if available.

    Returns:
        Optional[int]: The organization ID if stored, None otherwise.
    &quot;&quot;&quot;
    token_manager = TokenManager()
    return token_manager.get_org_id()


def get_current_org_name() -&gt; str | None:
    &quot;&quot;&quot;Get the stored organization name if available.

    Returns:
        Optional[str]: The organization name if stored, None otherwise.
    &quot;&quot;&quot;
    token_manager = TokenManager()
    return token_manager.get_org_name()


def get_cached_organizations() -&gt; list[dict] | None:
    &quot;&quot;&quot;Get all cached organizations.

    Returns:
        List of organization dictionaries with &apos;id&apos; and &apos;name&apos; keys, or None if no cache.
    &quot;&quot;&quot;
    token_manager = TokenManager()
    return token_manager.get_cached_organizations()


def is_org_id_cached(org_id: int) -&gt; bool:
    &quot;&quot;&quot;Check if an organization ID exists in the local cache.

    Args:
        org_id: The organization ID to check

    Returns:
        True if the organization ID is found in cache, False otherwise.
    &quot;&quot;&quot;
    token_manager = TokenManager()
    return token_manager.is_org_id_in_cache(org_id)


def get_org_name_from_cache(org_id: int) -&gt; str | None:
    &quot;&quot;&quot;Get organization name from cache by ID.

    Args:
        org_id: The organization ID to look up

    Returns:
        Organization name if found in cache, None otherwise.
    &quot;&quot;&quot;
    token_manager = TokenManager()
    return token_manager.get_org_name_from_cache(org_id)


def get_current_user_info() -&gt; dict | None:
    &quot;&quot;&quot;Get the stored user info if available.

    Returns:
        Optional[dict]: The user info if stored, None otherwise.
    &quot;&quot;&quot;
    token_manager = TokenManager()
    return token_manager.get_user_info()


# Repository caching functions (similar to organization caching)


def get_cached_repositories() -&gt; list[dict] | None:
    &quot;&quot;&quot;Get all cached repositories.

    Returns:
        List of repository dictionaries with &apos;id&apos; and &apos;name&apos; keys, or None if no cache.
    &quot;&quot;&quot;
    token_manager = TokenManager()
    auth_data = token_manager.get_auth_data()
    if auth_data and &quot;repositories_cache&quot; in auth_data:
        return auth_data[&quot;repositories_cache&quot;]
    return None


def cache_repositories(repositories: list[dict]) -&gt; None:
    &quot;&quot;&quot;Cache repositories to local storage.

    Args:
        repositories: List of repository dictionaries to cache
    &quot;&quot;&quot;
    token_manager = TokenManager()
    auth_data = token_manager.get_auth_data()
    if auth_data:
        auth_data[&quot;repositories_cache&quot;] = repositories
        # Save back to file
        try:
            import json

            with open(token_manager.token_file, &quot;w&quot;) as f:
                json.dump(auth_data, f, indent=2)
        except Exception:
            pass  # Fail silently


def is_repo_id_cached(repo_id: int) -&gt; bool:
    &quot;&quot;&quot;Check if a repository ID exists in the local cache.

    Args:
        repo_id: The repository ID to check

    Returns:
        True if the repository ID is found in cache, False otherwise.
    &quot;&quot;&quot;
    cached_repos = get_cached_repositories()
    if not cached_repos:
        return False

    return any(repo.get(&quot;id&quot;) == repo_id for repo in cached_repos)


def get_repo_name_from_cache(repo_id: int) -&gt; str | None:
    &quot;&quot;&quot;Get repository name from cache by ID.

    Args:
        repo_id: The repository ID to look up

    Returns:
        Repository name if found in cache, None otherwise.
    &quot;&quot;&quot;
    cached_repos = get_cached_repositories()
    if not cached_repos:
        return None

    for repo in cached_repos:
        if repo.get(&quot;id&quot;) == repo_id:
            return repo.get(&quot;name&quot;)

    return None


def get_current_repo_name() -&gt; str | None:
    &quot;&quot;&quot;Get the current repository name from environment or cache.&quot;&quot;&quot;
    from codegen.cli.utils.repo import get_current_repo_id

    repo_id = get_current_repo_id()
    if repo_id:
        return get_repo_name_from_cache(repo_id)
    return None


def set_default_organization(org_id: int, org_name: str) -&gt; None:
    &quot;&quot;&quot;Set the default organization in auth.json.

    Args:
        org_id: The organization ID to set as default
        org_name: The organization name
    &quot;&quot;&quot;
    token_manager = TokenManager()
    return token_manager.set_default_organization(org_id, org_name)</file><file path="src/codegen/cli/claude/__init__.py">&quot;&quot;&quot;Claude Code proxy server and utilities.&quot;&quot;&quot;</file><file path="src/codegen/cli/commands/agent/__init__.py">&quot;&quot;&quot;Agent command module.&quot;&quot;&quot;</file><file path="src/codegen/cli/commands/agent/main.py">&quot;&quot;&quot;Agent command for creating remote agent runs.&quot;&quot;&quot;

import json
from pathlib import Path

import requests
import typer
from rich import box
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax

from codegen.cli.api.endpoints import API_ENDPOINT
from codegen.cli.auth.token_manager import get_current_org_name, get_current_token
from codegen.cli.rich.spinners import create_spinner
from codegen.cli.utils.org import resolve_org_id
from codegen.git.repo_operator.local_git_repo import LocalGitRepo
from codegen.git.repo_operator.repo_operator import RepoOperator
from codegen.git.schemas.repo_config import RepoConfig

console = Console()

# Create the agent app
agent_app = typer.Typer(help=&quot;Create and manage individual agent runs&quot;)


@agent_app.command()
def create(
    prompt: str = typer.Option(..., &quot;--prompt&quot;, &quot;-p&quot;, help=&quot;The prompt to send to the agent&quot;),
    org_id: int | None = typer.Option(None, help=&quot;Organization ID (defaults to CODEGEN_ORG_ID/REPOSITORY_ORG_ID or auto-detect)&quot;),
    model: str | None = typer.Option(None, help=&quot;Model to use for this agent run (optional)&quot;),
    repo_id: int | None = typer.Option(None, help=&quot;Repository ID to use for this agent run (optional)&quot;),
):
    &quot;&quot;&quot;Create a new agent run with the given prompt.&quot;&quot;&quot;
    # Get the current token
    token = get_current_token()
    if not token:
        console.print(&quot;[red]Error:[/red] Not authenticated. Please run &apos;codegen login&apos; first.&quot;)
        raise typer.Exit(1)

    try:
        # Resolve org id
        resolved_org_id = resolve_org_id(org_id)
        if resolved_org_id is None:
            console.print(&quot;[red]Error:[/red] Organization ID not provided. Pass --org-id, set CODEGEN_ORG_ID, or REPOSITORY_ORG_ID.&quot;)
            raise typer.Exit(1)

        # Prepare the request payload
        payload = {
            &quot;prompt&quot;: prompt,
        }

        if model:
            payload[&quot;model&quot;] = model
        if repo_id:
            payload[&quot;repo_id&quot;] = repo_id

        # Make API request to create agent run with spinner
        spinner = create_spinner(&quot;Creating agent run...&quot;)
        spinner.start()

        try:
            headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}
            url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{resolved_org_id}/agent/run&quot;
            response = requests.post(url, headers=headers, json=payload)
            response.raise_for_status()
            agent_run_data = response.json()
        finally:
            spinner.stop()

        # Extract agent run information
        run_id = agent_run_data.get(&quot;id&quot;, &quot;Unknown&quot;)
        status = agent_run_data.get(&quot;status&quot;, &quot;Unknown&quot;)
        web_url = agent_run_data.get(&quot;web_url&quot;, &quot;&quot;)
        created_at = agent_run_data.get(&quot;created_at&quot;, &quot;&quot;)

        # Format created date
        if created_at:
            try:
                from datetime import datetime

                dt = datetime.fromisoformat(created_at.replace(&quot;Z&quot;, &quot;+00:00&quot;))
                created_display = dt.strftime(&quot;%B %d, %Y at %H:%M&quot;)
            except (ValueError, TypeError):
                created_display = created_at
        else:
            created_display = &quot;Unknown&quot;

        # Status with emoji
        status_display = status
        if status == &quot;COMPLETE&quot;:
            status_display = &quot;âœ… Complete&quot;
        elif status == &quot;RUNNING&quot;:
            status_display = &quot;ðŸƒ Running&quot;
        elif status == &quot;FAILED&quot;:
            status_display = &quot;âŒ Failed&quot;
        elif status == &quot;STOPPED&quot;:
            status_display = &quot;â¹ï¸ Stopped&quot;
        elif status == &quot;PENDING&quot;:
            status_display = &quot;â³ Pending&quot;

        # Create result display
        result_info = []
        result_info.append(f&quot;[cyan]Agent Run ID:[/cyan] {run_id}&quot;)
        result_info.append(f&quot;[cyan]Status:[/cyan]       {status_display}&quot;)
        result_info.append(f&quot;[cyan]Created:[/cyan]      {created_display}&quot;)
        if web_url:
            result_info.append(f&quot;[cyan]Web URL:[/cyan]      {web_url}&quot;)

        result_text = &quot;\n&quot;.join(result_info)

        console.print(
            Panel(
                result_text,
                title=&quot;ðŸ¤– [bold]Agent Run Created[/bold]&quot;,
                border_style=&quot;green&quot;,
                box=box.ROUNDED,
                padding=(1, 2),
            )
        )

        # Show next steps
        console.print(&quot;\n[dim]ðŸ’¡ Track progress with:[/dim] [cyan]codegen agents[/cyan]&quot;)
        if web_url:
            console.print(f&quot;[dim]ðŸŒ View in browser:[/dim]  [link]{web_url}[/link]&quot;)

    except requests.RequestException as e:
        console.print(f&quot;[red]Error creating agent run:[/red] {e}&quot;, style=&quot;bold red&quot;)
        if hasattr(e, &quot;response&quot;) and e.response is not None:
            try:
                error_detail = e.response.json().get(&quot;detail&quot;, &quot;Unknown error&quot;)
                console.print(f&quot;[red]Details:[/red] {error_detail}&quot;)
            except (ValueError, KeyError):
                pass
        raise typer.Exit(1)
    except Exception as e:
        console.print(f&quot;[red]Unexpected error:[/red] {e}&quot;, style=&quot;bold red&quot;)
        raise typer.Exit(1)


# Default callback for the agent app
@agent_app.callback(invoke_without_command=True)
def agent_callback(ctx: typer.Context):
    &quot;&quot;&quot;Create and manage individual agent runs.&quot;&quot;&quot;
    if ctx.invoked_subcommand is None:
        # If no subcommand is provided, show help
        print(ctx.get_help())
        raise typer.Exit()


# For backward compatibility, also allow `codegen agent --prompt &quot;...&quot;`, `codegen agent --id X --json`, and `codegen agent --id X pull`
def agent(
    action: str = typer.Argument(None, help=&quot;Action to perform: &apos;pull&apos; to checkout PR branch&quot;),
    prompt: str | None = typer.Option(None, &quot;--prompt&quot;, &quot;-p&quot;, help=&quot;The prompt to send to the agent&quot;),
    agent_id: int | None = typer.Option(None, &quot;--id&quot;, help=&quot;Agent run ID to fetch or pull&quot;),
    as_json: bool = typer.Option(False, &quot;--json&quot;, help=&quot;Output raw JSON response&quot;),
    org_id: int | None = typer.Option(None, help=&quot;Organization ID (defaults to CODEGEN_ORG_ID/REPOSITORY_ORG_ID or auto-detect)&quot;),
    model: str | None = typer.Option(None, help=&quot;Model to use for this agent run (optional)&quot;),
    repo_id: int | None = typer.Option(None, help=&quot;Repository ID to use for this agent run (optional)&quot;),
):
    &quot;&quot;&quot;Create a new agent run with the given prompt, fetch an existing agent run by ID, or pull PR branch.&quot;&quot;&quot;
    if prompt:
        # If prompt is provided, create the agent run
        create(prompt=prompt, org_id=org_id, model=model, repo_id=repo_id)
    elif agent_id and action == &quot;pull&quot;:
        # If agent ID and pull action provided, pull the PR branch
        pull(agent_id=agent_id, org_id=org_id)
    elif agent_id:
        # If agent ID is provided, fetch the agent run
        get(agent_id=agent_id, as_json=as_json, org_id=org_id)
    else:
        # If none of the above, show help
        console.print(&quot;[red]Error:[/red] Either --prompt or --id is required&quot;)
        console.print(&quot;Usage:&quot;)
        console.print(&quot;  [cyan]codegen agent --prompt &apos;Your prompt here&apos;[/cyan]      # Create agent run&quot;)
        console.print(&quot;  [cyan]codegen agent --id 123 --json[/cyan]                   # Fetch agent run as JSON&quot;)
        console.print(&quot;  [cyan]codegen agent --id 123 pull[/cyan]                     # Pull PR branch&quot;)
        raise typer.Exit(1)


@agent_app.command()
def get(
    agent_id: int = typer.Option(..., &quot;--id&quot;, help=&quot;Agent run ID to fetch&quot;),
    as_json: bool = typer.Option(False, &quot;--json&quot;, help=&quot;Output raw JSON response&quot;),
    org_id: int | None = typer.Option(None, help=&quot;Organization ID (defaults to CODEGEN_ORG_ID/REPOSITORY_ORG_ID or auto-detect)&quot;),
):
    &quot;&quot;&quot;Fetch and display details for a specific agent run.&quot;&quot;&quot;
    # Get the current token
    token = get_current_token()
    if not token:
        console.print(&quot;[red]Error:[/red] Not authenticated. Please run &apos;codegen login&apos; first.&quot;)
        raise typer.Exit(1)

    try:
        # Resolve org id (fast, uses stored data)
        resolved_org_id = resolve_org_id(org_id)
        if resolved_org_id is None:
            console.print(&quot;[red]Error:[/red] Organization ID not provided. Pass --org-id, set CODEGEN_ORG_ID, or REPOSITORY_ORG_ID.&quot;)
            raise typer.Exit(1)

        spinner = create_spinner(f&quot;Fetching agent run {agent_id}...&quot;)
        spinner.start()

        try:
            headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}
            # Fixed: Use /agent/run/{id} not /agent/runs/{id}
            url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{resolved_org_id}/agent/run/{agent_id}&quot;
            response = requests.get(url, headers=headers)
            response.raise_for_status()
            agent_data = response.json()
        finally:
            spinner.stop()

        # Output the data
        if as_json:
            # Pretty print JSON with syntax highlighting
            formatted_json = json.dumps(agent_data, indent=2, sort_keys=True)
            syntax = Syntax(formatted_json, &quot;json&quot;, theme=&quot;monokai&quot;, line_numbers=False)
            console.print(syntax)
        else:
            # Display formatted information (fallback for future enhancement)
            formatted_json = json.dumps(agent_data, indent=2, sort_keys=True)
            syntax = Syntax(formatted_json, &quot;json&quot;, theme=&quot;monokai&quot;, line_numbers=False)
            console.print(syntax)

    except requests.HTTPError as e:
        # Get organization name for better error messages
        org_name = get_current_org_name()
        org_display = f&quot;{org_name} ({resolved_org_id})&quot; if org_name else f&quot;organization {resolved_org_id}&quot;

        if e.response.status_code == 404:
            console.print(f&quot;[red]Error:[/red] Agent run {agent_id} not found in {org_display}.&quot;)
        elif e.response.status_code == 403:
            console.print(f&quot;[red]Error:[/red] Access denied to agent run {agent_id} in {org_display}. Check your permissions.&quot;)
        else:
            console.print(f&quot;[red]Error:[/red] HTTP {e.response.status_code}: {e}&quot;)
        raise typer.Exit(1)
    except requests.RequestException as e:
        console.print(f&quot;[red]Error fetching agent run:[/red] {e}&quot;)
        raise typer.Exit(1)
    except Exception as e:
        console.print(f&quot;[red]Unexpected error:[/red] {e}&quot;)
        raise typer.Exit(1)


@agent_app.command()
def pull(
    agent_id: int = typer.Option(..., &quot;--id&quot;, help=&quot;Agent run ID to pull PR branch for&quot;),
    org_id: int | None = typer.Option(None, help=&quot;Organization ID (defaults to CODEGEN_ORG_ID/REPOSITORY_ORG_ID or auto-detect)&quot;),
):
    &quot;&quot;&quot;Fetch and checkout the PR branch for an agent run.&quot;&quot;&quot;
    token = get_current_token()
    if not token:
        console.print(&quot;[red]Error:[/red] Not authenticated. Please run &apos;codegen login&apos; first.&quot;)
        raise typer.Exit(1)

    resolved_org_id = resolve_org_id(org_id)
    if resolved_org_id is None:
        console.print(&quot;[red]Error:[/red] Organization ID not provided. Pass --org-id, set CODEGEN_ORG_ID, or REPOSITORY_ORG_ID.&quot;)
        raise typer.Exit(1)

    # Check if we&apos;re in a git repository
    try:
        current_repo = LocalGitRepo(Path.cwd())
        if not current_repo.has_remote():
            console.print(&quot;[red]Error:[/red] Current directory is not a git repository with remotes.&quot;)
            raise typer.Exit(1)
    except Exception:
        console.print(&quot;[red]Error:[/red] Current directory is not a valid git repository.&quot;)
        raise typer.Exit(1)

    # Fetch agent run data
    spinner = create_spinner(f&quot;Fetching agent run {agent_id}...&quot;)
    spinner.start()

    try:
        headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}
        url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{resolved_org_id}/agent/run/{agent_id}&quot;
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        agent_data = response.json()
    except requests.HTTPError as e:
        org_name = get_current_org_name()
        org_display = f&quot;{org_name} ({resolved_org_id})&quot; if org_name else f&quot;organization {resolved_org_id}&quot;

        if e.response.status_code == 404:
            console.print(f&quot;[red]Error:[/red] Agent run {agent_id} not found in {org_display}.&quot;)
        elif e.response.status_code == 403:
            console.print(f&quot;[red]Error:[/red] Access denied to agent run {agent_id} in {org_display}. Check your permissions.&quot;)
        else:
            console.print(f&quot;[red]Error:[/red] HTTP {e.response.status_code}: {e}&quot;)
        raise typer.Exit(1)
    except requests.RequestException as e:
        console.print(f&quot;[red]Error fetching agent run:[/red] {e}&quot;)
        raise typer.Exit(1)
    finally:
        spinner.stop()

    # Check if agent run has PRs
    github_prs = agent_data.get(&quot;github_pull_requests&quot;, [])
    if not github_prs:
        console.print(f&quot;[yellow]Warning:[/yellow] Agent run {agent_id} has no associated pull requests.&quot;)
        raise typer.Exit(1)

    if len(github_prs) &gt; 1:
        console.print(f&quot;[yellow]Warning:[/yellow] Agent run {agent_id} has multiple PRs. Using the first one.&quot;)

    pr = github_prs[0]
    pr_url = pr.get(&quot;url&quot;)
    head_branch_name = pr.get(&quot;head_branch_name&quot;)

    if not pr_url:
        console.print(&quot;[red]Error:[/red] PR URL not found in agent run data.&quot;)
        raise typer.Exit(1)

    if not head_branch_name:
        # Try to extract branch name from PR URL as fallback
        # GitHub PR URLs often follow patterns like:
        # https://github.com/owner/repo/pull/123
        # We can use GitHub API to get the branch name
        console.print(&quot;[yellow]Info:[/yellow] HEAD branch name not in API response, attempting to fetch from GitHub...&quot;)
        try:
            # Extract owner, repo, and PR number from PR URL manually
            # Expected format: https://github.com/owner/repo/pull/123
            if not pr_url.startswith(&quot;https://github.com/&quot;):
                msg = f&quot;Only GitHub URLs are supported, got: {pr_url}&quot;
                raise ValueError(msg)

            # Remove the GitHub base and split the path
            path_parts = pr_url.replace(&quot;https://github.com/&quot;, &quot;&quot;).split(&quot;/&quot;)
            if len(path_parts) &lt; 4 or path_parts[2] != &quot;pull&quot;:
                msg = f&quot;Invalid GitHub PR URL format: {pr_url}&quot;
                raise ValueError(msg)

            owner = path_parts[0]
            repo = path_parts[1]
            pr_number = path_parts[3]

            # Use GitHub API to get PR details
            import requests as github_requests

            github_api_url = f&quot;https://api.github.com/repos/{owner}/{repo}/pulls/{pr_number}&quot;

            github_response = github_requests.get(github_api_url)
            if github_response.status_code == 200:
                pr_data = github_response.json()
                head_branch_name = pr_data.get(&quot;head&quot;, {}).get(&quot;ref&quot;)
                if head_branch_name:
                    console.print(f&quot;[green]âœ“ Found branch name from GitHub API:[/green] {head_branch_name}&quot;)
                else:
                    console.print(&quot;[red]Error:[/red] Could not extract branch name from GitHub API response.&quot;)
                    raise typer.Exit(1)
            else:
                console.print(f&quot;[red]Error:[/red] Failed to fetch PR details from GitHub API (status: {github_response.status_code})&quot;)
                console.print(&quot;[yellow]Tip:[/yellow] The PR may be private or the GitHub API rate limit may be exceeded.&quot;)
                raise typer.Exit(1)
        except Exception as e:
            console.print(f&quot;[red]Error:[/red] Could not fetch branch name from GitHub: {e}&quot;)
            console.print(&quot;[yellow]Tip:[/yellow] The backend may need to be updated to include branch information.&quot;)
            raise typer.Exit(1)

    # Parse PR URL to get repository information
    try:
        # Extract owner and repo from PR URL manually
        # Expected format: https://github.com/owner/repo/pull/123
        if not pr_url.startswith(&quot;https://github.com/&quot;):
            msg = f&quot;Only GitHub URLs are supported, got: {pr_url}&quot;
            raise ValueError(msg)

        # Remove the GitHub base and split the path
        path_parts = pr_url.replace(&quot;https://github.com/&quot;, &quot;&quot;).split(&quot;/&quot;)
        if len(path_parts) &lt; 4 or path_parts[2] != &quot;pull&quot;:
            msg = f&quot;Invalid GitHub PR URL format: {pr_url}&quot;
            raise ValueError(msg)

        owner = path_parts[0]
        repo = path_parts[1]
        pr_repo_full_name = f&quot;{owner}/{repo}&quot;
    except Exception as e:
        console.print(f&quot;[red]Error:[/red] Could not parse PR URL: {pr_url} - {e}&quot;)
        raise typer.Exit(1)

    # Check if current repository matches PR repository
    current_repo_full_name = current_repo.full_name
    if not current_repo_full_name:
        console.print(&quot;[red]Error:[/red] Could not determine current repository name.&quot;)
        raise typer.Exit(1)

    if current_repo_full_name.lower() != pr_repo_full_name.lower():
        console.print(&quot;[red]Error:[/red] Repository mismatch!&quot;)
        console.print(f&quot;  Current repo: [cyan]{current_repo_full_name}[/cyan]&quot;)
        console.print(f&quot;  PR repo:      [cyan]{pr_repo_full_name}[/cyan]&quot;)
        console.print(&quot;[yellow]Tip:[/yellow] Navigate to the correct repository directory first.&quot;)
        raise typer.Exit(1)

    # Perform git operations with safety checks
    try:
        repo_config = RepoConfig.from_repo_path(str(Path.cwd()))
        repo_operator = RepoOperator(repo_config)

        # Safety check: warn if repository has uncommitted changes
        if repo_operator.git_cli.is_dirty():
            console.print(&quot;[yellow]âš ï¸  Warning:[/yellow] You have uncommitted changes in your repository.&quot;)
            console.print(&quot;These changes may be lost when switching branches.&quot;)

            # Get user confirmation
            confirm = typer.confirm(&quot;Do you want to continue? Your changes may be lost.&quot;)
            if not confirm:
                console.print(&quot;[yellow]Operation cancelled.[/yellow]&quot;)
                raise typer.Exit(0)

            console.print(&quot;[blue]Proceeding with branch checkout...[/blue]&quot;)

        console.print(f&quot;[blue]Repository match confirmed:[/blue] {current_repo_full_name}&quot;)
        console.print(f&quot;[blue]Fetching and checking out branch:[/blue] {head_branch_name}&quot;)

        # Fetch the branch from remote
        fetch_spinner = create_spinner(&quot;Fetching latest changes from remote...&quot;)
        fetch_spinner.start()
        try:
            fetch_result = repo_operator.fetch_remote(&quot;origin&quot;)
            if fetch_result.name != &quot;SUCCESS&quot;:
                console.print(f&quot;[yellow]Warning:[/yellow] Fetch result: {fetch_result.name}&quot;)
        except Exception as e:
            console.print(f&quot;[red]Error during fetch:[/red] {e}&quot;)
            raise
        finally:
            fetch_spinner.stop()

        # Check if the branch already exists locally
        local_branches = [b.name for b in repo_operator.git_cli.branches]
        if head_branch_name in local_branches:
            console.print(f&quot;[yellow]Info:[/yellow] Local branch &apos;{head_branch_name}&apos; already exists. It will be reset to match the remote.&quot;)

        # Checkout the remote branch
        checkout_spinner = create_spinner(f&quot;Checking out branch {head_branch_name}...&quot;)
        checkout_spinner.start()
        try:
            checkout_result = repo_operator.checkout_remote_branch(head_branch_name)
            if checkout_result.name == &quot;SUCCESS&quot;:
                console.print(f&quot;[green]âœ“ Successfully checked out branch:[/green] {head_branch_name}&quot;)
            elif checkout_result.name == &quot;NOT_FOUND&quot;:
                console.print(f&quot;[red]Error:[/red] Branch {head_branch_name} not found on remote.&quot;)
                console.print(&quot;[yellow]Tip:[/yellow] The branch may have been deleted or renamed.&quot;)
                raise typer.Exit(1)
            else:
                console.print(f&quot;[yellow]Warning:[/yellow] Checkout result: {checkout_result.name}&quot;)
        except Exception as e:
            console.print(f&quot;[red]Error during checkout:[/red] {e}&quot;)
            raise
        finally:
            checkout_spinner.stop()

        # Display success info
        console.print(
            Panel(
                f&quot;[green]âœ“ Successfully pulled PR branch![/green]\n\n&quot;
                f&quot;[cyan]Agent Run:[/cyan]    {agent_id}\n&quot;
                f&quot;[cyan]Repository:[/cyan]   {current_repo_full_name}\n&quot;
                f&quot;[cyan]Branch:[/cyan]       {head_branch_name}\n&quot;
                f&quot;[cyan]PR URL:[/cyan]       {pr_url}&quot;,
                title=&quot;ðŸŒ¿ [bold]Branch Checkout Complete[/bold]&quot;,
                border_style=&quot;green&quot;,
                box=box.ROUNDED,
                padding=(1, 2),
            )
        )

    except Exception as e:
        console.print(f&quot;[red]Error during git operations:[/red] {e}&quot;)
        raise typer.Exit(1)</file><file path="src/codegen/cli/commands/agents/__init__.py">&quot;&quot;&quot;Agents command module.&quot;&quot;&quot;</file><file path="src/codegen/cli/commands/agents/main.py">&quot;&quot;&quot;Agents command for the Codegen CLI.&quot;&quot;&quot;

import requests
import typer
from rich.console import Console
from rich.table import Table

from codegen.cli.api.endpoints import API_ENDPOINT
from codegen.cli.auth.token_manager import get_current_token
from codegen.cli.rich.spinners import create_spinner
from codegen.cli.utils.org import resolve_org_id
from codegen.shared.logging.get_logger import get_logger

# Initialize logger
logger = get_logger(__name__)

console = Console()

# Create the agents app
agents_app = typer.Typer(help=&quot;Manage Codegen agents&quot;)


@agents_app.command(&quot;list&quot;)
def list_agents(org_id: int | None = typer.Option(None, help=&quot;Organization ID (defaults to CODEGEN_ORG_ID/REPOSITORY_ORG_ID or auto-detect)&quot;)):
    &quot;&quot;&quot;List agent runs from the Codegen API.&quot;&quot;&quot;
    logger.info(&quot;Agents list command invoked&quot;, extra={&quot;operation&quot;: &quot;agents.list&quot;, &quot;org_id&quot;: org_id, &quot;command&quot;: &quot;codegen agents list&quot;})

    # Get the current token
    token = get_current_token()
    if not token:
        logger.error(&quot;Agents list failed - not authenticated&quot;, extra={&quot;operation&quot;: &quot;agents.list&quot;, &quot;error_type&quot;: &quot;not_authenticated&quot;})
        console.print(&quot;[red]Error:[/red] Not authenticated. Please run &apos;codegen login&apos; first.&quot;)
        raise typer.Exit(1)

    try:
        # Resolve org id (now fast, uses stored data)
        resolved_org_id = resolve_org_id(org_id)
        if resolved_org_id is None:
            console.print(&quot;[red]Error:[/red] Organization ID not provided. Pass --org-id, set CODEGEN_ORG_ID, or REPOSITORY_ORG_ID.&quot;)
            raise typer.Exit(1)

        # Start spinner for API calls only
        spinner = create_spinner(&quot;Fetching your recent API agent runs...&quot;)
        spinner.start()

        try:
            headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}

            # Filter to only API source type and current user&apos;s agent runs
            params = {
                &quot;source_type&quot;: &quot;API&quot;,
                # We&apos;ll get the user_id from the /users/me endpoint
            }

            # First get the current user ID
            user_response = requests.get(f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/users/me&quot;, headers=headers)
            user_response.raise_for_status()
            user_data = user_response.json()
            user_id = user_data.get(&quot;id&quot;)

            if user_id:
                params[&quot;user_id&quot;] = user_id

            url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{resolved_org_id}/agent/runs&quot;
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()
            response_data = response.json()
        finally:
            spinner.stop()

        # Extract agent runs from the response structure
        agent_runs = response_data.get(&quot;items&quot;, [])
        total = response_data.get(&quot;total&quot;, 0)
        page = response_data.get(&quot;page&quot;, 1)
        page_size = response_data.get(&quot;page_size&quot;, 10)

        if not agent_runs:
            console.print(&quot;[yellow]No API agent runs found for your user.[/yellow]&quot;)
            return

        # Create a table to display agent runs
        table = Table(
            title=f&quot;Your Recent API Agent Runs (Page {page}, Total: {total})&quot;,
            border_style=&quot;blue&quot;,
            show_header=True,
            title_justify=&quot;center&quot;,
        )
        table.add_column(&quot;Created&quot;, style=&quot;dim&quot;)
        table.add_column(&quot;Status&quot;, style=&quot;white&quot;, justify=&quot;center&quot;)
        table.add_column(&quot;Summary&quot;, style=&quot;green&quot;)
        table.add_column(&quot;Link&quot;, style=&quot;blue&quot;)

        # Add agent runs to table
        for agent_run in agent_runs:
            run_id = str(agent_run.get(&quot;id&quot;, &quot;Unknown&quot;))
            status = agent_run.get(&quot;status&quot;, &quot;Unknown&quot;)
            source_type = agent_run.get(&quot;source_type&quot;, &quot;Unknown&quot;)
            created_at = agent_run.get(&quot;created_at&quot;, &quot;Unknown&quot;)

            # Use summary from API response (backend now handles extraction)
            summary = agent_run.get(&quot;summary&quot;, &quot;&quot;) or &quot;No summary&quot;

            # Status with colored circles
            if status == &quot;COMPLETE&quot;:
                status_display = &quot;[green]â—[/green] Complete&quot;
            elif status == &quot;ACTIVE&quot;:
                status_display = &quot;[dim]â—[/dim] Active&quot;
            elif status == &quot;RUNNING&quot;:
                status_display = &quot;[dim]â—[/dim] Running&quot;
            elif status == &quot;CANCELLED&quot;:
                status_display = &quot;[yellow]â—[/yellow] Cancelled&quot;
            elif status == &quot;ERROR&quot;:
                status_display = &quot;[red]â—[/red] Error&quot;
            elif status == &quot;FAILED&quot;:
                status_display = &quot;[red]â—[/red] Failed&quot;
            elif status == &quot;STOPPED&quot;:
                status_display = &quot;[yellow]â—[/yellow] Stopped&quot;
            elif status == &quot;PENDING&quot;:
                status_display = &quot;[dim]â—[/dim] Pending&quot;
            else:
                status_display = &quot;[dim]â—[/dim] &quot; + status

            # Format created date (just show date and time, not full timestamp)
            if created_at and created_at != &quot;Unknown&quot;:
                try:
                    # Parse and format the timestamp to be more readable
                    from datetime import datetime

                    dt = datetime.fromisoformat(created_at.replace(&quot;Z&quot;, &quot;+00:00&quot;))
                    created_display = dt.strftime(&quot;%m/%d %H:%M&quot;)
                except (ValueError, TypeError):
                    created_display = created_at[:16] if len(created_at) &gt; 16 else created_at
            else:
                created_display = created_at

            # Truncate summary if too long
            summary_display = summary[:50] + &quot;...&quot; if summary and len(summary) &gt; 50 else summary or &quot;No summary&quot;

            # Create web link for the agent run
            web_url = agent_run.get(&quot;web_url&quot;)
            if not web_url:
                # Construct URL if not provided
                web_url = f&quot;https://codegen.com/traces/{run_id}&quot;
            link_display = web_url

            table.add_row(created_display, status_display, summary_display, link_display)

        console.print(table)
        console.print(f&quot;\n[green]Showing {len(agent_runs)} of {total} API agent runs[/green]&quot;)

    except requests.RequestException as e:
        console.print(f&quot;[red]Error fetching agent runs:[/red] {e}&quot;, style=&quot;bold red&quot;)
        raise typer.Exit(1)
    except Exception as e:
        console.print(f&quot;[red]Unexpected error:[/red] {e}&quot;, style=&quot;bold red&quot;)
        raise typer.Exit(1)


# Default callback for the agents app
@agents_app.callback(invoke_without_command=True)
def agents_callback(ctx: typer.Context):
    &quot;&quot;&quot;Manage Codegen agents.&quot;&quot;&quot;
    if ctx.invoked_subcommand is None:
        # If no subcommand is provided, run list by default
        list_agents(org_id=None)</file><file path="src/codegen/cli/commands/claude/config/claude_session_active_hook.py">#!/usr/bin/env python3
&quot;&quot;&quot;Claude Code user prompt submit hook for API integration.

This script is called by Claude Code on UserPromptSubmit to:
1. Read the session context (session_id, org_id)
2. Send an ACTIVE status to the backend API
&quot;&quot;&quot;

import json
import os
import sys
from pathlib import Path

# Add the codegen CLI to the path so we can import from it
script_dir = Path(__file__).parent
codegen_cli_dir = script_dir.parent.parent.parent.parent
sys.path.insert(0, str(codegen_cli_dir))

try:
    from codegen.cli.commands.claude.claude_session_api import update_claude_session_status
except ImportError:
    update_claude_session_status = None


def read_session_file() -&gt; dict:
    &quot;&quot;&quot;Read session data written by the SessionStart hook, if available.&quot;&quot;&quot;
    session_path = Path.home() / &quot;.codegen&quot; / &quot;claude-session.json&quot;
    if not session_path.exists():
        return {}
    try:
        with open(session_path) as f:
            return json.load(f)
    except Exception:
        return {}


def main():
    try:
        # Prefer environment variables set by the CLI wrapper
        session_id = os.environ.get(&quot;CODEGEN_CLAUDE_SESSION_ID&quot;)
        org_id = os.environ.get(&quot;CODEGEN_CLAUDE_ORG_ID&quot;)

        # Fallback to reading the session file
        if not session_id or not org_id:
            data = read_session_file()
            session_id = session_id or data.get(&quot;session_id&quot;)
            org_id = org_id or data.get(&quot;org_id&quot;)

        # Normalize org_id type
        if isinstance(org_id, str):
            try:
                org_id = int(org_id)
            except ValueError:
                org_id = None

        if update_claude_session_status and session_id:
            update_claude_session_status(session_id, &quot;ACTIVE&quot;, org_id)

        # Print minimal output
        print(json.dumps({&quot;session_id&quot;: session_id, &quot;status&quot;: &quot;ACTIVE&quot;}))

    except Exception as e:
        print(json.dumps({&quot;error&quot;: str(e)}))


if __name__ == &quot;__main__&quot;:
    main()</file><file path="src/codegen/cli/commands/claude/config/claude_session_hook.py">#!/usr/bin/env python3
&quot;&quot;&quot;Claude Code session hook script for API integration.

This script is called by Claude Code on SessionStart to:
1. Create a session in the backend API
2. Write session data to local file for tracking
&quot;&quot;&quot;

import json
import os
import sys
from pathlib import Path

# Add the codegen CLI to the path so we can import from it
script_dir = Path(__file__).parent
codegen_cli_dir = script_dir.parent.parent.parent.parent
sys.path.insert(0, str(codegen_cli_dir))

try:
    from codegen.cli.commands.claude.claude_session_api import create_claude_session
    from codegen.cli.utils.org import resolve_org_id
except ImportError:
    create_claude_session = None


def main():
    &quot;&quot;&quot;Main hook function called by Claude Code.&quot;&quot;&quot;
    try:
        # Read hook input from stdin (Claude passes JSON data)
        input_data = {}
        try:
            if not sys.stdin.isatty():
                input_text = sys.stdin.read().strip()
                if input_text:
                    input_data = json.loads(input_text)
        except (json.JSONDecodeError, Exception):
            # If we can&apos;t read the input, continue with empty data
            pass

        # Get session ID from environment variable (set by main.py)
        session_id = os.environ.get(&quot;CODEGEN_CLAUDE_SESSION_ID&quot;)
        if not session_id:
            # Fallback: try to extract from input data
            session_id = input_data.get(&quot;session_id&quot;)

        if not session_id:
            # Generate a basic session ID if none available
            import uuid

            session_id = str(uuid.uuid4())

        # Get org_id from environment variable (set by main.py)
        org_id_str = os.environ.get(&quot;CODEGEN_CLAUDE_ORG_ID&quot;)
        org_id = None
        if org_id_str:
            try:
                org_id = int(org_id_str)
            except ValueError:
                pass

        # If we don&apos;t have org_id, try to resolve it
        if org_id is None and resolve_org_id:
            org_id = resolve_org_id(None)

        # Create session via API if available
        agent_run_id = None
        if org_id:
            agent_run_id = create_claude_session(session_id, org_id)

        # Prepare session data
        session_data = {&quot;session_id&quot;: session_id, &quot;agent_run_id&quot;: agent_run_id, &quot;org_id&quot;: org_id, &quot;hook_event&quot;: input_data.get(&quot;hook_event_name&quot;), &quot;timestamp&quot;: input_data.get(&quot;timestamp&quot;)}

        # Output the session data (this gets written to the session file by the hook command)
        print(json.dumps(session_data, indent=2))

    except Exception as e:
        # If anything fails, at least output basic session data
        session_id = os.environ.get(&quot;CODEGEN_CLAUDE_SESSION_ID&quot;, &quot;unknown&quot;)
        fallback_data = {&quot;session_id&quot;: session_id, &quot;error&quot;: str(e), &quot;agent_run_id&quot;: None, &quot;org_id&quot;: None}
        print(json.dumps(fallback_data, indent=2))


if __name__ == &quot;__main__&quot;:
    main()</file><file path="src/codegen/cli/commands/claude/config/claude_session_stop_hook.py">#!/usr/bin/env python3
&quot;&quot;&quot;Claude Code stop hook script for API integration.

This script is called by Claude Code on Stop to:
1. Read the session context (session_id, org_id)
2. Send a COMPLETE status to the backend API
&quot;&quot;&quot;

import json
import os
import sys
from pathlib import Path

# Add the codegen CLI to the path so we can import from it
script_dir = Path(__file__).parent
codegen_cli_dir = script_dir.parent.parent.parent.parent
sys.path.insert(0, str(codegen_cli_dir))

try:
    from codegen.cli.commands.claude.claude_session_api import update_claude_session_status
except ImportError:
    update_claude_session_status = None


def read_session_file() -&gt; dict:
    &quot;&quot;&quot;Read session data written by the SessionStart hook, if available.&quot;&quot;&quot;
    session_path = Path.home() / &quot;.codegen&quot; / &quot;claude-session.json&quot;
    if not session_path.exists():
        return {}
    try:
        with open(session_path) as f:
            return json.load(f)
    except Exception:
        return {}


def main():
    try:
        # Prefer environment variables set by the CLI wrapper
        session_id = os.environ.get(&quot;CODEGEN_CLAUDE_SESSION_ID&quot;)
        org_id = os.environ.get(&quot;CODEGEN_CLAUDE_ORG_ID&quot;)

        # Fallback to reading the session file
        if not session_id or not org_id:
            data = read_session_file()
            session_id = session_id or data.get(&quot;session_id&quot;)
            org_id = org_id or data.get(&quot;org_id&quot;)

        # Normalize org_id type
        if isinstance(org_id, str):
            try:
                org_id = int(org_id)
            except ValueError:
                org_id = None

        if update_claude_session_status and session_id:
            update_claude_session_status(session_id, &quot;COMPLETE&quot;, org_id)

        # Print minimal output to avoid noisy hooks
        print(json.dumps({&quot;session_id&quot;: session_id, &quot;status&quot;: &quot;COMPLETE&quot;}))

    except Exception as e:
        # Ensure hook doesn&apos;t fail Claude if something goes wrong
        print(json.dumps({&quot;error&quot;: str(e)}))


if __name__ == &quot;__main__&quot;:
    main()</file><file path="src/codegen/cli/commands/claude/config/mcp_setup.py">import subprocess

from codegen.cli.api.endpoints import MCP_SERVER_ENDPOINT
from codegen.cli.auth.token_manager import get_current_token
from codegen.cli.commands.claude.quiet_console import console
from codegen.cli.commands.claude.utils import resolve_claude_path


def add_codegen_mcp_server(org_id: int | None = None, repo_id: int | None = None):
    console.print(&quot;ðŸ”§ Configuring MCP server &apos;codegen-tools&apos;...&quot;, style=&quot;blue&quot;)
    try:
        token = get_current_token()
        if not token:
            console.print(&quot;âš ï¸  No authentication token found. Please run &apos;codegen login&apos; first.&quot;, style=&quot;yellow&quot;)
            return

        claude_path = resolve_claude_path()
        if not claude_path:
            console.print(&quot;âš ï¸  &apos;claude&apos; CLI not found to add MCP server&quot;, style=&quot;yellow&quot;)
            return

        # Build the command with required headers
        cmd = [
            claude_path,
            &quot;mcp&quot;,
            &quot;add&quot;,
            &quot;--transport&quot;,
            &quot;http&quot;,
            &quot;codegen-tools&quot;,
            MCP_SERVER_ENDPOINT,
            &quot;--header&quot;,
            f&quot;Authorization: Bearer {token}&quot;,
        ]

        # Add organization ID header if available
        if org_id is not None:
            cmd.extend([&quot;--header&quot;, f&quot;x-organization-id: {org_id}&quot;])
            console.print(f&quot;  Adding organization ID: {org_id}&quot;, style=&quot;dim&quot;)

        # Add repository ID header if available
        if repo_id is not None:
            cmd.extend([&quot;--header&quot;, f&quot;x-repo-id: {repo_id}&quot;])
            console.print(f&quot;  Adding repository ID: {repo_id}&quot;, style=&quot;dim&quot;)

        add_result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=15,
        )
        if add_result.returncode == 0:
            console.print(&quot;âœ… MCP server added: codegen-tools -&gt; http&quot;, style=&quot;green&quot;)
        else:
            stderr = add_result.stderr.strip() if add_result.stderr else add_result.stdout.strip()
            console.print(f&quot;âš ï¸  Failed to add MCP server (code {add_result.returncode}): {stderr}&quot;, style=&quot;yellow&quot;)
    except subprocess.TimeoutExpired:
        console.print(&quot;âš ï¸  MCP server add timed out&quot;, style=&quot;yellow&quot;)
    except FileNotFoundError:
        console.print(&quot;âš ï¸  &apos;claude&apos; CLI not found to add MCP server&quot;, style=&quot;yellow&quot;)
    except Exception as e:
        console.print(f&quot;âš ï¸  Error adding MCP server: {e}&quot;, style=&quot;yellow&quot;)


def cleanup_codegen_mcp_server():
    try:
        claude_path = resolve_claude_path()
        if not claude_path:
            # Silently skip if claude is not found during cleanup
            return

        subprocess.run(
            [
                claude_path,
                &quot;mcp&quot;,
                &quot;remove&quot;,
                &quot;codegen-tools&quot;,
            ],
        )
    except Exception as e:
        console.print(f&quot;âš ï¸  Error removing MCP server: {e}&quot;, style=&quot;yellow&quot;)</file><file path="src/codegen/cli/commands/claude/__init__.py">&quot;&quot;&quot;Claude Code integration commands.&quot;&quot;&quot;</file><file path="src/codegen/cli/commands/claude/claude_log_utils.py">&quot;&quot;&quot;Utilities for Claude Code session log management.&quot;&quot;&quot;

import json
import os
import re
from pathlib import Path
from typing import Dict, Any, Optional


def get_hyphenated_cwd() -&gt; str:
    &quot;&quot;&quot;Convert current working directory to hyphenated format for Claude log path.

    Returns:
        Hyphenated directory name (e.g., &quot;/Users/john/project&quot; -&gt; &quot;users-john-project&quot;)
    &quot;&quot;&quot;
    cwd = os.getcwd()
    # Remove leading slash and replace slashes and spaces with hyphens
    hyphenated = cwd.replace(&quot;/&quot;, &quot;-&quot;).replace(&quot; &quot;, &quot;-&quot;).replace(&quot;_&quot;, &quot;-&quot;)
    # Remove any double hyphens
    hyphenated = re.sub(r&quot;-+&quot;, &quot;-&quot;, hyphenated)
    return hyphenated


def get_claude_session_log_path(session_id: str) -&gt; Path:
    &quot;&quot;&quot;Get the path to the Claude session log file.

    Args:
        session_id: The Claude session ID

    Returns:
        Path to the session log file
    &quot;&quot;&quot;
    claude_dir = Path.home() / &quot;.claude&quot;
    projects_dir = claude_dir / &quot;projects&quot;
    hyphenated_cwd = get_hyphenated_cwd()
    project_dir = projects_dir / hyphenated_cwd

    log_file = project_dir / f&quot;{session_id}.jsonl&quot;
    return log_file


def parse_jsonl_line(line: str) -&gt; Optional[Dict[str, Any]]:
    &quot;&quot;&quot;Parse a single line from a JSONL file.

    Args:
        line: Raw line from JSONL file

    Returns:
        Parsed JSON object or None if parsing fails
    &quot;&quot;&quot;
    line = line.strip()
    if not line:
        return None

    try:
        return json.loads(line)
    except json.JSONDecodeError:
        return None


def ensure_log_directory(session_id: str) -&gt; Path:
    &quot;&quot;&quot;Ensure the log directory exists and return the log file path.

    Args:
        session_id: The Claude session ID

    Returns:
        Path to the session log file
    &quot;&quot;&quot;
    log_path = get_claude_session_log_path(session_id)
    log_path.parent.mkdir(parents=True, exist_ok=True)
    return log_path


def read_existing_log_lines(log_path: Path) -&gt; int:
    &quot;&quot;&quot;Count existing lines in a log file.

    Args:
        log_path: Path to the log file

    Returns:
        Number of existing lines
    &quot;&quot;&quot;
    if not log_path.exists():
        return 0

    try:
        with open(log_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
            return sum(1 for _ in f)
    except (OSError, UnicodeDecodeError):
        return 0


def validate_log_entry(log_entry: Dict[str, Any]) -&gt; bool:
    &quot;&quot;&quot;Validate a log entry before sending to API.

    Args:
        log_entry: The log entry to validate

    Returns:
        True if valid, False otherwise
    &quot;&quot;&quot;
    if not isinstance(log_entry, dict):
        return False

    # Basic validation - ensure it has some content
    if not log_entry:
        return False

    # Optionally validate specific fields that Claude Code uses
    # This can be expanded based on actual Claude log format
    return True


def format_log_for_api(log_entry: Dict[str, Any]) -&gt; Dict[str, Any]:
    &quot;&quot;&quot;Format a log entry for sending to the API.

    Args:
        log_entry: Raw log entry from Claude

    Returns:
        Formatted log entry ready for API
    &quot;&quot;&quot;
    # For now, pass through as-is since API expects dict[str, Any]
    # This can be enhanced to transform or filter fields as needed
    return log_entry</file><file path="src/codegen/cli/commands/claude/claude_log_watcher.py">&quot;&quot;&quot;Claude Code session log watcher implementation.&quot;&quot;&quot;

import time
import threading
from pathlib import Path
from typing import Optional, Callable, Dict, Any

from .quiet_console import console

from .claude_log_utils import get_claude_session_log_path, parse_jsonl_line, read_existing_log_lines, validate_log_entry, format_log_for_api
from .claude_session_api import send_claude_session_log


class ClaudeLogWatcher:
    &quot;&quot;&quot;Watches Claude Code session log files for new entries and sends them to the API.&quot;&quot;&quot;

    def __init__(self, session_id: str, org_id: Optional[int] = None, poll_interval: float = 1.0, on_log_entry: Optional[Callable[[Dict[str, Any]], None]] = None):
        &quot;&quot;&quot;Initialize the log watcher.

        Args:
            session_id: The Claude session ID to watch
            org_id: Organization ID for API calls
            poll_interval: How often to check for new entries (seconds)
            on_log_entry: Optional callback for each new log entry
        &quot;&quot;&quot;
        self.session_id = session_id
        self.org_id = org_id
        self.poll_interval = poll_interval
        self.on_log_entry = on_log_entry

        self.log_path = get_claude_session_log_path(session_id)
        self.last_line_count = 0
        self.is_running = False
        self.watcher_thread: Optional[threading.Thread] = None

        # Stats
        self.total_entries_processed = 0
        self.total_entries_sent = 0
        self.total_send_failures = 0

    def start(self) -&gt; bool:
        &quot;&quot;&quot;Start the log watcher in a background thread.

        Returns:
            True if started successfully, False otherwise
        &quot;&quot;&quot;
        if self.is_running:
            console.print(f&quot;âš ï¸  Log watcher for session {self.session_id[:8]}... is already running&quot;, style=&quot;yellow&quot;)
            return False

        # Initialize line count
        self.last_line_count = read_existing_log_lines(self.log_path)

        self.is_running = True
        self.watcher_thread = threading.Thread(target=self._watch_loop, daemon=True)
        self.watcher_thread.start()

        console.print(f&quot;ðŸ“‹ Started log watcher for session {self.session_id[:8]}...&quot;, style=&quot;green&quot;)
        console.print(f&quot;   Log file: {self.log_path}&quot;, style=&quot;dim&quot;)
        console.print(f&quot;   Starting from line: {self.last_line_count + 1}&quot;, style=&quot;dim&quot;)

        return True

    def stop(self) -&gt; None:
        &quot;&quot;&quot;Stop the log watcher.&quot;&quot;&quot;
        if not self.is_running:
            return

        self.is_running = False

        if self.watcher_thread and self.watcher_thread.is_alive():
            self.watcher_thread.join(timeout=2.0)

        console.print(f&quot;ðŸ“‹ Stopped log watcher for session {self.session_id[:8]}...&quot;, style=&quot;dim&quot;)
        console.print(f&quot;   Processed: {self.total_entries_processed} entries&quot;, style=&quot;dim&quot;)
        console.print(f&quot;   Sent: {self.total_entries_sent} entries&quot;, style=&quot;dim&quot;)
        if self.total_send_failures &gt; 0:
            console.print(f&quot;   Failures: {self.total_send_failures} entries&quot;, style=&quot;yellow&quot;)

    def _watch_loop(self) -&gt; None:
        &quot;&quot;&quot;Main watching loop that runs in a background thread.&quot;&quot;&quot;
        while self.is_running:
            try:
                self._check_for_new_entries()
                time.sleep(self.poll_interval)
            except Exception as e:
                console.print(f&quot;âš ï¸  Error in log watcher: {e}&quot;, style=&quot;yellow&quot;)
                time.sleep(self.poll_interval * 2)  # Back off on errors

    def _check_for_new_entries(self) -&gt; None:
        &quot;&quot;&quot;Check for new log entries and process them.&quot;&quot;&quot;
        if not self.log_path.exists():
            return

        try:
            current_line_count = read_existing_log_lines(self.log_path)

            if current_line_count &gt; self.last_line_count:
                new_entries = self._read_new_lines(self.last_line_count, current_line_count)

                for entry in new_entries:
                    self._process_log_entry(entry)

                self.last_line_count = current_line_count

        except Exception as e:
            console.print(f&quot;âš ï¸  Error reading log file: {e}&quot;, style=&quot;yellow&quot;)

    def _read_new_lines(self, start_line: int, end_line: int) -&gt; list[Dict[str, Any]]:
        &quot;&quot;&quot;Read new lines from the log file.

        Args:
            start_line: Line number to start from (0-indexed)
            end_line: Line number to end at (0-indexed, exclusive)

        Returns:
            List of parsed log entries
        &quot;&quot;&quot;
        entries = []

        try:
            with open(self.log_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
                lines = f.readlines()

                # Read only the new lines
                for i in range(start_line, min(end_line, len(lines))):
                    line = lines[i]
                    entry = parse_jsonl_line(line)

                    if entry is not None:
                        entries.append(entry)

        except (OSError, UnicodeDecodeError) as e:
            console.print(f&quot;âš ï¸  Error reading log file: {e}&quot;, style=&quot;yellow&quot;)

        return entries

    def _process_log_entry(self, log_entry: Dict[str, Any]) -&gt; None:
        &quot;&quot;&quot;Process a single log entry.

        Args:
            log_entry: The parsed log entry
        &quot;&quot;&quot;
        self.total_entries_processed += 1

        # Validate the entry
        if not validate_log_entry(log_entry):
            console.print(f&quot;âš ï¸  Invalid log entry skipped: {log_entry}&quot;, style=&quot;yellow&quot;)
            return

        # Format for API
        formatted_entry = format_log_for_api(log_entry)

        # Call optional callback
        if self.on_log_entry:
            try:
                self.on_log_entry(formatted_entry)
            except Exception as e:
                console.print(f&quot;âš ï¸  Error in log entry callback: {e}&quot;, style=&quot;yellow&quot;)

        # Send to API
        self._send_log_entry(formatted_entry)

    def _send_log_entry(self, log_entry: Dict[str, Any]) -&gt; None:
        &quot;&quot;&quot;Send a log entry to the API.

        Args:
            log_entry: The formatted log entry
        &quot;&quot;&quot;
        try:
            success = send_claude_session_log(self.session_id, log_entry, self.org_id)

            if success:
                self.total_entries_sent += 1
                # Only show verbose output in debug mode
                console.print(f&quot;ðŸ“¤ Sent log entry: {log_entry.get(&apos;type&apos;, &apos;unknown&apos;)}&quot;, style=&quot;dim&quot;)
            else:
                self.total_send_failures += 1

        except Exception as e:
            self.total_send_failures += 1
            console.print(f&quot;âš ï¸  Failed to send log entry: {e}&quot;, style=&quot;yellow&quot;)

    def get_stats(self) -&gt; Dict[str, Any]:
        &quot;&quot;&quot;Get watcher statistics.

        Returns:
            Dictionary with watcher stats
        &quot;&quot;&quot;
        return {
            &quot;session_id&quot;: self.session_id,
            &quot;is_running&quot;: self.is_running,
            &quot;log_path&quot;: str(self.log_path),
            &quot;log_file_exists&quot;: self.log_path.exists(),
            &quot;last_line_count&quot;: self.last_line_count,
            &quot;total_entries_processed&quot;: self.total_entries_processed,
            &quot;total_entries_sent&quot;: self.total_entries_sent,
            &quot;total_send_failures&quot;: self.total_send_failures,
            &quot;success_rate&quot;: (self.total_entries_sent / max(1, self.total_entries_processed) * 100 if self.total_entries_processed &gt; 0 else 0),
        }


class ClaudeLogWatcherManager:
    &quot;&quot;&quot;Manages multiple log watchers for different sessions.&quot;&quot;&quot;

    def __init__(self):
        self.watchers: Dict[str, ClaudeLogWatcher] = {}

    def start_watcher(self, session_id: str, org_id: Optional[int] = None, poll_interval: float = 1.0, on_log_entry: Optional[Callable[[Dict[str, Any]], None]] = None) -&gt; bool:
        &quot;&quot;&quot;Start a log watcher for a session.

        Args:
            session_id: The Claude session ID
            org_id: Organization ID for API calls
            poll_interval: How often to check for new entries (seconds)
            on_log_entry: Optional callback for each new log entry

        Returns:
            True if started successfully, False otherwise
        &quot;&quot;&quot;
        if session_id in self.watchers:
            console.print(f&quot;âš ï¸  Watcher for session {session_id[:8]}... already exists&quot;, style=&quot;yellow&quot;)
            return False

        watcher = ClaudeLogWatcher(session_id=session_id, org_id=org_id, poll_interval=poll_interval, on_log_entry=on_log_entry)

        if watcher.start():
            self.watchers[session_id] = watcher
            return True
        return False

    def stop_watcher(self, session_id: str) -&gt; None:
        &quot;&quot;&quot;Stop a log watcher for a session.

        Args:
            session_id: The Claude session ID
        &quot;&quot;&quot;
        if session_id in self.watchers:
            self.watchers[session_id].stop()
            del self.watchers[session_id]

    def stop_all_watchers(self) -&gt; None:
        &quot;&quot;&quot;Stop all active watchers.&quot;&quot;&quot;
        for session_id in list(self.watchers.keys()):
            self.stop_watcher(session_id)

    def get_active_sessions(self) -&gt; list[str]:
        &quot;&quot;&quot;Get list of active session IDs being watched.

        Returns:
            List of session IDs
        &quot;&quot;&quot;
        return list(self.watchers.keys())

    def get_watcher_stats(self, session_id: str) -&gt; Optional[Dict[str, Any]]:
        &quot;&quot;&quot;Get stats for a specific watcher.

        Args:
            session_id: The Claude session ID

        Returns:
            Watcher stats or None if not found
        &quot;&quot;&quot;
        if session_id in self.watchers:
            return self.watchers[session_id].get_stats()
        return None

    def get_all_stats(self) -&gt; Dict[str, Dict[str, Any]]:
        &quot;&quot;&quot;Get stats for all active watchers.

        Returns:
            Dictionary mapping session IDs to their stats
        &quot;&quot;&quot;
        return {session_id: watcher.get_stats() for session_id, watcher in self.watchers.items()}</file><file path="src/codegen/cli/commands/claude/claude_session_api.py">&quot;&quot;&quot;API client for Claude Code session management.&quot;&quot;&quot;

import json
import uuid
from typing import Optional

import requests

from codegen.cli.api.endpoints import API_ENDPOINT
from codegen.cli.auth.token_manager import get_current_token
from codegen.cli.utils.org import resolve_org_id

from .quiet_console import console


class ClaudeSessionAPIError(Exception):
    &quot;&quot;&quot;Exception raised for Claude session API errors.&quot;&quot;&quot;

    pass


def generate_session_id() -&gt; str:
    &quot;&quot;&quot;Generate a unique session ID for Claude Code session tracking.&quot;&quot;&quot;
    return str(uuid.uuid4())


def create_claude_session(session_id: str, org_id: Optional[int] = None) -&gt; Optional[str]:
    &quot;&quot;&quot;Create a new Claude Code session in the backend.

    Args:
        session_id: The session ID to register
        org_id: Organization ID (will be resolved if None)

    Returns:
        Agent run ID if successful, None if failed

    Raises:
        ClaudeSessionAPIError: If the API call fails
    &quot;&quot;&quot;
    try:
        # Resolve org_id
        resolved_org_id = resolve_org_id(org_id)
        if resolved_org_id is None:
            console.print(&quot;âš ï¸  Could not resolve organization ID for session creation&quot;, style=&quot;yellow&quot;)
            return None

        # Get authentication token
        token = get_current_token()
        if not token:
            console.print(&quot;âš ï¸  No authentication token found for session creation&quot;, style=&quot;yellow&quot;)
            return None

        # Prepare API request
        url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{resolved_org_id}/claude_code/session&quot;
        headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}
        payload = {&quot;session_id&quot;: session_id}

        # Make API request
        response = requests.post(url, json=payload, headers=headers, timeout=30)

        if response.status_code == 200:
            try:
                result = response.json()
                agent_run_id = result.get(&quot;agent_run_id&quot;)
                return agent_run_id
            except (json.JSONDecodeError, KeyError) as e:
                console.print(f&quot;âš ï¸  Invalid response format from session creation: {e}&quot;, style=&quot;yellow&quot;)
                return None
        else:
            error_msg = f&quot;HTTP {response.status_code}&quot;
            try:
                error_detail = response.json().get(&quot;detail&quot;, response.text)
                error_msg = f&quot;{error_msg}: {error_detail}&quot;
            except Exception:
                error_msg = f&quot;{error_msg}: {response.text}&quot;

            console.print(f&quot;âš ï¸  Failed to create Claude session: {error_msg}&quot;, style=&quot;yellow&quot;)
            return None

    except requests.RequestException as e:
        console.print(f&quot;âš ï¸  Network error creating Claude session: {e}&quot;, style=&quot;yellow&quot;)
        return None
    except Exception as e:
        console.print(f&quot;âš ï¸  Unexpected error creating Claude session: {e}&quot;, style=&quot;yellow&quot;)
        return None


def update_claude_session_status(session_id: str, status: str, org_id: Optional[int] = None) -&gt; bool:
    &quot;&quot;&quot;Update a Claude Code session status in the backend.

    Args:
        session_id: The session ID to update
        status: Session status (&quot;COMPLETE&quot;, &quot;ERROR&quot;, &quot;ACTIVE&quot;, etc.)
        org_id: Organization ID (will be resolved if None)

    Returns:
        True if successful, False if failed
    &quot;&quot;&quot;
    try:
        # Resolve org_id
        resolved_org_id = resolve_org_id(org_id)
        if resolved_org_id is None:
            console.print(&quot;âš ï¸  Could not resolve organization ID for session status update&quot;, style=&quot;yellow&quot;)
            return False

        # Get authentication token
        token = get_current_token()
        if not token:
            console.print(&quot;âš ï¸  No authentication token found for session status update&quot;, style=&quot;yellow&quot;)
            return False

        # Prepare API request
        url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{resolved_org_id}/claude_code/session/{session_id}/status&quot;
        headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}
        payload = {&quot;status&quot;: status}

        # Make API request
        response = requests.post(url, json=payload, headers=headers, timeout=30)

        if response.status_code == 200:
            status_emoji = &quot;âœ…&quot; if status == &quot;COMPLETE&quot; else &quot;ðŸ”„&quot; if status == &quot;ACTIVE&quot; else &quot;âŒ&quot;
            console.print(f&quot;{status_emoji} Updated Claude session {session_id[:8]}... status to {status}&quot;, style=&quot;green&quot;)
            return True
        else:
            error_msg = f&quot;HTTP {response.status_code}&quot;
            try:
                error_detail = response.json().get(&quot;detail&quot;, response.text)
                error_msg = f&quot;{error_msg}: {error_detail}&quot;
            except Exception:
                error_msg = f&quot;{error_msg}: {response.text}&quot;

            console.print(f&quot;âš ï¸  Failed to update Claude session status: {error_msg}&quot;, style=&quot;yellow&quot;)
            return False

    except requests.RequestException as e:
        console.print(f&quot;âš ï¸  Network error updating Claude session status: {e}&quot;, style=&quot;yellow&quot;)
        return False
    except Exception as e:
        console.print(f&quot;âš ï¸  Unexpected error updating Claude session status: {e}&quot;, style=&quot;yellow&quot;)
        return False


def send_claude_session_log(session_id: str, log_entry: dict, org_id: Optional[int] = None) -&gt; bool:
    &quot;&quot;&quot;Send a log entry to the Claude Code session log endpoint.

    Args:
        session_id: The session ID
        log_entry: The log entry to send (dict)
        org_id: Organization ID (will be resolved if None)

    Returns:
        True if successful, False if failed
    &quot;&quot;&quot;
    try:
        # Resolve org_id
        resolved_org_id = resolve_org_id(org_id)
        if resolved_org_id is None:
            console.print(&quot;âš ï¸  Could not resolve organization ID for log sending&quot;, style=&quot;yellow&quot;)
            return False

        # Get authentication token
        token = get_current_token()
        if not token:
            console.print(&quot;âš ï¸  No authentication token found for log sending&quot;, style=&quot;yellow&quot;)
            return False

        # Prepare API request
        url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{resolved_org_id}/claude_code/session/{session_id}/log&quot;
        headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}
        payload = {&quot;log&quot;: log_entry}

        # Make API request
        response = requests.post(url, json=payload, headers=headers, timeout=30)

        if response.status_code == 200:
            return True
        else:
            error_msg = f&quot;HTTP {response.status_code}&quot;
            try:
                error_detail = response.json().get(&quot;detail&quot;, response.text)
                error_msg = f&quot;{error_msg}: {error_detail}&quot;
            except Exception:
                error_msg = f&quot;{error_msg}: {response.text}&quot;

            console.print(f&quot;âš ï¸  Failed to send log entry: {error_msg}&quot;, style=&quot;yellow&quot;)
            return False

    except requests.RequestException as e:
        console.print(f&quot;âš ï¸  Network error sending log entry: {e}&quot;, style=&quot;yellow&quot;)
        return False
    except Exception as e:
        console.print(f&quot;âš ï¸  Unexpected error sending log entry: {e}&quot;, style=&quot;yellow&quot;)
        return False


def get_cli_rules(org_id: Optional[int] = None) -&gt; Optional[dict]:
    &quot;&quot;&quot;Fetch CLI rules from the API endpoint.

    Args:
        org_id: Organization ID (will be resolved if None)

    Returns:
        Dictionary containing organization_rules and user_custom_prompt, or None if failed
    &quot;&quot;&quot;
    try:
        # Resolve org_id
        resolved_org_id = resolve_org_id(org_id)
        if resolved_org_id is None:
            console.print(&quot;âš ï¸  Could not resolve organization ID for CLI rules&quot;, style=&quot;yellow&quot;)
            return None

        # Get authentication token
        token = get_current_token()
        if not token:
            console.print(&quot;âš ï¸  No authentication token found for CLI rules&quot;, style=&quot;yellow&quot;)
            return None

        # Prepare API request
        url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{resolved_org_id}/cli/rules&quot;
        headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}

        # Make API request
        response = requests.get(url, headers=headers, timeout=30)

        if response.status_code == 200:
            try:
                result = response.json()
                return result
            except json.JSONDecodeError as e:
                console.print(f&quot;âš ï¸  Invalid response format from CLI rules: {e}&quot;, style=&quot;yellow&quot;)
                return None
        else:
            error_msg = f&quot;HTTP {response.status_code}&quot;
            try:
                error_detail = response.json().get(&quot;detail&quot;, response.text)
                error_msg = f&quot;{error_msg}: {error_detail}&quot;
            except Exception:
                error_msg = f&quot;{error_msg}: {response.text}&quot;

            console.print(f&quot;âš ï¸  Failed to fetch CLI rules: {error_msg}&quot;, style=&quot;yellow&quot;)
            return None

    except requests.RequestException as e:
        console.print(f&quot;âš ï¸  Network error fetching CLI rules: {e}&quot;, style=&quot;yellow&quot;)
        return None
    except Exception as e:
        console.print(f&quot;âš ï¸  Unexpected error fetching CLI rules: {e}&quot;, style=&quot;yellow&quot;)
        return None


def write_session_hook_data(session_id: str, org_id: Optional[int] = None) -&gt; str:
    &quot;&quot;&quot;Write session data for Claude hook and create session via API.

    This function is called by the Claude hook to both write session data locally
    and create the session in the backend API.

    Args:
        session_id: The session ID
        org_id: Organization ID

    Returns:
        JSON string to write to the session file
    &quot;&quot;&quot;
    # Create session in backend API
    agent_run_id = create_claude_session(session_id, org_id)

    # Prepare session data
    session_data = {&quot;session_id&quot;: session_id, &quot;agent_run_id&quot;: agent_run_id, &quot;org_id&quot;: resolve_org_id(org_id)}

    return json.dumps(session_data, indent=2)</file><file path="src/codegen/cli/commands/claude/hooks.py">&quot;&quot;&quot;Claude hooks management for session tracking.&quot;&quot;&quot;

import json
import os
from pathlib import Path

from codegen.cli.commands.claude.quiet_console import console

CLAUDE_CONFIG_DIR = Path.home() / &quot;.claude&quot;
HOOKS_CONFIG_FILE = CLAUDE_CONFIG_DIR / &quot;settings.json&quot;
CODEGEN_DIR = Path.home() / &quot;.codegen&quot;
SESSION_FILE = CODEGEN_DIR / &quot;claude-session.json&quot;
SESSION_LOG_FILE = CODEGEN_DIR / &quot;claude-sessions.log&quot;


def ensure_claude_hook() -&gt; bool:
    &quot;&quot;&quot;Ensure the Claude hooks are properly set up for session tracking.

    This function will:
    1. Create necessary directories
    2. Create the hooks file if it doesn&apos;t exist
    3. Always overwrite any existing SessionStart and Stop hooks with our commands

    Returns:
        bool: True if hooks were set up successfully, False otherwise
    &quot;&quot;&quot;
    try:
        # Create .codegen directory if it doesn&apos;t exist
        CODEGEN_DIR.mkdir(exist_ok=True)

        # Clean up old session file if it exists
        if SESSION_FILE.exists():
            SESSION_FILE.unlink()

        # Ensure Claude config directory exists
        CLAUDE_CONFIG_DIR.mkdir(exist_ok=True)

        # Build the shell command that will create session via API and write session data

        # Build the stop hook command to mark session COMPLETE
        stop_hook_script_path = Path(__file__).parent / &quot;config&quot; / &quot;claude_session_stop_hook.py&quot;
        stop_hook_command = f&quot;python3 {stop_hook_script_path}&quot;

        # Build the user prompt submit hook to set status ACTIVE
        active_hook_script_path = Path(__file__).parent / &quot;config&quot; / &quot;claude_session_active_hook.py&quot;
        active_hook_command = f&quot;python3 {active_hook_script_path}&quot;

        # Read existing hooks config or create new one
        hooks_config = {}
        if HOOKS_CONFIG_FILE.exists():
            try:
                with open(HOOKS_CONFIG_FILE) as f:
                    content = f.read().strip()
                    if content:
                        hooks_config = json.loads(content)
                    else:
                        console.print(&quot;âš ï¸  Hooks file is empty, creating new configuration&quot;, style=&quot;yellow&quot;)
            except (OSError, json.JSONDecodeError) as e:
                console.print(f&quot;âš ï¸  Could not read existing hooks file: {e}, creating new one&quot;, style=&quot;yellow&quot;)

        # Ensure proper structure exists
        if &quot;hooks&quot; not in hooks_config:
            hooks_config[&quot;hooks&quot;] = {}
        if &quot;Stop&quot; not in hooks_config[&quot;hooks&quot;]:
            hooks_config[&quot;hooks&quot;][&quot;Stop&quot;] = []
        if &quot;UserPromptSubmit&quot; not in hooks_config[&quot;hooks&quot;]:
            hooks_config[&quot;hooks&quot;][&quot;UserPromptSubmit&quot;] = []

        # Get existing hooks
        stop_hooks = hooks_config[&quot;hooks&quot;][&quot;Stop&quot;]
        active_hooks = hooks_config[&quot;hooks&quot;][&quot;UserPromptSubmit&quot;]

        # Check if we&apos;re replacing existing hooks
        replaced_existing = (len(stop_hooks) &gt; 0) or (len(active_hooks) &gt; 0)

        # Create the new hook structures (following Claude&apos;s format)
        new_stop_hook_group = {&quot;hooks&quot;: [{&quot;type&quot;: &quot;command&quot;, &quot;command&quot;: stop_hook_command}]}
        new_active_hook_group = {&quot;hooks&quot;: [{&quot;type&quot;: &quot;command&quot;, &quot;command&quot;: active_hook_command}]}

        # Replace all existing hooks with our single hook per event
        hooks_config[&quot;hooks&quot;][&quot;Stop&quot;] = [new_stop_hook_group]
        hooks_config[&quot;hooks&quot;][&quot;UserPromptSubmit&quot;] = [new_active_hook_group]

        # Write updated config with nice formatting
        with open(HOOKS_CONFIG_FILE, &quot;w&quot;) as f:
            json.dump(hooks_config, f, indent=2)
            f.write(&quot;\n&quot;)  # Add trailing newline for cleaner file

        if replaced_existing:
            console.print(&quot;âœ… Replaced existing Claude hooks (SessionStart, Stop)&quot;, style=&quot;green&quot;)
        else:
            console.print(&quot;âœ… Registered new Claude hooks (SessionStart, Stop)&quot;, style=&quot;green&quot;)
        console.print(f&quot;   Stop hook:  {stop_hook_command}&quot;, style=&quot;dim&quot;)
        console.print(f&quot;   Active hook:{&apos; &apos; if len(&apos;Active hook:&apos;) &lt; 1 else &apos;&apos;} {active_hook_command}&quot;, style=&quot;dim&quot;)

        # Verify the hook was written correctly
        try:
            with open(HOOKS_CONFIG_FILE) as f:
                verify_config = json.load(f)

            found_stop_hook = False
            for hook_group in verify_config.get(&quot;hooks&quot;, {}).get(&quot;Stop&quot;, []):
                for hook in hook_group.get(&quot;hooks&quot;, []):
                    if &quot;claude_session_stop_hook.py&quot; in hook.get(&quot;command&quot;, &quot;&quot;):
                        found_stop_hook = True
                        break
            found_active_hook = False
            for hook_group in verify_config.get(&quot;hooks&quot;, {}).get(&quot;UserPromptSubmit&quot;, []):
                for hook in hook_group.get(&quot;hooks&quot;, []):
                    if &quot;claude_session_active_hook.py&quot; in hook.get(&quot;command&quot;, &quot;&quot;):
                        found_active_hook = True
                        break

            if found_stop_hook and found_active_hook:
                console.print(&quot;âœ… Hook configuration verified&quot;, style=&quot;dim&quot;)
            else:
                console.print(&quot;âš ï¸  Hook was written but verification failed&quot;, style=&quot;yellow&quot;)
                return False

        except Exception as e:
            console.print(f&quot;âš ï¸  Could not verify hook configuration: {e}&quot;, style=&quot;yellow&quot;)
            return False

        return True

    except Exception as e:
        console.print(f&quot;âŒ Failed to set up Claude hook: {e}&quot;, style=&quot;red&quot;)
        return False


def cleanup_claude_hook() -&gt; None:
    &quot;&quot;&quot;Remove the Codegen Claude hooks from the hooks configuration.&quot;&quot;&quot;
    try:
        if not HOOKS_CONFIG_FILE.exists():
            return

        with open(HOOKS_CONFIG_FILE) as f:
            hooks_config = json.load(f)

        if &quot;hooks&quot; not in hooks_config:
            return

        session_start_hooks = hooks_config[&quot;hooks&quot;].get(&quot;SessionStart&quot;, [])
        stop_hooks = hooks_config[&quot;hooks&quot;].get(&quot;Stop&quot;, [])
        active_hooks = hooks_config[&quot;hooks&quot;].get(&quot;UserPromptSubmit&quot;, [])
        modified = False

        # Filter out any hook groups that contain our command
        new_session_hooks = []
        for hook_group in session_start_hooks:
            # Check if this group contains our hook
            contains_our_hook = False
            for hook in hook_group.get(&quot;hooks&quot;, []):
                if hook.get(&quot;command&quot;) and &quot;claude-session.json&quot; in hook.get(&quot;command&quot;, &quot;&quot;):
                    contains_our_hook = True
                    modified = True
                    break

            # Keep hook groups that don&apos;t contain our hook
            if not contains_our_hook:
                new_session_hooks.append(hook_group)

        # Update SessionStart hooks if we removed something
        if modified:
            hooks_config[&quot;hooks&quot;][&quot;SessionStart&quot;] = new_session_hooks

        # Now also remove Stop hook referencing our stop script
        new_stop_hooks = []
        for hook_group in stop_hooks:
            contains_stop = False
            for hook in hook_group.get(&quot;hooks&quot;, []):
                if hook.get(&quot;command&quot;) and &quot;claude_session_stop_hook.py&quot; in hook.get(&quot;command&quot;, &quot;&quot;):
                    contains_stop = True
                    break
            if not contains_stop:
                new_stop_hooks.append(hook_group)
            else:
                modified = True

        if stop_hooks is not None:
            hooks_config[&quot;hooks&quot;][&quot;Stop&quot;] = new_stop_hooks

        # Remove UserPromptSubmit hook referencing our active script
        new_active_hooks = []
        for hook_group in active_hooks:
            contains_active = False
            for hook in hook_group.get(&quot;hooks&quot;, []):
                if hook.get(&quot;command&quot;) and &quot;claude_session_active_hook.py&quot; in hook.get(&quot;command&quot;, &quot;&quot;):
                    contains_active = True
                    break
            if not contains_active:
                new_active_hooks.append(hook_group)
            else:
                modified = True

        if active_hooks is not None:
            hooks_config[&quot;hooks&quot;][&quot;UserPromptSubmit&quot;] = new_active_hooks

        # Write updated config if anything changed
        if modified:
            with open(HOOKS_CONFIG_FILE, &quot;w&quot;) as f:
                json.dump(hooks_config, f, indent=2)
                f.write(&quot;\n&quot;)  # Add trailing newline
            console.print(&quot;âœ… Removed Claude hooks&quot;, style=&quot;dim&quot;)

        # Clean up session files
        if SESSION_FILE.exists():
            SESSION_FILE.unlink()

    except Exception as e:
        console.print(f&quot;âš ï¸  Error cleaning up hook: {e}&quot;, style=&quot;yellow&quot;)


def get_codegen_url(session_id: str) -&gt; str:
    &quot;&quot;&quot;Get the Codegen URL for a session ID.&quot;&quot;&quot;
    # You can customize this based on your environment
    base_url = os.environ.get(&quot;CODEGEN_BASE_URL&quot;, &quot;https://codegen.com&quot;)
    # Use the format: codegen.com/claude-code/{session-id}
    return f&quot;{base_url}/claude-code/{session_id}&quot;</file><file path="src/codegen/cli/commands/claude/main.py">&quot;&quot;&quot;Claude Code command with session tracking.&quot;&quot;&quot;

import json
import os
import signal
import subprocess
import sys
import time

import requests
import typer
from rich import box
from rich.console import Console
from rich.panel import Panel

from codegen.cli.api.endpoints import API_ENDPOINT
from codegen.cli.auth.token_manager import get_current_token
from codegen.cli.commands.claude.claude_log_watcher import ClaudeLogWatcherManager
from codegen.cli.commands.claude.claude_session_api import (
    create_claude_session,
    generate_session_id,
    get_cli_rules,
    update_claude_session_status,
)
from codegen.cli.commands.claude.config.mcp_setup import add_codegen_mcp_server, cleanup_codegen_mcp_server
from codegen.cli.commands.claude.hooks import SESSION_FILE, cleanup_claude_hook, ensure_claude_hook, get_codegen_url
from codegen.cli.commands.claude.quiet_console import console
from codegen.cli.commands.claude.utils import resolve_claude_path
from codegen.cli.rich.spinners import create_spinner
from codegen.cli.utils.org import resolve_org_id
from codegen.cli.utils.repo import resolve_repo_id
from codegen.shared.logging.get_logger import get_logger

# Initialize logger
logger = get_logger(__name__)


def _get_session_context() -&gt; dict:
    &quot;&quot;&quot;Get session context for logging.&quot;&quot;&quot;
    try:
        from codegen.cli.telemetry.otel_setup import get_session_uuid

        return {&quot;session_id&quot;: get_session_uuid()}
    except ImportError:
        return {}


t_console = Console()


def _run_claude_background(resolved_org_id: int, prompt: str | None) -&gt; None:
    &quot;&quot;&quot;Create a background agent run with Claude context and exit.&quot;&quot;&quot;
    logger.info(
        &quot;Claude background run started&quot;,
        extra={&quot;operation&quot;: &quot;claude.background&quot;, &quot;org_id&quot;: resolved_org_id, &quot;prompt_length&quot;: len(prompt) if prompt else 0, &quot;command&quot;: &quot;codegen claude --background&quot;, **_get_session_context()},
    )

    start_time = time.time()
    token = get_current_token()
    if not token:
        logger.error(
            &quot;Claude background run failed - not authenticated&quot;, extra={&quot;operation&quot;: &quot;claude.background&quot;, &quot;org_id&quot;: resolved_org_id, &quot;error_type&quot;: &quot;not_authenticated&quot;, **_get_session_context()}
        )
        console.print(&quot;[red]Error:[/red] Not authenticated. Please run &apos;codegen login&apos; first.&quot;)
        raise typer.Exit(1)

    payload = {&quot;prompt&quot;: prompt or &quot;Start a Claude Code background session&quot;}

    spinner = create_spinner(&quot;Creating agent run...&quot;)
    spinner.start()
    try:
        headers = {
            &quot;Authorization&quot;: f&quot;Bearer {token}&quot;,
            &quot;Content-Type&quot;: &quot;application/json&quot;,
            &quot;x-codegen-client&quot;: &quot;codegen__claude_code&quot;,
        }
        url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{resolved_org_id}/agent/run&quot;
        response = requests.post(url, headers=headers, json=payload)
        response.raise_for_status()
        agent_run_data = response.json()

        duration_ms = (time.time() - start_time) * 1000
        run_id = agent_run_data.get(&quot;id&quot;, &quot;Unknown&quot;)
        status = agent_run_data.get(&quot;status&quot;, &quot;Unknown&quot;)

        logger.info(
            &quot;Claude background run created successfully&quot;,
            extra={&quot;operation&quot;: &quot;claude.background&quot;, &quot;org_id&quot;: resolved_org_id, &quot;agent_run_id&quot;: run_id, &quot;status&quot;: status, &quot;duration_ms&quot;: duration_ms, &quot;success&quot;: True, **_get_session_context()},
        )

    except Exception as e:
        duration_ms = (time.time() - start_time) * 1000
        logger.error(
            &quot;Claude background run failed&quot;,
            extra={
                &quot;operation&quot;: &quot;claude.background&quot;,
                &quot;org_id&quot;: resolved_org_id,
                &quot;error_type&quot;: type(e).__name__,
                &quot;error_message&quot;: str(e),
                &quot;duration_ms&quot;: duration_ms,
                &quot;success&quot;: False,
                **_get_session_context(),
            },
            exc_info=True,
        )
        raise
    finally:
        spinner.stop()

    run_id = agent_run_data.get(&quot;id&quot;, &quot;Unknown&quot;)
    status = agent_run_data.get(&quot;status&quot;, &quot;Unknown&quot;)
    web_url = agent_run_data.get(&quot;web_url&quot;, &quot;&quot;)

    result_lines = [
        f&quot;[cyan]Agent Run ID:[/cyan] {run_id}&quot;,
        f&quot;[cyan]Status:[/cyan]       {status}&quot;,
    ]
    if web_url:
        result_lines.append(f&quot;[cyan]Web URL:[/cyan]      {web_url}&quot;)

    t_console.print(
        Panel(
            &quot;\n&quot;.join(result_lines),
            title=&quot;ðŸ¤– [bold]Background Agent Run Created[/bold]&quot;,
            border_style=&quot;green&quot;,
            box=box.ROUNDED,
            padding=(1, 2),
        )
    )
    t_console.print(&quot;\n[dim]ðŸ’¡ Track progress with:[/dim] [cyan]codegen agents[/cyan]&quot;)
    if web_url:
        t_console.print(f&quot;[dim]ðŸŒ View in browser:[/dim]  [link]{web_url}[/link]&quot;)


def _run_claude_interactive(resolved_org_id: int, no_mcp: bool | None) -&gt; None:
    &quot;&quot;&quot;Launch Claude Code with session tracking and log watching.&quot;&quot;&quot;
    # Generate session ID for tracking
    session_id = generate_session_id()

    logger.info(
        &quot;Claude interactive session started&quot;,
        extra={&quot;operation&quot;: &quot;claude.interactive&quot;, &quot;org_id&quot;: resolved_org_id, &quot;claude_session_id&quot;: session_id, &quot;mcp_disabled&quot;: bool(no_mcp), &quot;command&quot;: &quot;codegen claude&quot;, **_get_session_context()},
    )

    console.print(f&quot;ðŸ†” Generated session ID: {session_id[:8]}...&quot;, style=&quot;dim&quot;)

    console.print(&quot;ðŸš€ Starting Claude Code with session tracking...&quot;, style=&quot;blue&quot;)
    console.print(f&quot;ðŸŽ¯ Organization ID: {resolved_org_id}&quot;, style=&quot;dim&quot;)

    # Set up environment variables for hooks to access session information
    os.environ[&quot;CODEGEN_CLAUDE_SESSION_ID&quot;] = session_id
    os.environ[&quot;CODEGEN_CLAUDE_ORG_ID&quot;] = str(resolved_org_id)

    # Proactively create the backend session as a fallback in case hooks fail
    try:
        agent_run_id = create_claude_session(session_id, resolved_org_id)
        if agent_run_id:
            console.print(&quot;âœ… Backend session created&quot;, style=&quot;green&quot;)
        else:
            console.print(&quot;âš ï¸  Could not create backend session at startup (will rely on hooks)&quot;, style=&quot;yellow&quot;)
    except Exception as e:
        agent_run_id = None
        console.print(f&quot;âš ï¸  Session creation error at startup: {e}&quot;, style=&quot;yellow&quot;)

    # Set up Claude hook for session tracking
    if not ensure_claude_hook():
        console.print(&quot;âš ï¸  Failed to set up session tracking hook&quot;, style=&quot;yellow&quot;)

    # Write session context file for downstream hooks and tools (after hook setup)
    try:
        SESSION_FILE.parent.mkdir(exist_ok=True)
        session_payload = {
            &quot;session_id&quot;: session_id,
            &quot;agent_run_id&quot;: agent_run_id,
            &quot;org_id&quot;: resolved_org_id,
            &quot;hook_event&quot;: &quot;Startup&quot;,
        }
        with open(SESSION_FILE, &quot;w&quot;) as f:
            json.dump(session_payload, f, indent=2)
            f.write(&quot;\n&quot;)
        console.print(&quot;ðŸ“ Wrote session file to ~/.codegen/claude-session.json&quot;, style=&quot;dim&quot;)
    except Exception as e:
        console.print(f&quot;âš ï¸  Could not write session file: {e}&quot;, style=&quot;yellow&quot;)

    # Initialize log watcher manager
    log_watcher_manager = ClaudeLogWatcherManager()

    # Resolve Claude CLI path (we already checked it exists in the main claude() function)
    claude_path = resolve_claude_path()
    if not claude_path:
        # This should not happen since we check earlier, but handle it just in case
        logger.error(
            &quot;Claude CLI not found in interactive mode&quot;,
            extra={&quot;operation&quot;: &quot;claude.interactive&quot;, &quot;org_id&quot;: resolved_org_id, &quot;claude_session_id&quot;: session_id, &quot;error_type&quot;: &quot;claude_cli_not_found&quot;, **_get_session_context()},
        )
        console.print(&quot;âŒ Claude Code CLI not found.&quot;, style=&quot;red&quot;)
        update_claude_session_status(session_id, &quot;ERROR&quot;, resolved_org_id)
        raise typer.Exit(1)

    console.print(f&quot;ðŸ” Using Claude CLI at: {claude_path}&quot;, style=&quot;blue&quot;)
    try:
        test_result = subprocess.run([claude_path, &quot;--version&quot;], capture_output=True, text=True, timeout=10)
        if test_result.returncode == 0:
            console.print(f&quot;âœ… Claude Code found: {test_result.stdout.strip()}&quot;, style=&quot;green&quot;)
        else:
            console.print(f&quot;âš ï¸  Claude Code test failed with code {test_result.returncode}&quot;, style=&quot;yellow&quot;)
            if test_result.stderr:
                console.print(f&quot;Error: {test_result.stderr.strip()}&quot;, style=&quot;red&quot;)
    except subprocess.TimeoutExpired:
        console.print(&quot;âš ï¸  Claude Code version check timed out&quot;, style=&quot;yellow&quot;)
    except Exception as e:
        console.print(f&quot;âš ï¸  Claude Code test error: {e}&quot;, style=&quot;yellow&quot;)

    # If MCP endpoint provided, register MCP server via Claude CLI before launch
    if not no_mcp:
        # Resolve repository ID if available
        repo_id = resolve_repo_id()
        if repo_id:
            console.print(f&quot;ðŸŽ¯ Repository ID: {repo_id}&quot;, style=&quot;dim&quot;)
        add_codegen_mcp_server(org_id=resolved_org_id, repo_id=repo_id)

    console.print(&quot;ðŸ”µ Starting Claude Code session...&quot;, style=&quot;blue&quot;)

    try:
        # Fetch CLI rules for system prompt
        console.print(&quot;ðŸ“‹ Fetching CLI rules...&quot;, style=&quot;blue&quot;)
        cli_rules = get_cli_rules(resolved_org_id)

        # Build Claude command
        claude_cmd = [claude_path, &quot;--session-id&quot;, session_id]

        # Add system prompt if CLI rules were fetched successfully
        if cli_rules:
            system_prompt_parts = []

            # Add organization rules if available
            if cli_rules.get(&quot;organization_rules&quot;):
                system_prompt_parts.append(&quot;Organization Rules:&quot;)
                system_prompt_parts.append(cli_rules[&quot;organization_rules&quot;])

            # Add user custom prompt if available
            if cli_rules.get(&quot;user_custom_prompt&quot;):
                if system_prompt_parts:  # Add separator if we already have org rules
                    system_prompt_parts.append(&quot;\n&quot;)
                system_prompt_parts.append(&quot;User Custom Prompt:&quot;)
                system_prompt_parts.append(cli_rules[&quot;user_custom_prompt&quot;])

            # Combine all parts into system prompt
            if system_prompt_parts:
                system_prompt = &quot;\n&quot;.join(system_prompt_parts)
                claude_cmd.extend([&quot;--append-system-prompt&quot;, system_prompt])
                console.print(&quot;âœ… Added CLI rules to system prompt&quot;, style=&quot;green&quot;)
            else:
                console.print(&quot;âš ï¸  CLI rules response was empty&quot;, style=&quot;yellow&quot;)
        else:
            console.print(&quot;âš ï¸  Could not fetch CLI rules, continuing without system prompt&quot;, style=&quot;yellow&quot;)

        # Launch Claude Code with our session ID
        console.print(f&quot;ðŸš€ Launching Claude Code with session ID: {session_id[:8]}...&quot;, style=&quot;blue&quot;)

        url = get_codegen_url(session_id)
        console.print(f&quot;\nðŸ”µ Codegen URL: {url}\n&quot;, style=&quot;bold blue&quot;)

        process = subprocess.Popen(claude_cmd)

        # Start log watcher for the session
        console.print(&quot;ðŸ“‹ Starting log watcher...&quot;, style=&quot;blue&quot;)
        log_watcher_started = log_watcher_manager.start_watcher(
            session_id=session_id,
            org_id=resolved_org_id,
            poll_interval=1.0,
            on_log_entry=None,
        )

        if not log_watcher_started:
            console.print(&quot;âš ï¸  Failed to start log watcher&quot;, style=&quot;yellow&quot;)

        # Handle Ctrl+C gracefully
        def signal_handler(signum, frame):
            console.print(&quot;\nðŸ›‘ Stopping Claude Code...&quot;, style=&quot;yellow&quot;)
            log_watcher_manager.stop_all_watchers()
            process.terminate()
            cleanup_claude_hook()
            cleanup_codegen_mcp_server()
            update_claude_session_status(session_id, &quot;COMPLETE&quot;, resolved_org_id)
            sys.exit(0)

        signal.signal(signal.SIGINT, signal_handler)

        # Wait for Claude Code to finish
        returncode = process.wait()

        # Handle session completion based on exit code
        session_status = &quot;COMPLETE&quot; if returncode == 0 else &quot;ERROR&quot;
        update_claude_session_status(session_id, session_status, resolved_org_id)

        if returncode != 0:
            logger.error(
                &quot;Claude interactive session failed&quot;,
                extra={
                    &quot;operation&quot;: &quot;claude.interactive&quot;,
                    &quot;org_id&quot;: resolved_org_id,
                    &quot;claude_session_id&quot;: session_id,
                    &quot;exit_code&quot;: returncode,
                    &quot;session_status&quot;: session_status,
                    **_get_session_context(),
                },
            )
            console.print(f&quot;âŒ Claude Code exited with error code {returncode}&quot;, style=&quot;red&quot;)
        else:
            logger.info(
                &quot;Claude interactive session completed successfully&quot;,
                extra={
                    &quot;operation&quot;: &quot;claude.interactive&quot;,
                    &quot;org_id&quot;: resolved_org_id,
                    &quot;claude_session_id&quot;: session_id,
                    &quot;exit_code&quot;: returncode,
                    &quot;session_status&quot;: session_status,
                    **_get_session_context(),
                },
            )
            console.print(&quot;âœ… Claude Code finished successfully&quot;, style=&quot;green&quot;)

    except FileNotFoundError:
        logger.exception(
            &quot;Claude Code executable not found&quot;,
            extra={&quot;operation&quot;: &quot;claude.interactive&quot;, &quot;org_id&quot;: resolved_org_id, &quot;claude_session_id&quot;: session_id, &quot;error_type&quot;: &quot;claude_executable_not_found&quot;, **_get_session_context()},
        )
        console.print(&quot;âŒ Claude Code not found. Please install Claude Code first.&quot;, style=&quot;red&quot;)
        console.print(&quot;ðŸ’¡ Visit: https://claude.ai/download&quot;, style=&quot;dim&quot;)
        log_watcher_manager.stop_all_watchers()
        update_claude_session_status(session_id, &quot;ERROR&quot;, resolved_org_id)
        raise typer.Exit(1)
    except KeyboardInterrupt:
        logger.info(
            &quot;Claude interactive session interrupted by user&quot;,
            extra={
                &quot;operation&quot;: &quot;claude.interactive&quot;,
                &quot;org_id&quot;: resolved_org_id,
                &quot;claude_session_id&quot;: session_id,
                &quot;session_status&quot;: &quot;CANCELLED&quot;,
                &quot;exit_reason&quot;: &quot;user_interrupt&quot;,
                **_get_session_context(),
            },
        )
        console.print(&quot;\nðŸ›‘ Interrupted by user&quot;, style=&quot;yellow&quot;)
        log_watcher_manager.stop_all_watchers()
        update_claude_session_status(session_id, &quot;CANCELLED&quot;, resolved_org_id)
    except Exception as e:
        logger.error(
            &quot;Claude interactive session error&quot;,
            extra={
                &quot;operation&quot;: &quot;claude.interactive&quot;,
                &quot;org_id&quot;: resolved_org_id,
                &quot;claude_session_id&quot;: session_id,
                &quot;error_type&quot;: type(e).__name__,
                &quot;error_message&quot;: str(e),
                &quot;session_status&quot;: &quot;ERROR&quot;,
                **_get_session_context(),
            },
            exc_info=True,
        )
        console.print(f&quot;âŒ Error running Claude Code: {e}&quot;, style=&quot;red&quot;)
        log_watcher_manager.stop_all_watchers()
        update_claude_session_status(session_id, &quot;ERROR&quot;, resolved_org_id)
        raise typer.Exit(1)
    finally:
        # Clean up resources
        try:
            log_watcher_manager.stop_all_watchers()
        except Exception as e:
            console.print(f&quot;âš ï¸  Error stopping log watchers: {e}&quot;, style=&quot;yellow&quot;)

        cleanup_claude_hook()

        # Show final session info
        url = get_codegen_url(session_id)
        console.print(f&quot;\nðŸ”µ Session URL: {url}&quot;, style=&quot;bold blue&quot;)
        console.print(f&quot;ðŸ†” Session ID: {session_id}&quot;, style=&quot;dim&quot;)
        console.print(f&quot;ðŸŽ¯ Organization ID: {resolved_org_id}&quot;, style=&quot;dim&quot;)
        console.print(&quot;ðŸ’¡ Check your backend to see the session data&quot;, style=&quot;dim&quot;)


def claude(
    org_id: int | None = typer.Option(None, help=&quot;Organization ID (defaults to CODEGEN_ORG_ID/REPOSITORY_ORG_ID or auto-detect)&quot;),
    no_mcp: bool | None = typer.Option(False, &quot;--no-mcp&quot;, help=&quot;Disable Codegen&apos;s MCP server with additional capabilities over HTTP&quot;),
    background: str | None = typer.Option(None, &quot;--background&quot;, &quot;-b&quot;, help=&quot;Create a background agent run with this prompt instead of launching Claude Code&quot;),
):
    &quot;&quot;&quot;Run Claude Code with session tracking or create a background run.&quot;&quot;&quot;
    logger.info(
        &quot;Claude command invoked&quot;,
        extra={
            &quot;operation&quot;: &quot;claude.command&quot;,
            &quot;org_id&quot;: org_id,
            &quot;no_mcp&quot;: bool(no_mcp),
            &quot;is_background&quot;: background is not None,
            &quot;background_prompt_length&quot;: len(background) if background else 0,
            &quot;command&quot;: f&quot;codegen claude{&apos; --background&apos; if background else &apos;&apos;}&quot;,
            **_get_session_context(),
        },
    )

    # Check if Claude is installed for interactive mode (not needed for background mode)
    if background is None:
        claude_path = resolve_claude_path()
        if not claude_path:
            logger.error(
                &quot;Claude CLI not found&quot;,
                extra={&quot;operation&quot;: &quot;claude.command&quot;, &quot;error_type&quot;: &quot;claude_cli_not_found&quot;, **_get_session_context()},
            )
            # Use t_console (the visible console) for error messages instead of the quiet console
            t_console.print(&quot;\n[red bold]âŒ Claude Code Not Installed[/red bold]&quot;)
            t_console.print(&quot;\n[yellow]Claude Code CLI is not installed or cannot be found.[/yellow]&quot;)
            t_console.print(&quot;\n[bold]To install Claude Code:[/bold]&quot;)
            t_console.print(&quot;  â€¢ Install globally: [cyan]npm install -g @anthropic-ai/claude-code[/cyan]&quot;)
            t_console.print(&quot;  â€¢ Or run: [cyan]claude /migrate-installer[/cyan] for local installation&quot;)
            t_console.print(&quot;\n[dim]If you migrated a local install, ensure ~/.claude/local/claude exists[/dim]&quot;)
            t_console.print(&quot;[dim]or add it to your PATH.[/dim]&quot;)
            raise typer.Exit(1)

    # Resolve org_id early for session management
    resolved_org_id = resolve_org_id(org_id)
    if resolved_org_id is None:
        logger.error(&quot;Claude command failed - no org ID&quot;, extra={&quot;operation&quot;: &quot;claude.command&quot;, &quot;error_type&quot;: &quot;org_id_missing&quot;, **_get_session_context()})
        console.print(&quot;[red]Error:[/red] Organization ID not provided. Pass --org-id, set CODEGEN_ORG_ID, or REPOSITORY_ORG_ID.&quot;)
        raise typer.Exit(1)

    try:
        if background is not None:
            # Use the value from --background as the prompt
            final_prompt = background
            _run_claude_background(resolved_org_id, final_prompt)
            return

        _run_claude_interactive(resolved_org_id, no_mcp)

    except typer.Exit:
        # Let typer exits pass through without additional logging
        raise
    except Exception as e:
        logger.error(
            &quot;Claude command failed unexpectedly&quot;,
            extra={
                &quot;operation&quot;: &quot;claude.command&quot;,
                &quot;org_id&quot;: resolved_org_id,
                &quot;error_type&quot;: type(e).__name__,
                &quot;error_message&quot;: str(e),
                &quot;is_background&quot;: background is not None,
                **_get_session_context(),
            },
            exc_info=True,
        )
        raise</file><file path="src/codegen/cli/commands/claude/quiet_console.py">&quot;&quot;&quot;Silent console utilities for Claude CLI.

This module provides a shared Rich console instance that is silent by default
to avoid interfering with Claude&apos;s terminal UI.
&quot;&quot;&quot;

from __future__ import annotations

import io
import os
from rich.console import Console


def _create_console() -&gt; Console:
    &quot;&quot;&quot;Create a console instance.

    If CODEGEN_CLAUDE_VERBOSE is set to a truthy value, return a normal
    Console for debugging; otherwise, return a Console that writes to an
    in-memory buffer so nothing is emitted to stdout/stderr.
    &quot;&quot;&quot;
    verbose = os.environ.get(&quot;CODEGEN_CLAUDE_VERBOSE&quot;, &quot;&quot;).strip().lower()
    is_verbose = verbose in (&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;, &quot;on&quot;)

    if is_verbose:
        return Console()

    # Silent console: sink all output
    return Console(file=io.StringIO())


# Shared console used across Claude CLI modules
console = _create_console()</file><file path="src/codegen/cli/commands/claude/utils.py">&quot;&quot;&quot;Utility functions for Claude CLI integration.&quot;&quot;&quot;

import os
from shutil import which


def resolve_claude_path() -&gt; str | None:
    &quot;&quot;&quot;Resolve the path to the Claude Code CLI.

    Tries PATH first, then common local install locations created by `claude /migrate`.

    Returns:
        Path to the claude executable if found, None otherwise.
    &quot;&quot;&quot;
    # 1) Check system PATH first
    path_from_path = which(&quot;claude&quot;)
    if path_from_path:
        return path_from_path

    # 2) Check common local install locations
    home = os.path.expanduser(&quot;~&quot;)
    candidates = [
        # Local install created by `claude /migrate`
        os.path.join(home, &quot;.claude&quot;, &quot;local&quot;, &quot;claude&quot;),
        os.path.join(home, &quot;.claude&quot;, &quot;local&quot;, &quot;node_modules&quot;, &quot;.bin&quot;, &quot;claude&quot;),
        # Common global install locations
        &quot;/usr/local/bin/claude&quot;,
        &quot;/opt/homebrew/bin/claude&quot;,  # Homebrew on Apple Silicon
    ]

    for candidate in candidates:
        try:
            if os.path.isfile(candidate) and os.access(candidate, os.X_OK):
                return candidate
        except Exception:
            # Best-effort checks only; ignore filesystem errors
            pass

    return None</file><file path="src/codegen/cli/commands/config/main.py">import logging

import rich
import typer
from rich.table import Table

from codegen.cli.commands.config.telemetry import telemetry_app
from codegen.configs.constants import ENV_FILENAME, GLOBAL_ENV_FILE
from codegen.configs.user_config import UserConfig
from codegen.shared.logging.get_logger import get_logger
from codegen.shared.path import get_git_root_path

# Initialize logger for config commands
logger = get_logger(__name__)

# Create a Typer app for the config command
config_command = typer.Typer(help=&quot;Manage codegen configuration.&quot;)

# Add telemetry subcommands
config_command.add_typer(telemetry_app, name=&quot;telemetry&quot;)


@config_command.command(name=&quot;list&quot;)
def list_config():
    &quot;&quot;&quot;List current configuration values.&quot;&quot;&quot;
    logger.info(&quot;Config list command invoked&quot;, extra={&quot;operation&quot;: &quot;config.list&quot;, &quot;command&quot;: &quot;codegen config list&quot;})

    def flatten_dict(data: dict, prefix: str = &quot;&quot;) -&gt; dict:
        items = {}
        for key, value in data.items():
            full_key = f&quot;{prefix}{key}&quot; if prefix else key
            if isinstance(value, dict):
                # Always include dictionary fields, even if empty
                if not value:
                    items[full_key] = &quot;{}&quot;
                items.update(flatten_dict(value, f&quot;{full_key}.&quot;))
            else:
                items[full_key] = value
        return items

    config = _get_user_config()
    flat_config = flatten_dict(config.to_dict())
    sorted_items = sorted(flat_config.items(), key=lambda x: x[0])

    # Create table
    table = Table(title=&quot;Configuration Values&quot;, border_style=&quot;blue&quot;, show_header=True, title_justify=&quot;center&quot;)
    table.add_column(&quot;Key&quot;, style=&quot;cyan&quot;, no_wrap=True)
    table.add_column(&quot;Value&quot;, style=&quot;magenta&quot;)

    # Group items by prefix
    codebase_items = []
    repository_items = []
    other_items = []

    for key, value in sorted_items:
        prefix = key.split(&quot;_&quot;)[0].lower()
        if prefix == &quot;codebase&quot;:
            codebase_items.append((key, value))
        elif prefix == &quot;repository&quot;:
            repository_items.append((key, value))
        else:
            other_items.append((key, value))

    # Add codebase section
    if codebase_items:
        table.add_section()
        table.add_row(&quot;[bold yellow]Codebase[/bold yellow]&quot;, &quot;&quot;)
        for key, value in codebase_items:
            table.add_row(f&quot;  {key}&quot;, str(value))

    # Add repository section
    if repository_items:
        table.add_section()
        table.add_row(&quot;[bold yellow]Repository[/bold yellow]&quot;, &quot;&quot;)
        for key, value in repository_items:
            table.add_row(f&quot;  {key}&quot;, str(value))

    # Add other section
    if other_items:
        table.add_section()
        table.add_row(&quot;[bold yellow]Other[/bold yellow]&quot;, &quot;&quot;)
        for key, value in other_items:
            table.add_row(f&quot;  {key}&quot;, str(value))

    rich.print(table)


@config_command.command(name=&quot;get&quot;)
def get_config(key: str = typer.Argument(..., help=&quot;Configuration key to get&quot;)):
    &quot;&quot;&quot;Get a configuration value.&quot;&quot;&quot;
    logger.info(&quot;Config get command invoked&quot;, extra={&quot;operation&quot;: &quot;config.get&quot;, &quot;key&quot;: key, &quot;command&quot;: f&quot;codegen config get {key}&quot;})

    config = _get_user_config()
    if not config.has_key(key):
        logger.warning(&quot;Config key not found&quot;, extra={&quot;operation&quot;: &quot;config.get&quot;, &quot;key&quot;: key, &quot;error_type&quot;: &quot;key_not_found&quot;})
        rich.print(f&quot;[red]Error: Configuration key &apos;{key}&apos; not found[/red]&quot;)
        return

    value = config.get(key)
    # Don&apos;t log debug info for successful value retrieval - focus on user actions

    rich.print(f&quot;[cyan]{key}[/cyan]=[magenta]{value}[/magenta]&quot;)


@config_command.command(name=&quot;set&quot;)
def set_config(key: str = typer.Argument(..., help=&quot;Configuration key to set&quot;), value: str = typer.Argument(..., help=&quot;Configuration value to set&quot;)):
    &quot;&quot;&quot;Set a configuration value and write to .env&quot;&quot;&quot;
    config = _get_user_config()
    if not config.has_key(key):
        rich.print(f&quot;[red]Error: Configuration key &apos;{key}&apos; not found[/red]&quot;)
        return

    cur_value = config.get(key)
    if cur_value is None or str(cur_value).lower() != value.lower():
        try:
            config.set(key, value)
        except Exception as e:
            logging.exception(e)
            rich.print(f&quot;[red]{e}[/red]&quot;)
            return

    rich.print(f&quot;[green]Successfully set {key}=[magenta]{value}[/magenta] and saved to {ENV_FILENAME}[/green]&quot;)


def _get_user_config() -&gt; UserConfig:
    if (project_root := get_git_root_path()) is None:
        env_filepath = GLOBAL_ENV_FILE
    else:
        env_filepath = project_root / ENV_FILENAME

    return UserConfig(env_filepath)</file><file path="src/codegen/cli/commands/config/telemetry.py">&quot;&quot;&quot;Telemetry configuration commands.&quot;&quot;&quot;

import json
from pathlib import Path

import typer
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax
from rich.table import Table

from codegen.cli.telemetry import update_telemetry_consent
from codegen.configs.constants import GLOBAL_CONFIG_DIR, GLOBAL_ENV_FILE
from codegen.configs.models.telemetry import TelemetryConfig

console = Console()

# Create the telemetry sub-app
telemetry_app = typer.Typer(help=&quot;Manage telemetry settings&quot;)


@telemetry_app.command()
def enable():
    &quot;&quot;&quot;Enable telemetry data collection.&quot;&quot;&quot;
    update_telemetry_consent(enabled=True)


@telemetry_app.command()
def disable():
    &quot;&quot;&quot;Disable telemetry data collection.&quot;&quot;&quot;
    update_telemetry_consent(enabled=False)


@telemetry_app.command()
def status():
    &quot;&quot;&quot;Show current telemetry settings.&quot;&quot;&quot;
    telemetry = TelemetryConfig(env_filepath=GLOBAL_ENV_FILE)

    table = Table(title=&quot;Telemetry Settings&quot;, show_header=False)
    table.add_column(&quot;Setting&quot;, style=&quot;cyan&quot;)
    table.add_column(&quot;Value&quot;, style=&quot;white&quot;)

    table.add_row(&quot;Enabled&quot;, &quot;âœ… Yes&quot; if telemetry.enabled else &quot;âŒ No&quot;)
    table.add_row(&quot;Debug Mode&quot;, &quot;Yes&quot; if telemetry.debug else &quot;No&quot;)

    console.print(table)
    console.print(&quot;\n[dim]Telemetry helps us improve the CLI experience.[/dim]&quot;)
    console.print(&quot;[dim]No personal information or source code is collected.[/dim]&quot;)


@telemetry_app.command()
def debug(
    enable: bool = typer.Option(None, &quot;--enable/--disable&quot;, help=&quot;Enable or disable debug mode&quot;),
    show_logs: bool = typer.Option(False, &quot;--logs&quot;, help=&quot;Show recent debug logs&quot;),
    clear: bool = typer.Option(False, &quot;--clear&quot;, help=&quot;Clear debug logs&quot;),
):
    &quot;&quot;&quot;Manage telemetry debug mode and logs.&quot;&quot;&quot;
    telemetry = TelemetryConfig(env_filepath=GLOBAL_ENV_FILE)
    debug_dir = GLOBAL_CONFIG_DIR / &quot;telemetry_debug&quot;

    # Handle enable/disable
    if enable is not None:
        telemetry.debug = enable
        telemetry.write_to_file(GLOBAL_ENV_FILE)

        # Refresh logging configuration to immediately apply the debug mode change
        try:
            from codegen.shared.logging.get_logger import refresh_telemetry_config

            refresh_telemetry_config()
        except ImportError:
            pass  # Logging refresh not available

        console.print(f&quot;[green]âœ“ Debug mode {&apos;enabled&apos; if enable else &apos;disabled&apos;}[/green]&quot;)
        if enable:
            console.print(f&quot;[dim]Debug logs will be written to: {debug_dir}[/dim]&quot;)
            console.print(&quot;[dim]Console logging will now be enabled for all CLI operations[/dim]&quot;)
        else:
            console.print(&quot;[dim]Console logging will now be disabled for CLI operations[/dim]&quot;)

    # Handle clear
    if clear:
        if debug_dir.exists():
            import shutil

            shutil.rmtree(debug_dir)
            console.print(&quot;[green]âœ“ Debug logs cleared[/green]&quot;)
        else:
            console.print(&quot;[yellow]No debug logs to clear[/yellow]&quot;)
        return

    # Handle show logs
    if show_logs:
        if not debug_dir.exists():
            console.print(&quot;[yellow]No debug logs found[/yellow]&quot;)
            return

        # Find most recent session file
        session_files = sorted(debug_dir.glob(&quot;session_*.jsonl&quot;), reverse=True)
        if not session_files:
            console.print(&quot;[yellow]No debug sessions found[/yellow]&quot;)
            return

        latest_file = session_files[0]
        console.print(f&quot;\n[cyan]Latest session:[/cyan] {latest_file.name}&quot;)

        # Read and display spans
        with open(latest_file) as f:
            spans = []
            for line in f:
                data = json.loads(line)
                if data[&quot;type&quot;] == &quot;span&quot;:
                    spans.append(data)

        if not spans:
            console.print(&quot;[yellow]No spans recorded in this session[/yellow]&quot;)
            return

        # Create table
        table = Table(title=f&quot;Telemetry Spans ({len(spans)} total)&quot;)
        table.add_column(&quot;Operation&quot;, style=&quot;cyan&quot;)
        table.add_column(&quot;Duration (ms)&quot;, style=&quot;green&quot;)
        table.add_column(&quot;Status&quot;, style=&quot;yellow&quot;)
        table.add_column(&quot;Key Attributes&quot;, style=&quot;white&quot;)

        for span in spans[-10:]:  # Show last 10 spans
            duration = f&quot;{span.get(&apos;duration_ms&apos;, 0):.2f}&quot; if span.get(&quot;duration_ms&quot;) else &quot;N/A&quot;
            status = span[&quot;status&quot;][&quot;status_code&quot;]

            # Extract key attributes
            attrs = span.get(&quot;attributes&quot;, {})
            key_attrs = []
            for key in [&quot;cli.command.name&quot;, &quot;cli.operation.name&quot;, &quot;event.name&quot;]:
                if key in attrs:
                    key_attrs.append(f&quot;{key.split(&apos;.&apos;)[-1]}: {attrs[key]}&quot;)

            table.add_row(span[&quot;name&quot;], duration, status, &quot;\n&quot;.join(key_attrs[:2]) if key_attrs else &quot;&quot;)

        console.print(table)
        console.print(f&quot;\n[dim]Full logs available at: {latest_file}[/dim]&quot;)

    # If no action specified, show current status
    if enable is None and not show_logs and not clear:
        console.print(f&quot;Debug mode: {&apos;[green]Enabled[/green]&apos; if telemetry.debug else &apos;[red]Disabled[/red]&apos;}&quot;)
        if debug_dir.exists():
            log_count = len(list(debug_dir.glob(&quot;session_*.jsonl&quot;)))
            console.print(f&quot;Debug sessions: {log_count}&quot;)
            console.print(f&quot;Debug directory: {debug_dir}&quot;)


@telemetry_app.callback(invoke_without_command=True)
def telemetry_callback(ctx: typer.Context):
    &quot;&quot;&quot;Manage telemetry settings.&quot;&quot;&quot;
    if ctx.invoked_subcommand is None:
        # If no subcommand is provided, show status
        status()</file><file path="src/codegen/cli/commands/init/main.py">from pathlib import Path

import rich
import typer

from codegen.cli.auth.session import CodegenSession
from codegen.cli.rich.codeblocks import format_command
from codegen.shared.logging.get_logger import get_logger
from codegen.shared.path import get_git_root_path

# Initialize logger
logger = get_logger(__name__)


def init(
    path: str | None = typer.Option(None, help=&quot;Path within a git repository. Defaults to the current directory.&quot;),
    token: str | None = typer.Option(None, help=&quot;Access token for the git repository. Required for full functionality.&quot;),
    language: str | None = typer.Option(None, help=&quot;Override automatic language detection (python or typescript)&quot;),
    fetch_docs: bool = typer.Option(False, &quot;--fetch-docs&quot;, help=&quot;Fetch docs and examples (requires auth)&quot;),
):
    &quot;&quot;&quot;Initialize or update the Codegen folder.&quot;&quot;&quot;
    logger.info(&quot;Init command started&quot;, extra={&quot;operation&quot;: &quot;init&quot;, &quot;path&quot;: path, &quot;language&quot;: language, &quot;fetch_docs&quot;: fetch_docs, &quot;has_token&quot;: bool(token)})

    # Validate language option
    if language and language.lower() not in [&quot;python&quot;, &quot;typescript&quot;]:
        logger.error(&quot;Invalid language specified&quot;, extra={&quot;operation&quot;: &quot;init&quot;, &quot;language&quot;: language, &quot;error_type&quot;: &quot;invalid_language&quot;})
        rich.print(f&quot;[bold red]Error:[/bold red] Invalid language &apos;{language}&apos;. Must be &apos;python&apos; or &apos;typescript&apos;.&quot;)
        raise typer.Exit(1)

    # Print a message if not in a git repo
    path_obj = Path.cwd() if path is None else Path(path)
    repo_path = get_git_root_path(path_obj)
    rich.print(f&quot;Found git repository at: {repo_path}&quot;)

    if repo_path is None:
        logger.error(&quot;Not in a git repository&quot;, extra={&quot;operation&quot;: &quot;init&quot;, &quot;path&quot;: str(path_obj), &quot;error_type&quot;: &quot;not_git_repo&quot;})
        rich.print(f&quot;\n[bold red]Error:[/bold red] Path={path_obj} is not in a git repository&quot;)
        rich.print(&quot;[white]Please run this command from within a git repository.[/white]&quot;)
        rich.print(&quot;\n[dim]To initialize a new git repository:[/dim]&quot;)
        rich.print(format_command(&quot;git init&quot;))
        rich.print(format_command(&quot;codegen init&quot;))
        raise typer.Exit(1)

    # At this point, repo_path is guaranteed to be not None
    assert repo_path is not None

    # Session creation details not needed in logs

    session = CodegenSession(repo_path=repo_path, git_token=token)
    if language:
        session.config.repository.language = language.upper()
        session.config.save()
        # Language override details included in completion log

    action = &quot;Updating&quot; if session.existing else &quot;Initializing&quot;

    logger.info(
        &quot;Codegen session created&quot;,
        extra={&quot;operation&quot;: &quot;init&quot;, &quot;repo_path&quot;: str(repo_path), &quot;action&quot;: action.lower(), &quot;existing&quot;: session.existing, &quot;language&quot;: getattr(session.config.repository, &quot;language&quot;, None)},
    )

    # Create the codegen directory
    codegen_dir = session.codegen_dir
    codegen_dir.mkdir(parents=True, exist_ok=True)

    logger.info(
        &quot;Init completed successfully&quot;,
        extra={
            &quot;operation&quot;: &quot;init&quot;,
            &quot;repo_path&quot;: str(repo_path),
            &quot;codegen_dir&quot;: str(codegen_dir),
            &quot;action&quot;: action.lower(),
            &quot;language&quot;: getattr(session.config.repository, &quot;language&quot;, None),
            &quot;fetch_docs&quot;: fetch_docs,
        },
    )

    # Print success message
    rich.print(f&quot;âœ… {action} complete\n&quot;)
    rich.print(f&quot;Codegen workspace initialized at: [bold]{codegen_dir}[/bold]&quot;)

    # Print next steps
    rich.print(&quot;\n[bold]What&apos;s next?[/bold]\n&quot;)
    rich.print(&quot;1. Create a function:&quot;)
    rich.print(format_command(&apos;codegen create my-function . -d &quot;describe what you want to do&quot;&apos;))
    rich.print(&quot;2. Run it:&quot;)
    rich.print(format_command(&quot;codegen run my-function --apply-local&quot;))</file><file path="src/codegen/cli/commands/init/render.py">from pathlib import Path


def get_success_message(codegen_dir: Path, docs_dir: Path, examples_dir: Path) -&gt; str:
    &quot;&quot;&quot;Get the success message to display after initialization.&quot;&quot;&quot;
    return &quot;&quot;&quot;ðŸ“ .codegen configuration folder created:
   [dim]codemods/[/dim]                  Your codemod implementations
   [dim].venv/[/dim]                     Python virtual environment (gitignored)
   [dim]codegen-system-prompt.txt[/dim]  AI system prompt (gitignored)&quot;&quot;&quot;</file><file path="src/codegen/cli/commands/integrations/__init__.py">&quot;&quot;&quot;Integrations command module.&quot;&quot;&quot;</file><file path="src/codegen/cli/commands/integrations/main.py">&quot;&quot;&quot;Integrations command for the Codegen CLI.&quot;&quot;&quot;

import webbrowser

import requests
import typer
from rich.console import Console
from rich.table import Table

from codegen.cli.api.endpoints import API_ENDPOINT
from codegen.cli.auth.token_manager import get_current_token
from codegen.cli.rich.spinners import create_spinner
from codegen.cli.utils.org import resolve_org_id
from codegen.cli.utils.url import generate_webapp_url

console = Console()

# Create the integrations app
integrations_app = typer.Typer(help=&quot;Manage Codegen integrations&quot;)


@integrations_app.command(&quot;list&quot;)
def list_integrations(org_id: int | None = typer.Option(None, help=&quot;Organization ID (defaults to CODEGEN_ORG_ID/REPOSITORY_ORG_ID or auto-detect)&quot;)):
    &quot;&quot;&quot;List organization integrations from the Codegen API.&quot;&quot;&quot;
    # Get the current token
    token = get_current_token()
    if not token:
        console.print(&quot;[red]Error:[/red] Not authenticated. Please run &apos;codegen login&apos; first.&quot;)
        raise typer.Exit(1)

    try:
        # Resolve org id
        resolved_org_id = resolve_org_id(org_id)
        if resolved_org_id is None:
            console.print(&quot;[red]Error:[/red] Organization ID not provided. Pass --org-id, set CODEGEN_ORG_ID, or REPOSITORY_ORG_ID.&quot;)
            raise typer.Exit(1)

        # Make API request to list integrations with spinner
        spinner = create_spinner(&quot;Fetching organization integrations...&quot;)
        spinner.start()

        try:
            headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}
            url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{resolved_org_id}/integrations&quot;
            response = requests.get(url, headers=headers)
            response.raise_for_status()
            response_data = response.json()
        finally:
            spinner.stop()

        # Extract integrations from the response structure
        integrations_data = response_data.get(&quot;integrations&quot;, [])
        organization_name = response_data.get(&quot;organization_name&quot;, &quot;Unknown&quot;)
        total_active = response_data.get(&quot;total_active_integrations&quot;, 0)

        if not integrations_data:
            console.print(&quot;[yellow]No integrations found.[/yellow]&quot;)
            return

        # Create a table to display integrations
        table = Table(
            title=f&quot;Integrations for {organization_name}&quot;,
            border_style=&quot;blue&quot;,
            show_header=True,
            title_justify=&quot;center&quot;,
        )
        table.add_column(&quot;Integration&quot;, style=&quot;cyan&quot;, no_wrap=True)
        table.add_column(&quot;Status&quot;, style=&quot;white&quot;, justify=&quot;center&quot;)
        table.add_column(&quot;Type&quot;, style=&quot;magenta&quot;)
        table.add_column(&quot;Details&quot;, style=&quot;dim&quot;)

        # Add integrations to table
        for integration in integrations_data:
            integration_type = integration.get(&quot;integration_type&quot;, &quot;Unknown&quot;)
            active = integration.get(&quot;active&quot;, False)
            token_id = integration.get(&quot;token_id&quot;)
            installation_id = integration.get(&quot;installation_id&quot;)
            metadata = integration.get(&quot;metadata&quot;, {})

            # Status with emoji
            status = &quot;âœ… Active&quot; if active else &quot;âŒ Inactive&quot;

            # Determine integration category
            if integration_type.endswith(&quot;_user&quot;):
                category = &quot;User Token&quot;
            elif integration_type.endswith(&quot;_app&quot;):
                category = &quot;App Install&quot;
            elif integration_type in [&quot;github&quot;, &quot;slack_app&quot;, &quot;linear_app&quot;]:
                category = &quot;App Install&quot;
            else:
                category = &quot;Token-based&quot;

            # Build details string
            details = []
            if token_id:
                details.append(f&quot;Token ID: {token_id}&quot;)
            if installation_id:
                details.append(f&quot;Install ID: {installation_id}&quot;)
            if metadata and isinstance(metadata, dict):
                for key, value in metadata.items():
                    if key == &quot;webhook_secret&quot;:
                        details.append(f&quot;{key}: ***secret***&quot;)
                    else:
                        details.append(f&quot;{key}: {value}&quot;)

            details_str = &quot;, &quot;.join(details) if details else &quot;No details&quot;
            if len(details_str) &gt; 50:
                details_str = details_str[:47] + &quot;...&quot;

            table.add_row(integration_type.replace(&quot;_&quot;, &quot; &quot;).title(), status, category, details_str)

        console.print(table)
        console.print(f&quot;\n[green]Total: {len(integrations_data)} integrations ({total_active} active)[/green]&quot;)

    except requests.RequestException as e:
        console.print(f&quot;[red]Error fetching integrations:[/red] {e}&quot;, style=&quot;bold red&quot;)
        raise typer.Exit(1)
    except Exception as e:
        console.print(f&quot;[red]Unexpected error:[/red] {e}&quot;, style=&quot;bold red&quot;)
        raise typer.Exit(1)


@integrations_app.command(&quot;add&quot;)
def add_integration():
    &quot;&quot;&quot;Open the Codegen integrations page in your browser to add new integrations.&quot;&quot;&quot;
    console.print(&quot;ðŸŒ Opening Codegen integrations page...&quot;, style=&quot;bold blue&quot;)

    # Generate the web URL using the environment-aware utility
    web_url = generate_webapp_url(&quot;integrations&quot;)

    try:
        webbrowser.open(web_url)
        console.print(f&quot;âœ… Opened [link]{web_url}[/link] in your browser&quot;, style=&quot;green&quot;)
        console.print(&quot;ðŸ’¡ You can add new integrations from the web interface&quot;, style=&quot;dim&quot;)
    except Exception as e:
        console.print(f&quot;âŒ Failed to open browser: {e}&quot;, style=&quot;red&quot;)
        console.print(f&quot;ðŸ”— Please manually visit: {web_url}&quot;, style=&quot;yellow&quot;)


# Default callback for the integrations app
@integrations_app.callback(invoke_without_command=True)
def integrations_callback(ctx: typer.Context):
    &quot;&quot;&quot;Manage Codegen integrations.&quot;&quot;&quot;
    if ctx.invoked_subcommand is None:
        # If no subcommand is provided, run list by default
        list_integrations(org_id=None)</file><file path="src/codegen/cli/commands/login/main.py">import typer

from codegen.cli.auth.login import login_routine
from codegen.cli.auth.token_manager import get_current_token
from codegen.shared.logging.get_logger import get_logger

# Initialize logger
logger = get_logger(__name__)


def _get_session_context() -&gt; dict:
    &quot;&quot;&quot;Get session context for logging.&quot;&quot;&quot;
    try:
        from codegen.cli.telemetry.otel_setup import get_session_uuid

        return {&quot;session_id&quot;: get_session_uuid()}
    except ImportError:
        return {}


def login(token: str | None = typer.Option(None, help=&quot;API token for authentication&quot;)):
    &quot;&quot;&quot;Store authentication token.&quot;&quot;&quot;
    extra = {&quot;operation&quot;: &quot;auth.login&quot;, &quot;has_provided_token&quot;: bool(token), &quot;command&quot;: &quot;codegen login&quot;, **_get_session_context()}
    logger.info(&quot;Login command invoked&quot;, extra=extra)

    # Check if already authenticated
    current_token = get_current_token()
    if current_token:
        logger.debug(&quot;User already authenticated&quot;, extra={&quot;operation&quot;: &quot;auth.login&quot;, &quot;already_authenticated&quot;: True, **_get_session_context()})
        pass  # Just proceed silently with re-authentication

    try:
        login_routine(token)
        logger.info(&quot;Login completed successfully&quot;, extra={&quot;operation&quot;: &quot;auth.login&quot;, &quot;success&quot;: True, **_get_session_context()})
    except Exception as e:
        logger.error(&quot;Login failed&quot;, extra={&quot;operation&quot;: &quot;auth.login&quot;, &quot;error_type&quot;: type(e).__name__, &quot;error_message&quot;: str(e), &quot;success&quot;: False, **_get_session_context()}, exc_info=True)
        raise</file><file path="src/codegen/cli/commands/logout/main.py">import rich

from codegen.cli.auth.token_manager import TokenManager
from codegen.shared.logging.get_logger import get_logger

# Initialize logger
logger = get_logger(__name__)


def logout():
    &quot;&quot;&quot;Clear stored authentication token.&quot;&quot;&quot;
    logger.info(&quot;Logout command invoked&quot;, extra={&quot;operation&quot;: &quot;auth.logout&quot;, &quot;command&quot;: &quot;codegen logout&quot;})

    try:
        token_manager = TokenManager()
        token_manager.clear_token()
        logger.info(&quot;Logout completed successfully&quot;, extra={&quot;operation&quot;: &quot;auth.logout&quot;, &quot;success&quot;: True})
        rich.print(&quot;Successfully logged out&quot;)
    except Exception as e:
        logger.error(&quot;Logout failed&quot;, extra={&quot;operation&quot;: &quot;auth.logout&quot;, &quot;error_type&quot;: type(e).__name__, &quot;error_message&quot;: str(e), &quot;success&quot;: False}, exc_info=True)
        raise</file><file path="src/codegen/cli/commands/org/__init__.py">&quot;&quot;&quot;Organization management command.&quot;&quot;&quot;

from .main import org

__all__ = [&quot;org&quot;]</file><file path="src/codegen/cli/commands/org/main.py">&quot;&quot;&quot;Organization management command for switching between organizations.&quot;&quot;&quot;

import os

import typer
from rich.console import Console

from codegen.cli.auth.token_manager import get_cached_organizations, get_current_token
from codegen.cli.commands.org.tui import OrgSelectorApp

console = Console()


def org(
    set_default: int | None = typer.Option(None, &quot;--set-default&quot;, &quot;-s&quot;, help=&quot;Set default organization ID&quot;),
    list_orgs: bool = typer.Option(False, &quot;--list&quot;, &quot;-l&quot;, help=&quot;List available organizations&quot;),
):
    &quot;&quot;&quot;Manage and switch between organizations.&quot;&quot;&quot;
    # Check if user is authenticated
    token = get_current_token()
    if not token:
        console.print(&quot;[red]Error:[/red] Not authenticated. Please run &apos;codegen login&apos; first.&quot;)
        raise typer.Exit(1)

    # Get cached organizations
    cached_orgs = get_cached_organizations()
    if not cached_orgs:
        console.print(&quot;[red]Error:[/red] No organizations found in cache. Please run &apos;codegen login&apos; to refresh.&quot;)
        raise typer.Exit(1)

    # Handle list mode
    if list_orgs:
        _list_organizations(cached_orgs)
        return

    # Handle set default mode
    if set_default is not None:
        _set_default_organization(set_default, cached_orgs)
        return

    # No flags provided, launch TUI
    _run_org_selector_tui()


def _list_organizations(cached_orgs: list[dict]) -&gt; None:
    &quot;&quot;&quot;List all available organizations.&quot;&quot;&quot;
    from rich.table import Table

    table = Table(title=&quot;Available Organizations&quot;)
    table.add_column(&quot;ID&quot;, style=&quot;cyan&quot;, no_wrap=True)
    table.add_column(&quot;Name&quot;, style=&quot;green&quot;)

    for org in cached_orgs:
        table.add_row(str(org[&quot;id&quot;]), org[&quot;name&quot;])

    console.print(table)


def _set_default_organization(org_id: int, cached_orgs: list[dict]) -&gt; None:
    &quot;&quot;&quot;Set the default organization via environment variable.&quot;&quot;&quot;
    # Check if org ID exists in cache
    org_found = None
    for org in cached_orgs:
        if org[&quot;id&quot;] == org_id:
            org_found = org
            break

    if not org_found:
        available_orgs = &quot;, &quot;.join([f&quot;{org[&apos;name&apos;]} ({org[&apos;id&apos;]})&quot; for org in cached_orgs])
        console.print(f&quot;[red]Error:[/red] Organization ID {org_id} not found in your accessible organizations.&quot;)
        console.print(f&quot;[yellow]Available organizations:[/yellow] {available_orgs}&quot;)
        raise typer.Exit(1)

    # Set the environment variable
    os.environ[&quot;CODEGEN_ORG_ID&quot;] = str(org_id)
    
    # Try to update .env file if it exists
    env_file_path = &quot;.env&quot;
    if os.path.exists(env_file_path):
        _update_env_file(env_file_path, &quot;CODEGEN_ORG_ID&quot;, str(org_id))
        console.print(f&quot;[green]âœ“ Updated {env_file_path} with CODEGEN_ORG_ID={org_id}[/green]&quot;)
    else:
        console.print(f&quot;[yellow]Info:[/yellow] No .env file found. Set environment variable manually:&quot;)
        console.print(f&quot;[cyan]export CODEGEN_ORG_ID={org_id}[/cyan]&quot;)

    console.print(f&quot;[green]âœ“ Default organization set to:[/green] {org_found[&apos;name&apos;]} ({org_id})&quot;)


def _update_env_file(file_path: str, key: str, value: str) -&gt; None:
    &quot;&quot;&quot;Update or add an environment variable in the .env file.&quot;&quot;&quot;
    lines = []
    key_found = False

    # Read existing lines
    try:
        with open(file_path) as f:
            lines = f.readlines()
    except FileNotFoundError:
        pass

    # Ensure all lines end with newline
    for i, line in enumerate(lines):
        if not line.endswith(&apos;\n&apos;):
            lines[i] = line + &apos;\n&apos;

    # Update existing key or note if we need to add it
    for i, line in enumerate(lines):
        if line.strip().startswith(f&quot;{key}=&quot;):
            lines[i] = f&quot;{key}={value}\n&quot;
            key_found = True
            break

    # Add new key if not found
    if not key_found:
        lines.append(f&quot;{key}={value}\n&quot;)

    # Write back to file
    with open(file_path, &quot;w&quot;) as f:
        f.writelines(lines)


def _run_org_selector_tui() -&gt; None:
    &quot;&quot;&quot;Launch the organization selector TUI.&quot;&quot;&quot;
    try:
        app = OrgSelectorApp()
        app.run()
    except Exception as e:
        console.print(f&quot;[red]Error launching TUI:[/red] {e}&quot;)
        raise typer.Exit(1)</file><file path="src/codegen/cli/commands/org/tui.py">&quot;&quot;&quot;Organization selector TUI using Textual - Fixed version.&quot;&quot;&quot;

import os

from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Container, Vertical
from textual.screen import Screen
from textual.widgets import DataTable, Footer, Header, Static

from codegen.cli.auth.token_manager import get_cached_organizations, get_current_org_id
from codegen.cli.utils.org import resolve_org_id


class OrgSelectorTUI(Screen):
    &quot;&quot;&quot;TUI for selecting and switching organizations.&quot;&quot;&quot;

    BINDINGS = [
        Binding(&quot;escape,ctrl+c&quot;, &quot;quit&quot;, &quot;Quit&quot;, priority=True),
        Binding(&quot;enter&quot;, &quot;select_org&quot;, &quot;Select&quot;, show=True),
        Binding(&quot;q&quot;, &quot;quit&quot;, &quot;Quit&quot;, show=True),
    ]

    def __init__(self):
        super().__init__()
        self.organizations = get_cached_organizations() or []
        self.current_org_id = get_current_org_id()

    def compose(self) -&gt; ComposeResult:
        &quot;&quot;&quot;Create child widgets for the app.&quot;&quot;&quot;
        yield Header()
        
        if not self.organizations:
            yield Container(
                Static(&quot;âš ï¸  No organizations found. Please run &apos;codegen login&apos; first.&quot;, classes=&quot;warning-message&quot;), 
                id=&quot;no-orgs-warning&quot;
            )
        else:
            with Vertical():
                yield Static(&quot;ðŸ¢ Select Your Organization&quot;, classes=&quot;title&quot;)
                yield Static(&quot;Use â†‘â†“ to navigate, Enter to select, Q/Esc to quit&quot;, classes=&quot;help&quot;)
                
                table = DataTable(id=&quot;orgs-table&quot;, cursor_type=&quot;row&quot;)
                table.add_columns(&quot;Current&quot;, &quot;ID&quot;, &quot;Organization Name&quot;)
                
                # Get the actual current org ID (checks environment variables first)
                actual_current_org_id = resolve_org_id()
                
                for org in self.organizations:
                    org_id = org[&quot;id&quot;]
                    org_name = org[&quot;name&quot;]
                    is_current = &quot;â—&quot; if org_id == actual_current_org_id else &quot; &quot;
                    
                    table.add_row(is_current, str(org_id), org_name, key=str(org_id))
                
                yield table
                
                yield Static(
                    &quot;\nðŸ’¡ Selecting an organization will update your CODEGEN_ORG_ID environment variable.&quot;, 
                    classes=&quot;help&quot;
                )
        
        yield Footer()

    def on_mount(self) -&gt; None:
        &quot;&quot;&quot;Called when the screen is mounted.&quot;&quot;&quot;
        # Set focus on the table if it exists
        if self.organizations:
            try:
                table = self.query_one(&quot;#orgs-table&quot;, DataTable)
                table.focus()
            except Exception:
                pass

    def on_data_table_row_selected(self, event: DataTable.RowSelected) -&gt; None:
        &quot;&quot;&quot;Handle DataTable row selection (Enter key).&quot;&quot;&quot;
        if event.data_table.id == &quot;orgs-table&quot;:
            self._handle_org_selection()

    def action_select_org(self) -&gt; None:
        &quot;&quot;&quot;Select the highlighted organization (fallback action).&quot;&quot;&quot;
        self._handle_org_selection()

    def _handle_org_selection(self) -&gt; None:
        &quot;&quot;&quot;Handle organization selection logic.&quot;&quot;&quot;
        if not self.organizations:
            self.notify(&quot;âŒ No organizations available&quot;, severity=&quot;error&quot;)
            return

        try:
            table = self.query_one(&quot;#orgs-table&quot;, DataTable)
            
            if table.cursor_row is not None and table.cursor_row &lt; len(self.organizations):
                # Get the selected organization directly from the cursor position
                selected_org = self.organizations[table.cursor_row]
                selected_org_id = selected_org[&quot;id&quot;]

                # Set the organization
                self._set_organization(selected_org_id, selected_org[&quot;name&quot;])
            else:
                self.notify(f&quot;âŒ Invalid cursor position: {table.cursor_row}/{len(self.organizations)}&quot;, severity=&quot;error&quot;)
        except Exception as e:
            self.notify(f&quot;âŒ Error in select org: {e}&quot;, severity=&quot;error&quot;)

    def _set_organization(self, org_id: int, org_name: str) -&gt; None:
        &quot;&quot;&quot;Set the selected organization as default.&quot;&quot;&quot;
        # Set environment variable
        os.environ[&quot;CODEGEN_ORG_ID&quot;] = str(org_id)
        
        # Try to update .env file
        env_updated = self._update_env_file(org_id)
        
        if env_updated:
            self.notify(f&quot;âœ“ Set default organization: {org_name} (ID: {org_id})&quot;)
            self.notify(&quot;âœ“ Updated .env file with CODEGEN_ORG_ID&quot;)
        else:
            self.notify(f&quot;âœ“ Set organization: {org_name} (ID: {org_id})&quot;)
            self.notify(&quot;â„¹  Add &apos;export CODEGEN_ORG_ID={org_id}&apos; to your shell for persistence&quot;)
        
        # Wait a moment for user to see the notifications, then close
        self.set_timer(2.0, self._close_screen)

    def _update_env_file(self, org_id: int) -&gt; bool:
        &quot;&quot;&quot;Update the .env file with the new organization ID.&quot;&quot;&quot;
        env_file_path = &quot;.env&quot;
        
        try:
            lines = []
            key_found = False

            # Read existing lines if file exists
            if os.path.exists(env_file_path):
                with open(env_file_path) as f:
                    lines = f.readlines()

            # Ensure all lines end with newline
            for i, line in enumerate(lines):
                if not line.endswith(&apos;\n&apos;):
                    lines[i] = line + &apos;\n&apos;

            # Update existing CODEGEN_ORG_ID or note that we need to add it
            for i, line in enumerate(lines):
                if line.strip().startswith(&quot;CODEGEN_ORG_ID=&quot;):
                    lines[i] = f&quot;CODEGEN_ORG_ID={org_id}\n&quot;
                    key_found = True
                    break

            # Add new line if not found
            if not key_found:
                lines.append(f&quot;CODEGEN_ORG_ID={org_id}\n&quot;)

            # Write back to file
            with open(env_file_path, &quot;w&quot;) as f:
                f.writelines(lines)
            
            return True
            
        except Exception:
            return False

    def _close_screen(self) -&gt; None:
        &quot;&quot;&quot;Close the screen.&quot;&quot;&quot;
        try:
            # Pop ourselves from the screen stack
            self.app.pop_screen()
        except Exception:
            # Fallback - try to dismiss the screen
            self.dismiss()

    def action_quit(self) -&gt; None:
        &quot;&quot;&quot;Quit the application or close the screen.&quot;&quot;&quot;
        self._close_screen()


class OrgSelectorApp(App):
    &quot;&quot;&quot;Standalone app wrapper for the organization selector.&quot;&quot;&quot;
    
    CSS_PATH = &quot;../../tui/codegen_theme.tcss&quot;  # Use custom Codegen theme
    TITLE = &quot;Organization Selector - Codegen CLI&quot;
    BINDINGS = [
        Binding(&quot;escape,ctrl+c&quot;, &quot;quit&quot;, &quot;Quit&quot;, priority=True),
        Binding(&quot;enter&quot;, &quot;select_org&quot;, &quot;Select&quot;, show=True),
        Binding(&quot;q&quot;, &quot;quit&quot;, &quot;Quit&quot;, show=True),
    ]

    def __init__(self):
        super().__init__()
        self.organizations = get_cached_organizations() or []
        self.current_org_id = get_current_org_id()

    def compose(self) -&gt; ComposeResult:
        &quot;&quot;&quot;Create child widgets for the app.&quot;&quot;&quot;
        yield Header()
        
        if not self.organizations:
            yield Container(
                Static(&quot;âš ï¸  No organizations found. Please run &apos;codegen login&apos; first.&quot;, classes=&quot;warning-message&quot;), 
                id=&quot;no-orgs-warning&quot;
            )
        else:
            with Vertical():
                yield Static(&quot;ðŸ¢ Select Your Organization&quot;, classes=&quot;title&quot;)
                yield Static(&quot;Use â†‘â†“ to navigate, Enter to select, Q/Esc to quit&quot;, classes=&quot;help&quot;)
                
                table = DataTable(id=&quot;orgs-table&quot;, cursor_type=&quot;row&quot;)
                table.add_columns(&quot;Current&quot;, &quot;ID&quot;, &quot;Organization Name&quot;)
                
                # Get the actual current org ID (checks environment variables first)
                actual_current_org_id = resolve_org_id()
                
                for org in self.organizations:
                    org_id = org[&quot;id&quot;]
                    org_name = org[&quot;name&quot;]
                    is_current = &quot;â—&quot; if org_id == actual_current_org_id else &quot; &quot;
                    
                    table.add_row(is_current, str(org_id), org_name, key=str(org_id))
                
                yield table
                
                yield Static(
                    &quot;\nðŸ’¡ Selecting an organization will update your CODEGEN_ORG_ID environment variable.&quot;, 
                    classes=&quot;help&quot;
                )
        
        yield Footer()

    def on_mount(self) -&gt; None:
        &quot;&quot;&quot;Called when the app mounts.&quot;&quot;&quot;
        # Set focus on the table if it exists
        if self.organizations:
            try:
                table = self.query_one(&quot;#orgs-table&quot;, DataTable)
                table.focus()
            except Exception:
                pass

    def on_data_table_row_selected(self, event: DataTable.RowSelected) -&gt; None:
        &quot;&quot;&quot;Handle DataTable row selection (Enter key).&quot;&quot;&quot;
        if event.data_table.id == &quot;orgs-table&quot;:
            self._handle_org_selection()

    def action_select_org(self) -&gt; None:
        &quot;&quot;&quot;Select the highlighted organization (fallback action).&quot;&quot;&quot;
        self._handle_org_selection()

    def _handle_org_selection(self) -&gt; None:
        &quot;&quot;&quot;Handle organization selection logic.&quot;&quot;&quot;
        if not self.organizations:
            self.notify(&quot;âŒ No organizations available&quot;, severity=&quot;error&quot;)
            return

        try:
            table = self.query_one(&quot;#orgs-table&quot;, DataTable)
            
            if table.cursor_row is not None and table.cursor_row &lt; len(self.organizations):
                # Get the selected organization directly from the cursor position
                selected_org = self.organizations[table.cursor_row]
                selected_org_id = selected_org[&quot;id&quot;]

                # Set the organization
                self._set_organization(selected_org_id, selected_org[&quot;name&quot;])
            else:
                self.notify(f&quot;âŒ Invalid cursor position: {table.cursor_row}/{len(self.organizations)}&quot;, severity=&quot;error&quot;)
        except Exception as e:
            self.notify(f&quot;âŒ Error in select org: {e}&quot;, severity=&quot;error&quot;)

    def _set_organization(self, org_id: int, org_name: str) -&gt; None:
        &quot;&quot;&quot;Set the selected organization as default.&quot;&quot;&quot;
        # Set environment variable
        os.environ[&quot;CODEGEN_ORG_ID&quot;] = str(org_id)
        
        # Try to update .env file
        env_updated = self._update_env_file(org_id)
        
        if env_updated:
            self.notify(f&quot;âœ“ Set default organization: {org_name} (ID: {org_id})&quot;)
            self.notify(&quot;âœ“ Updated .env file with CODEGEN_ORG_ID&quot;)
        else:
            self.notify(f&quot;âœ“ Set organization: {org_name} (ID: {org_id})&quot;)
            self.notify(&quot;â„¹  Add &apos;export CODEGEN_ORG_ID={org_id}&apos; to your shell for persistence&quot;)
        
        # Wait a moment for user to see the notifications, then exit
        self.set_timer(2.0, self.exit)

    def _update_env_file(self, org_id: int) -&gt; bool:
        &quot;&quot;&quot;Update the .env file with the new organization ID.&quot;&quot;&quot;
        env_file_path = &quot;.env&quot;
        
        try:
            lines = []
            key_found = False

            # Read existing lines if file exists
            if os.path.exists(env_file_path):
                with open(env_file_path) as f:
                    lines = f.readlines()

            # Ensure all lines end with newline
            for i, line in enumerate(lines):
                if not line.endswith(&apos;\n&apos;):
                    lines[i] = line + &apos;\n&apos;

            # Update existing CODEGEN_ORG_ID or note that we need to add it
            for i, line in enumerate(lines):
                if line.strip().startswith(&quot;CODEGEN_ORG_ID=&quot;):
                    lines[i] = f&quot;CODEGEN_ORG_ID={org_id}\n&quot;
                    key_found = True
                    break

            # Add new line if not found
            if not key_found:
                lines.append(f&quot;CODEGEN_ORG_ID={org_id}\n&quot;)

            # Write back to file
            with open(env_file_path, &quot;w&quot;) as f:
                f.writelines(lines)
            
            return True
            
        except Exception:
            return False

    def action_quit(self) -&gt; None:
        &quot;&quot;&quot;Quit the application.&quot;&quot;&quot;
        self.exit()</file><file path="src/codegen/cli/commands/profile/main.py">&quot;&quot;&quot;Profile command for the Codegen CLI.&quot;&quot;&quot;

import requests
import typer
from rich.console import Console

from codegen.cli.api.endpoints import API_ENDPOINT
from codegen.cli.auth.token_manager import (
    get_cached_organizations,
    get_current_org_name,
    get_current_token,
    get_current_user_info,
    set_default_organization,
)
from codegen.cli.rich.spinners import create_spinner
from codegen.cli.utils.org import resolve_org_id
from codegen.cli.utils.simple_selector import simple_org_selector

console = Console()

# Create the profile Typer app
profile_app = typer.Typer(name=&quot;profile&quot;, help=&quot;Manage user profile and organization settings.&quot;)


def _get_profile_data() -&gt; dict:
    &quot;&quot;&quot;Get profile data (shared between commands).&quot;&quot;&quot;
    # Get the current token
    token = get_current_token()
    if not token:
        console.print(&quot;[red]Error:[/red] Not authenticated. Please run &apos;codegen login&apos; first.&quot;)
        raise typer.Exit(1)

    # Try to get stored user and org info first (fast, no API calls)
    user_info = get_current_user_info()
    org_name = get_current_org_name()
    org_id = resolve_org_id()  # This now uses stored data first

    # If we have stored data, use it directly
    if user_info and user_info.get(&quot;id&quot;):
        user_id = user_info.get(&quot;id&quot;, &quot;Unknown&quot;)
        full_name = user_info.get(&quot;full_name&quot;, &quot;&quot;)
        email = user_info.get(&quot;email&quot;, &quot;&quot;)
        github_username = user_info.get(&quot;github_username&quot;, &quot;&quot;)
        role = &quot;Member&quot;  # Default role for stored data
    else:
        # Fall back to API call if no stored data
        spinner = create_spinner(&quot;Fetching user profile info...&quot;)
        spinner.start()
        try:
            headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}
            user_response = requests.get(f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/users/me&quot;, headers=headers)
            user_response.raise_for_status()
            user_data = user_response.json()

            user_id = user_data.get(&quot;id&quot;, &quot;Unknown&quot;)
            full_name = user_data.get(&quot;full_name&quot;, &quot;&quot;)
            email = user_data.get(&quot;email&quot;, &quot;&quot;)
            github_username = user_data.get(&quot;github_username&quot;, &quot;&quot;)
            role = user_data.get(&quot;role&quot;, &quot;Member&quot;)
        except requests.RequestException as e:
            spinner.stop()
            console.print(f&quot;[red]Error:[/red] Failed to fetch profile information: {e}&quot;)
            raise typer.Exit(1)
        finally:
            spinner.stop()

    # If no stored org name but we have an org_id, try to fetch it
    if org_id and not org_name:
        spinner = create_spinner(&quot;Fetching organization info...&quot;)
        spinner.start()
        try:
            headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}
            orgs_response = requests.get(f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations&quot;, headers=headers)
            orgs_response.raise_for_status()
            orgs_data = orgs_response.json()

            # Find the organization by ID
            orgs = orgs_data.get(&quot;items&quot;, [])
            for org in orgs:
                if org.get(&quot;id&quot;) == org_id:
                    org_name = org.get(&quot;name&quot;)
                    break
        except requests.RequestException:
            # Ignore errors for org name lookup - not critical
            pass
        finally:
            spinner.stop()

    return {
        &quot;user_id&quot;: user_id,
        &quot;full_name&quot;: full_name,
        &quot;email&quot;: email,
        &quot;github_username&quot;: github_username,
        &quot;role&quot;: role,
        &quot;org_name&quot;: org_name,
        &quot;org_id&quot;: org_id,
    }


@profile_app.callback(invoke_without_command=True)
def profile_main(ctx: typer.Context):
    &quot;&quot;&quot;Display organization selection dropdown or profile info.&quot;&quot;&quot;
    if ctx.invoked_subcommand is None:
        # No subcommand - show organization selector
        _show_org_selector()


@profile_app.command(&quot;list&quot;)
def profile_list():
    &quot;&quot;&quot;List all available organizations.&quot;&quot;&quot;
    data = _get_profile_data()
    cached_orgs = get_cached_organizations()

    if not cached_orgs:
        console.print(&quot;[yellow]No organizations found. Please run &apos;codegen login&apos; first.[/yellow]&quot;)
        return

    # Build profile information
    if data[&quot;user_id&quot;] != &quot;Unknown&quot;:
        console.print(f&quot;[dim]User ID:[/dim]  [blue]{data[&apos;user_id&apos;]}[/blue]&quot;)
    if data[&quot;full_name&quot;]:
        console.print(f&quot;[dim]Name:[/dim]     [blue]{data[&apos;full_name&apos;]}[/blue]&quot;)
    if data[&quot;email&quot;]:
        console.print(f&quot;[dim]Email:[/dim]    [blue]{data[&apos;email&apos;]}[/blue]&quot;)
    if data[&quot;github_username&quot;]:
        console.print(f&quot;[dim]GitHub:[/dim]   [blue]{data[&apos;github_username&apos;]}[/blue]&quot;)
    if data[&quot;role&quot;]:
        console.print(f&quot;[dim]Role:[/dim]     [blue]{data[&apos;role&apos;]}[/blue]&quot;)

    # Current organization
    if data[&quot;org_name&quot;]:
        console.print(f&quot;[dim]Current Org:[/dim] [blue]{data[&apos;org_name&apos;]} ({data[&apos;org_id&apos;]})[/blue]&quot;)
    elif data[&quot;org_id&quot;]:
        console.print(f&quot;[dim]Current Org:[/dim] [blue]Organization {data[&apos;org_id&apos;]}[/blue]&quot;)
    else:
        console.print(&quot;[dim]Current Org:[/dim] [yellow]Not configured[/yellow]&quot;)

    console.print()
    console.print(&quot;[dim]Available Organizations:[/dim]&quot;)

    for org in cached_orgs:
        org_id = org.get(&quot;id&quot;)
        org_name = org.get(&quot;name&quot;)
        is_current = &quot; [green](current)[/green]&quot; if org_id == data[&quot;org_id&quot;] else &quot;&quot;
        console.print(f&quot;  â€¢ [blue]{org_name}[/blue] [dim](ID: {org_id})[/dim]{is_current}&quot;)


def _show_org_selector():
    &quot;&quot;&quot;Show the organization selector.&quot;&quot;&quot;
    cached_orgs = get_cached_organizations()

    if not cached_orgs:
        console.print(&quot;[red]Error:[/red] No organizations found. Please run &apos;codegen login&apos; first.&quot;)
        raise typer.Exit(1)

    if len(cached_orgs) == 1:
        # Only one org, set it as default
        org = cached_orgs[0]
        org_id = org.get(&quot;id&quot;)
        org_name = org.get(&quot;name&quot;)
        try:
            set_default_organization(org_id, org_name)
            console.print(f&quot;[green]âœ“[/green] Set default organization: {org_name} (ID: {org_id})&quot;)
        except Exception as e:
            console.print(f&quot;[red]Error:[/red] Failed to set default organization: {e}&quot;)
            raise typer.Exit(1)
        return

    # Multiple orgs - show simple selector
    current_org_id = resolve_org_id()
    console.print(&quot;[blue]Select your default organization:[/blue]&quot;)

    selected_org = simple_org_selector(organizations=cached_orgs, current_org_id=current_org_id, title=&quot;ðŸ‘¤ Select Default Organization&quot;)

    if selected_org:
        org_id = selected_org.get(&quot;id&quot;)
        org_name = selected_org.get(&quot;name&quot;)
        try:
            set_default_organization(org_id, org_name)
            console.print(f&quot;\n[green]âœ“ Set default organization:[/green] {org_name} (ID: {org_id})&quot;)
            console.print(&quot;[green]âœ“ Updated ~/.codegen/auth.json[/green]&quot;)
        except Exception as e:
            console.print(f&quot;\n[red]Error:[/red] Failed to set default organization: {e}&quot;)
            raise typer.Exit(1)
    else:
        console.print(&quot;\n[yellow]No organization selected.[/yellow]&quot;)


# For backward compatibility, export the profile function
def profile():
    &quot;&quot;&quot;Display organization selector (legacy function).&quot;&quot;&quot;
    _show_org_selector()</file><file path="src/codegen/cli/commands/repo/__init__.py">&quot;&quot;&quot;Repository management commands.&quot;&quot;&quot;

from .main import repo

__all__ = [&quot;repo&quot;]</file><file path="src/codegen/cli/commands/repo/main.py">&quot;&quot;&quot;Repository management command for managing repository configuration.&quot;&quot;&quot;

import typer
from rich.console import Console
from rich.table import Table

from codegen.cli.utils.repo import (
    get_current_repo_id, 
    get_repo_env_status, 
    set_repo_env_variable, 
    update_env_file_with_repo,
    clear_repo_env_variables,
    ensure_repositories_cached
)
from codegen.cli.auth.token_manager import get_current_token

console = Console()


def repo(
    set_default: int | None = typer.Option(None, &quot;--set-default&quot;, &quot;-s&quot;, help=&quot;Set default repository ID&quot;),
    clear: bool = typer.Option(False, &quot;--clear&quot;, &quot;-c&quot;, help=&quot;Clear repository configuration&quot;),
    list_config: bool = typer.Option(False, &quot;--list&quot;, &quot;-l&quot;, help=&quot;List current repository configuration&quot;),
    list_repos: bool = typer.Option(False, &quot;--list-repos&quot;, &quot;-lr&quot;, help=&quot;List available repositories&quot;),
):
    &quot;&quot;&quot;Manage repository configuration and environment variables.&quot;&quot;&quot;
    
    # Handle list repositories mode
    if list_repos:
        _list_repositories()
        return
    
    # Handle list config mode
    if list_config:
        _list_repo_config()
        return

    # Handle clear mode
    if clear:
        _clear_repo_config()
        return

    # Handle set default mode
    if set_default is not None:
        _set_default_repository(set_default)
        return

    # No flags provided, launch TUI
    _run_repo_selector_tui()


def _list_repo_config() -&gt; None:
    &quot;&quot;&quot;List current repository configuration.&quot;&quot;&quot;
    table = Table(title=&quot;Repository Configuration&quot;)
    table.add_column(&quot;Setting&quot;, style=&quot;cyan&quot;, no_wrap=True)
    table.add_column(&quot;Value&quot;, style=&quot;green&quot;)
    table.add_column(&quot;Status&quot;, style=&quot;yellow&quot;)

    # Current repository ID
    current_repo_id = get_current_repo_id()
    if current_repo_id:
        table.add_row(&quot;Current Repository ID&quot;, str(current_repo_id), &quot;âœ… Active&quot;)
    else:
        table.add_row(&quot;Current Repository ID&quot;, &quot;Not configured&quot;, &quot;âŒ Inactive&quot;)
    
    # Environment variables
    env_status = get_repo_env_status()
    for var_name, value in env_status.items():
        status = &quot;âœ… Set&quot; if value != &quot;Not set&quot; else &quot;âŒ Not set&quot;
        table.add_row(var_name, value, status)

    console.print(table)


def _list_repositories() -&gt; None:
    &quot;&quot;&quot;List all available repositories.&quot;&quot;&quot;
    # Check if user is authenticated
    token = get_current_token()
    if not token:
        console.print(&quot;[red]Error:[/red] Not authenticated. Please run &apos;codegen login&apos; first.&quot;)
        raise typer.Exit(1)

    # Get cached or fetch repositories
    repositories = ensure_repositories_cached()
    if not repositories:
        console.print(&quot;[red]Error:[/red] No repositories found.&quot;)
        raise typer.Exit(1)

    table = Table(title=&quot;Available Repositories&quot;)
    table.add_column(&quot;ID&quot;, style=&quot;cyan&quot;, no_wrap=True)
    table.add_column(&quot;Name&quot;, style=&quot;green&quot;)
    table.add_column(&quot;Description&quot;, style=&quot;dim&quot;)
    table.add_column(&quot;Current&quot;, style=&quot;yellow&quot;)

    current_repo_id = get_current_repo_id()
    
    for repo in repositories:
        repo_id = repo.get(&quot;id&quot;, &quot;Unknown&quot;)
        repo_name = repo.get(&quot;name&quot;, &quot;Unknown&quot;)
        repo_desc = repo.get(&quot;description&quot;, &quot;&quot;)
        is_current = &quot;â—&quot; if repo_id == current_repo_id else &quot;&quot;
        
        table.add_row(str(repo_id), repo_name, repo_desc, is_current)

    console.print(table)


def _set_default_repository(repo_id: int) -&gt; None:
    &quot;&quot;&quot;Set default repository ID.&quot;&quot;&quot;
    try:
        # Set in environment
        success = set_repo_env_variable(repo_id, &quot;CODEGEN_REPO_ID&quot;)
        if not success:
            console.print(&quot;[red]Error:[/red] Failed to set repository ID in environment.&quot;)
            raise typer.Exit(1)

        # Try to update .env file
        env_updated = update_env_file_with_repo(repo_id)
        
        if env_updated:
            console.print(f&quot;[green]âœ“[/green] Set default repository ID to: [cyan]{repo_id}[/cyan]&quot;)
            console.print(&quot;[green]âœ“[/green] Updated .env file with CODEGEN_REPO_ID&quot;)
        else:
            console.print(f&quot;[green]âœ“[/green] Set repository ID to: [cyan]{repo_id}[/cyan]&quot;)
            console.print(&quot;[yellow]â„¹[/yellow] Could not update .env file. Add &apos;export CODEGEN_REPO_ID={repo_id}&apos; to your shell for persistence&quot;)

    except Exception as e:
        console.print(f&quot;[red]Error:[/red] Failed to set default repository: {e}&quot;)
        raise typer.Exit(1)


def _clear_repo_config() -&gt; None:
    &quot;&quot;&quot;Clear repository configuration.&quot;&quot;&quot;
    try:
        clear_repo_env_variables()
        console.print(&quot;[green]âœ“[/green] Cleared repository configuration from environment variables&quot;)
        
        # Note: We don&apos;t automatically clear the .env file to avoid data loss
        console.print(&quot;[yellow]â„¹[/yellow] To permanently remove from .env file, manually delete the CODEGEN_REPO_ID line&quot;)
        
    except Exception as e:
        console.print(f&quot;[red]Error:[/red] Failed to clear repository configuration: {e}&quot;)
        raise typer.Exit(1)


def _run_repo_selector_tui() -&gt; None:
    &quot;&quot;&quot;Launch the repository selector TUI.&quot;&quot;&quot;
    try:
        from codegen.cli.commands.repo.tui import RepoSelectorApp
        
        app = RepoSelectorApp()
        app.run()
        
    except ImportError:
        console.print(&quot;[red]Error:[/red] Repository selector TUI not available&quot;)
        raise typer.Exit(1)
    except Exception as e:
        console.print(f&quot;[red]Error:[/red] Failed to launch repository selector: {e}&quot;)
        raise typer.Exit(1)</file><file path="src/codegen/cli/commands/repo/tui.py">&quot;&quot;&quot;Repository selector TUI using Textual.&quot;&quot;&quot;

import os

from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Container, Vertical
from textual.screen import Screen
from textual.widgets import DataTable, Footer, Header, Static

from codegen.cli.auth.token_manager import get_cached_repositories, get_current_token
from codegen.cli.utils.repo import (
    get_current_repo_id, 
    set_repo_env_variable,
    update_env_file_with_repo,
    ensure_repositories_cached
)
from codegen.cli.utils.org import resolve_org_id


class RepoSelectorTUI(Screen):
    &quot;&quot;&quot;TUI for selecting and switching repositories.&quot;&quot;&quot;

    BINDINGS = [
        Binding(&quot;escape,ctrl+c&quot;, &quot;quit&quot;, &quot;Quit&quot;, priority=True),
        Binding(&quot;enter&quot;, &quot;select_repo&quot;, &quot;Select&quot;, show=True),
        Binding(&quot;q&quot;, &quot;quit&quot;, &quot;Quit&quot;, show=True),
    ]

    def __init__(self):
        super().__init__()
        self.repositories = ensure_repositories_cached() or []
        self.current_repo_id = get_current_repo_id()

    def compose(self) -&gt; ComposeResult:
        &quot;&quot;&quot;Create child widgets for the app.&quot;&quot;&quot;
        yield Header()
        
        if not self.repositories:
            yield Container(
                Static(&quot;âš ï¸  No repositories found. Fetching repositories...&quot;, classes=&quot;warning-message&quot;), 
                id=&quot;no-repos-warning&quot;
            )
        else:
            with Vertical():
                yield Static(&quot;ðŸ—‚ï¸ Select Your Repository&quot;, classes=&quot;title&quot;)
                yield Static(&quot;Use â†‘â†“ to navigate, Enter to select, Q/Esc to quit&quot;, classes=&quot;help&quot;)
                
                table = DataTable(id=&quot;repos-table&quot;, cursor_type=&quot;row&quot;)
                table.add_columns(&quot;Current&quot;, &quot;ID&quot;, &quot;Repository Name&quot;)
                
                # Get the actual current repo ID (checks environment variables first)
                actual_current_repo_id = get_current_repo_id()
                
                for repo in self.repositories:
                    repo_id = repo[&quot;id&quot;]
                    repo_name = repo[&quot;name&quot;]
                    is_current = &quot;â—&quot; if repo_id == actual_current_repo_id else &quot; &quot;
                    
                    table.add_row(is_current, str(repo_id), repo_name, key=str(repo_id))
                
                yield table
                
                yield Static(
                    &quot;\nðŸ’¡ Selecting a repository will update your CODEGEN_REPO_ID environment variable.&quot;, 
                    classes=&quot;help&quot;
                )
        
        yield Footer()

    def on_mount(self) -&gt; None:
        &quot;&quot;&quot;Called when the screen is mounted.&quot;&quot;&quot;
        if self.repositories:
            try:
                table = self.query_one(&quot;#repos-table&quot;, DataTable)
                table.focus()
            except Exception:
                pass

    def on_data_table_row_selected(self, event: DataTable.RowSelected) -&gt; None:
        &quot;&quot;&quot;Handle DataTable row selection (Enter key).&quot;&quot;&quot;
        if event.data_table.id == &quot;repos-table&quot;:
            self._handle_repo_selection()

    def action_select_repo(self) -&gt; None:
        &quot;&quot;&quot;Select repository (fallback for direct key binding).&quot;&quot;&quot;
        self._handle_repo_selection()

    def _handle_repo_selection(self) -&gt; None:
        &quot;&quot;&quot;Handle repository selection logic.&quot;&quot;&quot;
        try:
            table = self.query_one(&quot;#repos-table&quot;, DataTable)
            if table.cursor_row is not None and table.cursor_row &lt; len(self.repositories):
                selected_repo = self.repositories[table.cursor_row]
                repo_id = selected_repo[&quot;id&quot;]
                repo_name = selected_repo[&quot;name&quot;]
                
                self._set_repository(repo_id, repo_name)
        except Exception as e:
            self.notify(f&quot;âŒ Error selecting repository: {e}&quot;, severity=&quot;error&quot;)

    def _set_repository(self, repo_id: int, repo_name: str) -&gt; None:
        &quot;&quot;&quot;Set the selected repository as the current one.&quot;&quot;&quot;
        # Update environment variable
        os.environ[&quot;CODEGEN_REPO_ID&quot;] = str(repo_id)
        
        # Try to update .env file
        env_updated = self._update_env_file(repo_id)
        
        if env_updated:
            self.notify(f&quot;âœ“ Set default repository: {repo_name} (ID: {repo_id})&quot;)
            self.notify(&quot;âœ“ Updated .env file with CODEGEN_REPO_ID&quot;)
        else:
            self.notify(f&quot;âœ“ Set repository: {repo_name} (ID: {repo_id})&quot;)
            self.notify(&quot;â„¹  Add &apos;export CODEGEN_REPO_ID={repo_id}&apos; to your shell for persistence&quot;)
        
        # Wait a moment for user to see the notifications, then exit
        self.set_timer(2.0, self._close_screen)

    def _update_env_file(self, repo_id: int) -&gt; bool:
        &quot;&quot;&quot;Update the .env file with the new repository ID.&quot;&quot;&quot;
        env_file_path = &quot;.env&quot;
        
        try:
            lines = []
            key_updated = False
            key_to_update = &quot;CODEGEN_REPO_ID&quot;
            
            # Read existing .env file if it exists
            if os.path.exists(env_file_path):
                with open(env_file_path, &quot;r&quot;) as f:
                    lines = f.readlines()
            
            # Update or add the key
            for i, line in enumerate(lines):
                if line.strip().startswith(f&quot;{key_to_update}=&quot;):
                    lines[i] = f&quot;{key_to_update}={repo_id}\n&quot;
                    key_updated = True
                    break
            
            # If key wasn&apos;t found, add it
            if not key_updated:
                if lines and not lines[-1].endswith(&apos;\n&apos;):
                    lines.append(&apos;\n&apos;)
                lines.append(f&quot;{key_to_update}={repo_id}\n&quot;)
            
            # Write back to file
            with open(env_file_path, &quot;w&quot;) as f:
                f.writelines(lines)
            
            return True
            
        except Exception:
            return False

    def _close_screen(self) -&gt; None:
        &quot;&quot;&quot;Close the screen.&quot;&quot;&quot;
        if hasattr(self.app, &apos;pop_screen&apos;):
            self.app.pop_screen()
        else:
            self.app.exit()

    def action_quit(self) -&gt; None:
        &quot;&quot;&quot;Quit the TUI.&quot;&quot;&quot;
        self._close_screen()


class RepoSelectorApp(App):
    &quot;&quot;&quot;Standalone app wrapper for the repository selector.&quot;&quot;&quot;
    
    CSS_PATH = &quot;../../tui/codegen_theme.tcss&quot;  # Use custom Codegen theme
    TITLE = &quot;Repository Selector - Codegen CLI&quot;
    BINDINGS = [
        Binding(&quot;escape,ctrl+c&quot;, &quot;quit&quot;, &quot;Quit&quot;, priority=True),
        Binding(&quot;enter&quot;, &quot;select_repo&quot;, &quot;Select&quot;, show=True),
        Binding(&quot;q&quot;, &quot;quit&quot;, &quot;Quit&quot;, show=True),
    ]

    def __init__(self):
        super().__init__()
        self.repositories = ensure_repositories_cached() or []
        self.current_repo_id = get_current_repo_id()

    def compose(self) -&gt; ComposeResult:
        &quot;&quot;&quot;Create child widgets for the app.&quot;&quot;&quot;
        yield Header()
        
        if not self.repositories:
            yield Container(
                Static(&quot;âš ï¸  No repositories found. Fetching repositories...&quot;, classes=&quot;warning-message&quot;), 
                id=&quot;no-repos-warning&quot;
            )
        else:
            with Vertical():
                yield Static(&quot;ðŸ—‚ï¸ Select Your Repository&quot;, classes=&quot;title&quot;)
                yield Static(&quot;Use â†‘â†“ to navigate, Enter to select, Q/Esc to quit&quot;, classes=&quot;help&quot;)
                
                table = DataTable(id=&quot;repos-table&quot;, cursor_type=&quot;row&quot;)
                table.add_columns(&quot;Current&quot;, &quot;ID&quot;, &quot;Repository Name&quot;)
                
                # Get the actual current repo ID (checks environment variables first)
                actual_current_repo_id = get_current_repo_id()
                
                for repo in self.repositories:
                    repo_id = repo[&quot;id&quot;]
                    repo_name = repo[&quot;name&quot;]
                    is_current = &quot;â—&quot; if repo_id == actual_current_repo_id else &quot; &quot;
                    
                    table.add_row(is_current, str(repo_id), repo_name, key=str(repo_id))
                
                yield table
                
                yield Static(
                    &quot;\nðŸ’¡ Selecting a repository will update your CODEGEN_REPO_ID environment variable.&quot;, 
                    classes=&quot;help&quot;
                )
        
        yield Footer()

    def on_mount(self) -&gt; None:
        &quot;&quot;&quot;Called when the app starts.&quot;&quot;&quot;
        if self.repositories:
            try:
                table = self.query_one(&quot;#repos-table&quot;, DataTable)
                table.focus()
            except Exception:
                pass

    def on_data_table_row_selected(self, event: DataTable.RowSelected) -&gt; None:
        &quot;&quot;&quot;Handle DataTable row selection (Enter key).&quot;&quot;&quot;
        if event.data_table.id == &quot;repos-table&quot;:
            self._handle_repo_selection()

    def action_select_repo(self) -&gt; None:
        &quot;&quot;&quot;Select repository (fallback for direct key binding).&quot;&quot;&quot;
        self._handle_repo_selection()

    def _handle_repo_selection(self) -&gt; None:
        &quot;&quot;&quot;Handle repository selection logic.&quot;&quot;&quot;
        try:
            table = self.query_one(&quot;#repos-table&quot;, DataTable)
            if table.cursor_row is not None and table.cursor_row &lt; len(self.repositories):
                selected_repo = self.repositories[table.cursor_row]
                repo_id = selected_repo[&quot;id&quot;]
                repo_name = selected_repo[&quot;name&quot;]
                
                self._set_repository(repo_id, repo_name)
        except Exception as e:
            self.notify(f&quot;âŒ Error selecting repository: {e}&quot;, severity=&quot;error&quot;)

    def _set_repository(self, repo_id: int, repo_name: str) -&gt; None:
        &quot;&quot;&quot;Set the selected repository as the current one.&quot;&quot;&quot;
        # Update environment variable
        os.environ[&quot;CODEGEN_REPO_ID&quot;] = str(repo_id)
        
        # Try to update .env file
        env_updated = self._update_env_file(repo_id)
        
        if env_updated:
            self.notify(f&quot;âœ“ Set default repository: {repo_name} (ID: {repo_id})&quot;)
            self.notify(&quot;âœ“ Updated .env file with CODEGEN_REPO_ID&quot;)
        else:
            self.notify(f&quot;âœ“ Set repository: {repo_name} (ID: {repo_id})&quot;)
            self.notify(&quot;â„¹  Add &apos;export CODEGEN_REPO_ID={repo_id}&apos; to your shell for persistence&quot;)
        
        # Wait a moment for user to see the notifications, then exit
        self.set_timer(2.0, self.exit)

    def _update_env_file(self, repo_id: int) -&gt; bool:
        &quot;&quot;&quot;Update the .env file with the new repository ID.&quot;&quot;&quot;
        env_file_path = &quot;.env&quot;
        
        try:
            lines = []
            key_updated = False
            key_to_update = &quot;CODEGEN_REPO_ID&quot;
            
            # Read existing .env file if it exists
            if os.path.exists(env_file_path):
                with open(env_file_path, &quot;r&quot;) as f:
                    lines = f.readlines()
            
            # Update or add the key
            for i, line in enumerate(lines):
                if line.strip().startswith(f&quot;{key_to_update}=&quot;):
                    lines[i] = f&quot;{key_to_update}={repo_id}\n&quot;
                    key_updated = True
                    break
            
            # If key wasn&apos;t found, add it
            if not key_updated:
                if lines and not lines[-1].endswith(&apos;\n&apos;):
                    lines.append(&apos;\n&apos;)
                lines.append(f&quot;{key_to_update}={repo_id}\n&quot;)
            
            # Write back to file
            with open(env_file_path, &quot;w&quot;) as f:
                f.writelines(lines)
            
            return True
            
        except Exception:
            return False</file><file path="src/codegen/cli/commands/style_debug/main.py">&quot;&quot;&quot;Debug command to visualize CLI styling components.&quot;&quot;&quot;

import time

import typer

from codegen.cli.rich.spinners import create_spinner


def style_debug(text: str = typer.Option(&quot;Loading...&quot;, help=&quot;Text to show in the spinner&quot;)):
    &quot;&quot;&quot;Debug command to visualize CLI styling (spinners, etc).&quot;&quot;&quot;
    try:
        with create_spinner(text) as status:
            # Run indefinitely until Ctrl+C
            while True:
                time.sleep(0.1)
    except KeyboardInterrupt:
        # Exit gracefully on Ctrl+C
        pass</file><file path="src/codegen/cli/commands/tools/__init__.py">&quot;&quot;&quot;Tools command module.&quot;&quot;&quot;</file><file path="src/codegen/cli/commands/tools/main.py">&quot;&quot;&quot;Tools command for the Codegen CLI.&quot;&quot;&quot;

import requests
import typer
from rich.console import Console
from rich.table import Table

from codegen.cli.api.endpoints import API_ENDPOINT
from codegen.cli.auth.token_manager import get_current_token
from codegen.cli.rich.spinners import create_spinner
from codegen.cli.utils.org import resolve_org_id

console = Console()


def tools(org_id: int | None = typer.Option(None, help=&quot;Organization ID (defaults to CODEGEN_ORG_ID/REPOSITORY_ORG_ID or auto-detect)&quot;)):
    &quot;&quot;&quot;List available tools from the Codegen API.&quot;&quot;&quot;
    # Get the current token
    token = get_current_token()
    if not token:
        console.print(&quot;[red]Error:[/red] Not authenticated. Please run &apos;codegen login&apos; first.&quot;)
        raise typer.Exit(1)

    try:
        # Resolve org id
        resolved_org_id = resolve_org_id(org_id)
        if resolved_org_id is None:
            console.print(&quot;[red]Error:[/red] Organization ID not provided. Pass --org-id, set CODEGEN_ORG_ID, or REPOSITORY_ORG_ID.&quot;)
            raise typer.Exit(1)

        # Make API request to list tools with spinner
        spinner = create_spinner(&quot;Fetching available tools...&quot;)
        spinner.start()

        try:
            headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}
            url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{resolved_org_id}/tools&quot;
            response = requests.get(url, headers=headers)
            response.raise_for_status()
            response_data = response.json()
        finally:
            spinner.stop()

        # Extract tools from the response structure
        if isinstance(response_data, dict) and &quot;tools&quot; in response_data:
            tools_data = response_data[&quot;tools&quot;]
            total_count = response_data.get(&quot;total_count&quot;, len(tools_data))
        else:
            tools_data = response_data
            total_count = len(tools_data) if isinstance(tools_data, list) else 1

        if not tools_data:
            console.print(&quot;[yellow]No tools found.[/yellow]&quot;)
            return

        # Handle case where response might be a list of strings vs list of objects
        if isinstance(tools_data, list) and len(tools_data) &gt; 0:
            # Check if first item is a string or object
            if isinstance(tools_data[0], str):
                # Simple list of tool names
                console.print(f&quot;[green]Found {len(tools_data)} tools:[/green]&quot;)
                for tool_name in tools_data:
                    console.print(f&quot;  â€¢ {tool_name}&quot;)
                return

        # Create a table to display tools (for structured data)
        table = Table(
            title=&quot;Available Tools&quot;,
            border_style=&quot;blue&quot;,
            show_header=True,
            title_justify=&quot;center&quot;,
        )
        table.add_column(&quot;Tool Name&quot;, style=&quot;cyan&quot;, no_wrap=True)
        table.add_column(&quot;Description&quot;, style=&quot;white&quot;)
        table.add_column(&quot;Category&quot;, style=&quot;magenta&quot;)

        # Add tools to table
        for tool in tools_data:
            if isinstance(tool, dict):
                tool_name = tool.get(&quot;name&quot;, &quot;Unknown&quot;)
                description = tool.get(&quot;description&quot;, &quot;No description available&quot;)
                category = tool.get(&quot;category&quot;, &quot;General&quot;)

                # Truncate long descriptions
                if len(description) &gt; 80:
                    description = description[:77] + &quot;...&quot;

                table.add_row(tool_name, description, category)
            else:
                # Fallback for non-dict items
                table.add_row(str(tool), &quot;Unknown&quot;, &quot;General&quot;)

        console.print(table)
        console.print(f&quot;\n[green]Found {total_count} tools available.[/green]&quot;)

    except requests.RequestException as e:
        console.print(f&quot;[red]Error fetching tools:[/red] {e}&quot;, style=&quot;bold red&quot;)
        raise typer.Exit(1)
    except Exception as e:
        console.print(f&quot;[red]Unexpected error:[/red] {e}&quot;, style=&quot;bold red&quot;)
        raise typer.Exit(1)</file><file path="src/codegen/cli/commands/tui/__init__.py">&quot;&quot;&quot;TUI command module.&quot;&quot;&quot;</file><file path="src/codegen/cli/commands/tui/main.py">&quot;&quot;&quot;TUI command for the Codegen CLI.&quot;&quot;&quot;

from codegen.cli.tui.app import run_tui


def tui():
    &quot;&quot;&quot;Launch the Codegen TUI interface.&quot;&quot;&quot;
    run_tui()


if __name__ == &quot;__main__&quot;:
    tui()</file><file path="src/codegen/cli/commands/update/__init__.py">&quot;&quot;&quot;Update command module for Codegen CLI.&quot;&quot;&quot;

from .main import update
from .updater import UpdateManager, check_for_updates_on_startup

__all__ = [&quot;update&quot;, &quot;UpdateManager&quot;, &quot;check_for_updates_on_startup&quot;]</file><file path="src/codegen/cli/commands/update/main.py">import subprocess
import sys
from importlib.metadata import distribution

import requests
import rich
import typer
from packaging.version import Version
from rich.console import Console

import codegen

from .updater import UpdateManager

console = Console()


def fetch_pypi_releases(package: str) -&gt; list[str]:
    response = requests.get(f&quot;https://pypi.org/pypi/{package}/json&quot;)
    response.raise_for_status()
    return response.json()[&quot;releases&quot;].keys()


def filter_versions(versions: list[Version], current_version: Version, num_prev_minor_version: int = 1) -&gt; list[Version]:
    descending_minor_versions = [v_tuple for v_tuple in sorted(set(v.release[:2] for v in versions), reverse=True) if v_tuple &lt; current_version.release[:2]]
    try:
        compare_tuple = descending_minor_versions[:num_prev_minor_version][-1] + (0,)
    except IndexError:
        compare_tuple = (current_version.major, current_version.minor, 0)

    return [v for v in versions if (v.major, v.minor, v.micro) &gt;= compare_tuple]  # v.release will only show major,minor if micro doesn&apos;t exist.


def install_package(package: str, *args: str) -&gt; None:
    subprocess.check_call([sys.executable, &quot;-m&quot;, &quot;pip&quot;, &quot;install&quot;, package, *args])


def update(
    list_: bool = typer.Option(False, &quot;--list&quot;, &quot;-l&quot;, help=&quot;List all supported versions&quot;),
    version: str | None = typer.Option(None, &quot;--version&quot;, &quot;-v&quot;, help=&quot;Update to a specific version&quot;),
    check: bool = typer.Option(False, &quot;--check&quot;, help=&quot;Check for available updates without installing&quot;),
    legacy: bool = typer.Option(False, &quot;--legacy&quot;, help=&quot;Use legacy update method (simple pip upgrade)&quot;),
):
    &quot;&quot;&quot;Update Codegen CLI to the latest or specified version.

    Examples:
        codegen update                    # Update to latest version
        codegen update --check            # Check for updates
        codegen update --version 1.2.3    # Update to specific version
    &quot;&quot;&quot;
    # Handle legacy mode
    if legacy:
        _legacy_update(list_, version)
        return

    # Use new update manager
    manager = UpdateManager()

    # Handle different actions
    if check or list_:
        result = manager.check_for_updates(force=True)

        if result.update_available:
            console.print(f&quot;\n[cyan]Update available: {result.current_version} â†’ {result.latest_version}[/cyan]&quot;)
            console.print(&quot;[dim]Run &apos;codegen update&apos; to upgrade[/dim]\n&quot;)
        else:
            console.print(&quot;[green]You&apos;re on the latest version![/green]&quot;)

        if list_ and result.versions:
            console.print(&quot;\n[bold]Available versions:[/bold]&quot;)
            for ver_info in result.versions[:10]:
                marker = &quot; (current)&quot; if ver_info.version == result.current_version else &quot;&quot;
                console.print(f&quot;  {ver_info.version}{marker}&quot;)
    else:
        # Perform update
        if not manager.perform_update(target_version=version):
            raise typer.Exit(1)


def _legacy_update(list_: bool, version: str | None):
    &quot;&quot;&quot;Legacy update method using simple pip upgrade.&quot;&quot;&quot;
    package_name = codegen.__package__ or &quot;codegen&quot;
    package_info = distribution(package_name)
    current_version = Version(package_info.version)

    if list_:
        releases = fetch_pypi_releases(package_info.name)
        filtered_releases = filter_versions([Version(r) for r in releases], current_version, num_prev_minor_version=2)
        for release in filtered_releases:
            if release.release == current_version.release:
                rich.print(f&quot;[bold]{release}[/bold] (current)&quot;)
            else:
                rich.print(release)
    elif version:
        install_package(f&quot;{package_info.name}=={version}&quot;)
    else:
        # Update to latest version
        install_package(package_info.name, &quot;--upgrade&quot;)</file><file path="src/codegen/cli/commands/update/updater.py">&quot;&quot;&quot;Simplified self-update system for the Codegen CLI.&quot;&quot;&quot;

import json
import os
import platform
import shutil
import subprocess
import sys
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import List, Optional

import requests
from packaging.version import Version
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table

console = Console()

# Update configuration
UPDATE_CHECK_FILE = Path.home() / &quot;.codegen&quot; / &quot;update_check.json&quot;
UPDATE_CHECK_INTERVAL = timedelta(hours=12)  # Check for updates once per day


class InstallMethod(Enum):
    &quot;&quot;&quot;Installation methods for the CLI.&quot;&quot;&quot;

    PIP = &quot;pip&quot;
    PIPX = &quot;pipx&quot;
    UV_TOOL = &quot;uv_tool&quot;
    HOMEBREW = &quot;homebrew&quot;
    GITHUB_RELEASE = &quot;github&quot;
    DEVELOPMENT = &quot;development&quot;
    UNKNOWN = &quot;unknown&quot;


@dataclass
class VersionInfo:
    &quot;&quot;&quot;Information about a version.&quot;&quot;&quot;

    version: Version
    release_date: datetime
    download_url: Optional[str] = None
    release_notes: Optional[str] = None
    size: Optional[int] = None


@dataclass
class UpdateCheckResult:
    &quot;&quot;&quot;Result of checking for updates.&quot;&quot;&quot;

    current_version: Version
    latest_version: Optional[Version] = None
    update_available: bool = False
    versions: List[VersionInfo] = None
    last_check: Optional[datetime] = None


class UpdateManager:
    &quot;&quot;&quot;Manages self-updates for the CLI.&quot;&quot;&quot;

    def __init__(self, package_name: str = &quot;codegen&quot;):
        self.package_name = package_name
        self.console = console
        self.install_method = self._detect_install_method()

    def _detect_install_method(self) -&gt; InstallMethod:
        &quot;&quot;&quot;Detect how the CLI was installed.&quot;&quot;&quot;
        # Check for UV tool FIRST (before development check)
        # UV tools are installed in ~/.local/share/uv/tools/
        if &quot;.local/share/uv/tools/&quot; in sys.executable:
            return InstallMethod.UV_TOOL

        # Also check if the codegen command is in the UV managed bin directory
        try:
            import shutil

            codegen_path = shutil.which(&quot;codegen&quot;)
            if codegen_path and &quot;.local/bin/codegen&quot; in codegen_path:
                # Check if this links to a UV tool installation
                real_path = os.path.realpath(codegen_path)
                if &quot;.local/share/uv/tools/&quot; in real_path:
                    return InstallMethod.UV_TOOL
        except Exception:
            pass

        # Check for pipx
        if &quot;pipx&quot; in sys.executable or os.environ.get(&quot;PIPX_HOME&quot;):
            return InstallMethod.PIPX

        # Check for Homebrew
        if platform.system() == &quot;Darwin&quot; and &quot;/homebrew/&quot; in sys.executable:
            return InstallMethod.HOMEBREW

        # Check if running from development environment
        # This check should come AFTER UV tool check since UV tool installations
        # may have direct_url.json files
        if &quot;site-packages&quot; not in sys.executable and &quot;dist-packages&quot; not in sys.executable:
            # Check if we&apos;re in an editable install
            try:
                import importlib.metadata

                dist = importlib.metadata.distribution(self.package_name)
                if dist.read_text(&quot;direct_url.json&quot;):
                    return InstallMethod.DEVELOPMENT
            except Exception:
                pass

        # Check for pip
        if &quot;site-packages&quot; in sys.executable or &quot;dist-packages&quot; in sys.executable:
            return InstallMethod.PIP

        return InstallMethod.UNKNOWN

    def check_for_updates(self, force: bool = False) -&gt; UpdateCheckResult:
        &quot;&quot;&quot;Check for available updates.&quot;&quot;&quot;
        # Load last check time
        last_check = self._load_last_check_time()

        # Skip check if recently checked (unless forced)
        if not force and last_check:
            if datetime.now() - last_check &lt; UPDATE_CHECK_INTERVAL:
                return UpdateCheckResult(current_version=self._get_current_version(), last_check=last_check)

        current_version = self._get_current_version()

        try:
            # Fetch available versions
            versions = self._fetch_available_versions()

            # Find latest stable version
            latest = self._find_latest_version(versions)

            # Save check time
            self._save_last_check_time()

            return UpdateCheckResult(
                current_version=current_version,
                latest_version=latest.version if latest else None,
                update_available=latest and latest.version &gt; current_version,
                versions=versions,
                last_check=datetime.now(),
            )
        except Exception as e:
            self.console.print(f&quot;[yellow]Warning: Could not check for updates: {e}[/yellow]&quot;)
            return UpdateCheckResult(current_version=current_version)

    def _get_current_version(self) -&gt; Version:
        &quot;&quot;&quot;Get the current installed version.&quot;&quot;&quot;
        import importlib.metadata

        dist = importlib.metadata.distribution(self.package_name)
        return Version(dist.version)

    def _fetch_available_versions(self) -&gt; List[VersionInfo]:
        &quot;&quot;&quot;Fetch available versions from PyPI.&quot;&quot;&quot;
        versions = []

        # Fetch from PyPI
        try:
            response = requests.get(f&quot;https://pypi.org/pypi/{self.package_name}/json&quot;, timeout=10)
            response.raise_for_status()
            data = response.json()

            for version_str, releases in data[&quot;releases&quot;].items():
                try:
                    version = Version(version_str)

                    # Skip pre-releases
                    if version.is_prerelease:
                        continue

                    # Get release info
                    release_date = None
                    if releases:
                        upload_time = releases[0].get(&quot;upload_time_iso_8601&quot;)
                        if upload_time:
                            release_date = datetime.fromisoformat(upload_time.replace(&quot;Z&quot;, &quot;+00:00&quot;))

                    versions.append(
                        VersionInfo(
                            version=version,
                            release_date=release_date or datetime.now(),
                            download_url=f&quot;https://pypi.org/project/{self.package_name}/{version}/&quot;,
                        )
                    )
                except Exception:
                    continue  # Skip invalid versions
        except Exception as e:
            self.console.print(f&quot;[yellow]Could not fetch PyPI versions: {e}[/yellow]&quot;)

        return sorted(versions, key=lambda v: v.version, reverse=True)

    def _find_latest_version(self, versions: List[VersionInfo]) -&gt; Optional[VersionInfo]:
        &quot;&quot;&quot;Find the latest stable version.&quot;&quot;&quot;
        for version_info in versions:
            # Return the first (highest) version since list is sorted
            return version_info
        return None

    def _load_last_check_time(self) -&gt; Optional[datetime]:
        &quot;&quot;&quot;Load the last update check time.&quot;&quot;&quot;
        if UPDATE_CHECK_FILE.exists():
            try:
                with open(UPDATE_CHECK_FILE) as f:
                    data = json.load(f)
                    return datetime.fromisoformat(data.get(&quot;last_check&quot;))
            except Exception:
                pass
        return None

    def _save_last_check_time(self) -&gt; None:
        &quot;&quot;&quot;Save the last update check time.&quot;&quot;&quot;
        UPDATE_CHECK_FILE.parent.mkdir(parents=True, exist_ok=True)
        with open(UPDATE_CHECK_FILE, &quot;w&quot;) as f:
            json.dump({&quot;last_check&quot;: datetime.now().isoformat()}, f)

    def perform_update(self, target_version: Optional[str] = None, dry_run: bool = False, skip_confirmation: bool = False) -&gt; bool:
        &quot;&quot;&quot;Perform the update to a specific version or latest.&quot;&quot;&quot;
        current_version = self._get_current_version()

        # Determine target version
        if target_version:
            try:
                target = Version(target_version)
            except Exception:
                self.console.print(f&quot;[red]Invalid version: {target_version}[/red]&quot;)
                return False
        else:
            # Get latest stable version
            check_result = self.check_for_updates(force=True)
            if not check_result.update_available:
                self.console.print(&quot;[green]Already on the latest version![/green]&quot;)
                return True
            target = check_result.latest_version

        if target &lt;= current_version:
            self.console.print(f&quot;[yellow]Target version {target} is not newer than current {current_version}[/yellow]&quot;)
            return False

        # Show update plan
        self._show_update_plan(current_version, target, dry_run)

        if dry_run:
            return True

        # Confirm update (skip if already confirmed)
        if not skip_confirmation and not self._confirm_update():
            self.console.print(&quot;[yellow]Update cancelled[/yellow]&quot;)
            return False

        # Run pre-update hooks
        if not self._run_pre_update_hooks(current_version, target):
            self.console.print(&quot;[red]Pre-update checks failed[/red]&quot;)
            return False

        # Perform the update based on installation method
        success = self._perform_update_for_method(target)

        if success:
            # Run post-update hooks
            self._run_post_update_hooks(current_version, target)

            self.console.print(f&quot;[green]âœ… Successfully updated from {current_version} to {target}![/green]&quot;)
            self.console.print(&quot;\n[cyan]Please restart your terminal or run:[/cyan]&quot;)
            self.console.print(&quot;[bold]hash -r[/bold]  # For bash/zsh&quot;)
            self.console.print(&quot;[bold]rehash[/bold]   # For zsh&quot;)
        else:
            self.console.print(&quot;[red]Update failed.[/red]&quot;)

        return success

    def _show_update_plan(self, current: Version, target: Version, dry_run: bool) -&gt; None:
        &quot;&quot;&quot;Show the update plan.&quot;&quot;&quot;
        panel_content = f&quot;&quot;&quot;
[cyan]Current Version:[/cyan] {current}
[cyan]Target Version:[/cyan]  {target}
[cyan]Install Method:[/cyan]  {self.install_method.value}
[cyan]Dry Run:[/cyan]        {dry_run}
&quot;&quot;&quot;

        self.console.print(Panel(panel_content.strip(), title=&quot;Update Plan&quot;, border_style=&quot;blue&quot;))

    def _confirm_update(self) -&gt; bool:
        &quot;&quot;&quot;Confirm the update with the user.&quot;&quot;&quot;
        from rich.prompt import Confirm

        return Confirm.ask(&quot;Do you want to proceed with the update?&quot;, default=True)

    def _run_pre_update_hooks(self, current: Version, target: Version) -&gt; bool:
        &quot;&quot;&quot;Run pre-update hooks.&quot;&quot;&quot;
        # Check for breaking changes
        if target.major &gt; current.major:
            self.console.print(&quot;[yellow]âš ï¸  Major version update detected - breaking changes possible[/yellow]&quot;)

        # No migrations needed for now
        return True

    def _run_post_update_hooks(self, previous: Version, current: Version) -&gt; None:
        &quot;&quot;&quot;Run post-update hooks.&quot;&quot;&quot;
        # Show post-update tips
        if current.major &gt; previous.major:
            self.console.print(&quot;\n[cyan]ðŸ“š Major version update completed![/cyan]&quot;)
            self.console.print(&quot;[dim]Check the changelog for breaking changes and new features.[/dim]&quot;)

    def _perform_update_for_method(self, target: Version) -&gt; bool:
        &quot;&quot;&quot;Perform update based on installation method.&quot;&quot;&quot;
        if self.install_method == InstallMethod.PIP:
            return self._update_via_pip(target)
        elif self.install_method == InstallMethod.PIPX:
            return self._update_via_pipx(target)
        elif self.install_method == InstallMethod.UV_TOOL:
            return self._update_via_uv_tool(target)
        elif self.install_method == InstallMethod.HOMEBREW:
            return self._update_via_homebrew(target)
        elif self.install_method == InstallMethod.DEVELOPMENT:
            self.console.print(&quot;[yellow]Development installation detected - please update via git[/yellow]&quot;)
            return False
        else:
            self.console.print(&quot;[yellow]Unknown installation method - trying pip[/yellow]&quot;)
            return self._update_via_pip(target)

    def _update_via_pip(self, target: Version) -&gt; bool:
        &quot;&quot;&quot;Update using pip.&quot;&quot;&quot;
        try:
            with Progress(
                SpinnerColumn(),
                TextColumn(&quot;[progress.description]{task.description}&quot;),
                transient=True,
            ) as progress:
                progress.add_task(f&quot;Updating via pip to {target}...&quot;, total=None)

                subprocess.check_call([sys.executable, &quot;-m&quot;, &quot;pip&quot;, &quot;install&quot;, f&quot;{self.package_name}=={target}&quot;, &quot;--upgrade&quot;])
            return True
        except subprocess.CalledProcessError as e:
            self.console.print(f&quot;[red]pip update failed: {e}[/red]&quot;)
            return False

    def _update_via_pipx(self, target: Version) -&gt; bool:
        &quot;&quot;&quot;Update using pipx.&quot;&quot;&quot;
        try:
            with Progress(
                SpinnerColumn(),
                TextColumn(&quot;[progress.description]{task.description}&quot;),
                transient=True,
            ) as progress:
                progress.add_task(f&quot;Updating via pipx to {target}...&quot;, total=None)

                subprocess.check_call([&quot;pipx&quot;, &quot;upgrade&quot;, self.package_name, &quot;--pip-args&quot;, f&quot;{self.package_name}=={target}&quot;])
            return True
        except subprocess.CalledProcessError as e:
            self.console.print(f&quot;[red]pipx update failed: {e}[/red]&quot;)
            return False

    def _update_via_uv_tool(self, target: Version) -&gt; bool:
        &quot;&quot;&quot;Update using uv tool.&quot;&quot;&quot;
        try:
            with Progress(
                SpinnerColumn(),
                TextColumn(&quot;[progress.description]{task.description}&quot;),
                transient=True,
            ) as progress:
                progress.add_task(f&quot;Updating via uv tool to {target}...&quot;, total=None)

                # UV tool requires different syntax: uv tool install --upgrade package==version
                subprocess.check_call([&quot;uv&quot;, &quot;tool&quot;, &quot;install&quot;, &quot;--upgrade&quot;, f&quot;{self.package_name}=={target}&quot;])
            return True
        except subprocess.CalledProcessError as e:
            self.console.print(f&quot;[red]uv tool update failed: {e}[/red]&quot;)
            self.console.print(&quot;[yellow]You may need to manually update using:[/yellow]&quot;)
            self.console.print(f&quot;[bold]uv tool install --upgrade {self.package_name}=={target}[/bold]&quot;)
            return False

    def _update_via_homebrew(self, target: Version) -&gt; bool:
        &quot;&quot;&quot;Update using Homebrew.&quot;&quot;&quot;
        self.console.print(&quot;[yellow]Homebrew update not yet implemented - please use &apos;brew upgrade codegen&apos;[/yellow]&quot;)
        return False


def check_for_updates_on_startup() -&gt; None:
    &quot;&quot;&quot;Check for updates on CLI startup with blocking prompt.&quot;&quot;&quot;
    try:
        # Only check if we haven&apos;t checked recently
        manager = UpdateManager()
        result = manager.check_for_updates(force=True)

        if result.update_available:
            console.print(f&quot;\n[cyan]â„¹ï¸  A new version of Codegen CLI is available: {result.current_version} â†’ {result.latest_version}[/cyan]&quot;)

            if manager.perform_update():
                console.print(&quot;\n[green]âœ“ Update completed successfully![/green]&quot;)
                console.print(&quot;[yellow]Please restart your terminal or run a new codegen command to use the updated version.[/yellow]\n&quot;)
                # Exit after successful update
                sys.exit(0)
            else:
                console.print(&quot;\n[red]Update failed. Please try running &apos;codegen update&apos; manually.[/red]\n&quot;)

    except Exception:
        # Silently ignore update check failures on startup
        pass</file><file path="src/codegen/cli/env/constants.py">from codegen.cli.env.enums import Environment

DEFAULT_ENV = Environment.PRODUCTION</file><file path="src/codegen/cli/env/enums.py">from enum import StrEnum


class Environment(StrEnum):
    PRODUCTION = &quot;prod&quot;
    STAGING = &quot;staging&quot;
    DEVELOP = &quot;develop&quot;</file><file path="src/codegen/cli/env/global_env.ipynb">{
 &quot;cells&quot;: [
  {
   &quot;cell_type&quot;: &quot;code&quot;,
   &quot;execution_count&quot;: null,
   &quot;metadata&quot;: {},
   &quot;outputs&quot;: [],
   &quot;source&quot;: [
    &quot;# test: parse environment\n&quot;,
    &quot;from codegen.cli.env.enums import Environment\n&quot;,
    &quot;\n&quot;,
    &quot;\n&quot;,
    &quot;Environment(\&quot;staging\&quot;)&quot;
   ]
  },
  {
   &quot;cell_type&quot;: &quot;code&quot;,
   &quot;execution_count&quot;: null,
   &quot;metadata&quot;: {},
   &quot;outputs&quot;: [],
   &quot;source&quot;: [
    &quot;# test: ENV=prod loads .env.prod\n&quot;,
    &quot;import os\n&quot;,
    &quot;\n&quot;,
    &quot;os.environ[\&quot;ENV\&quot;] = \&quot;prod\&quot;\n&quot;,
    &quot;from codegen.cli.env.global_env import GlobalEnv\n&quot;,
    &quot;\n&quot;,
    &quot;global_env = GlobalEnv()\n&quot;,
    &quot;print(global_env.ALGOLIA_SEARCH_KEY)&quot;
   ]
  },
  {
   &quot;cell_type&quot;: &quot;code&quot;,
   &quot;execution_count&quot;: null,
   &quot;metadata&quot;: {},
   &quot;outputs&quot;: [],
   &quot;source&quot;: [
    &quot;# test: ENV=staging and .env.staging does not exist loads from .env\n&quot;,
    &quot;import os\n&quot;,
    &quot;\n&quot;,
    &quot;os.environ[\&quot;ENV\&quot;] = \&quot;staging\&quot;\n&quot;,
    &quot;from codegen.cli.env.global_env import GlobalEnv\n&quot;,
    &quot;\n&quot;,
    &quot;global_env = GlobalEnv()\n&quot;,
    &quot;print(global_env.ALGOLIA_SEARCH_KEY)&quot;
   ]
  }
 ],
 &quot;metadata&quot;: {
  &quot;kernelspec&quot;: {
   &quot;display_name&quot;: &quot;.venv&quot;,
   &quot;language&quot;: &quot;python&quot;,
   &quot;name&quot;: &quot;python3&quot;
  },
  &quot;language_info&quot;: {
   &quot;codemirror_mode&quot;: {
    &quot;name&quot;: &quot;ipython&quot;,
    &quot;version&quot;: 3
   },
   &quot;file_extension&quot;: &quot;.py&quot;,
   &quot;mimetype&quot;: &quot;text/x-python&quot;,
   &quot;name&quot;: &quot;python&quot;,
   &quot;nbconvert_exporter&quot;: &quot;python&quot;,
   &quot;pygments_lexer&quot;: &quot;ipython3&quot;,
   &quot;version&quot;: &quot;3.13.0&quot;
  }
 },
 &quot;nbformat&quot;: 4,
 &quot;nbformat_minor&quot;: 2
}</file><file path="src/codegen/cli/env/global_env.py">import os

from dotenv import find_dotenv, load_dotenv

from codegen.cli.env.constants import DEFAULT_ENV
from codegen.cli.env.enums import Environment


class GlobalEnv:
    def __init__(self) -&gt; None:
        self.ENV = self._parse_env()
        self._load_dotenv()

        # =====[ DEV ]=====
        self.DEBUG = self._get_env_var(&quot;DEBUG&quot;)

        # =====[ AUTH ]=====
        self.CODEGEN_USER_ACCESS_TOKEN = self._get_env_var(&quot;CODEGEN_USER_ACCESS_TOKEN&quot;)

        # =====[ ALGOLIA ]=====
        self.ALGOLIA_SEARCH_KEY = self._get_env_var(&quot;ALGOLIA_SEARCH_KEY&quot;)

        # =====[ POSTHOG ]=====
        self.POSTHOG_PROJECT_API_KEY = self._get_env_var(&quot;POSTHOG_PROJECT_API_KEY&quot;)

        # =====[ MODAL ]=====
        self.MODAL_ENVIRONMENT = self._get_env_var(&quot;MODAL_ENVIRONMENT&quot;)

    def _parse_env(self) -&gt; Environment:
        env_envvar = os.environ.get(&quot;ENV&quot;)
        if not env_envvar:
            return DEFAULT_ENV
        if env_envvar not in Environment:
            msg = f&quot;Invalid environment: {env_envvar}&quot;
            raise ValueError(msg)
        return Environment(env_envvar)

    def _load_dotenv(self) -&gt; None:
        env_file = find_dotenv(filename=f&quot;.env.{self.ENV}&quot;)
        # if env specific .env file does not exist, try to load .env
        load_dotenv(env_file or None, override=True)

    def _get_env_var(self, var_name, required: bool = False) -&gt; str:
        if self.ENV == &quot;local&quot;:
            return &quot;&quot;

        if value := os.environ.get(var_name):
            return value

        if required:
            msg = f&quot;Environment variable {var_name} is not set with ENV={self.ENV}!&quot;
            raise ValueError(msg)
        return &quot;&quot;

    def __repr__(self) -&gt; str:
        # Returns all env vars in a readable format
        return &quot;\n&quot;.join([f&quot;{k}={v}&quot; for k, v in self.__dict__.items()])


# NOTE: load and store envvars once
global_env = GlobalEnv()</file><file path="src/codegen/cli/mcp/tools/__init__.py">&quot;&quot;&quot;Tools module for the Codegen MCP server.&quot;&quot;&quot;</file><file path="src/codegen/cli/mcp/tools/dynamic.py">&quot;&quot;&quot;Dynamic tool registration for the Codegen MCP server.&quot;&quot;&quot;

import json
from typing import Annotated

from fastmcp import FastMCP

from .executor import execute_tool_via_api


def register_dynamic_tools(mcp: FastMCP, available_tools: list):
    &quot;&quot;&quot;Register all available tools from the API as individual MCP tools.&quot;&quot;&quot;
    import inspect

    for i, tool_info in enumerate(available_tools):
        # Skip None or invalid tool entries
        if not tool_info or not isinstance(tool_info, dict):
            print(f&quot;âš ï¸ Skipping invalid tool entry at index {i}: {tool_info}&quot;)
            continue

        try:
            tool_name = tool_info.get(&quot;name&quot;, &quot;unknown_tool&quot;)
            tool_description = tool_info.get(&quot;description&quot;, &quot;No description available&quot;).replace(&quot;&apos;&quot;, &apos;&quot;&apos;).replace(&apos;&quot;&apos;, &apos;\\&quot;&apos;)
            tool_parameters = tool_info.get(&quot;parameters&quot;, {})

            # Parse the parameter schema
            if tool_parameters is None:
                tool_parameters = {}
            properties = tool_parameters.get(&quot;properties&quot;, {})
            required = tool_parameters.get(&quot;required&quot;, [])
        except Exception as e:
            print(f&quot;âŒ Error processing tool at index {i}: {e}&quot;)
            print(f&quot;Tool data: {tool_info}&quot;)
            continue

        def make_tool_function(name: str, description: str, props: dict, req: list):
            # Create function dynamically with proper parameters
            def create_dynamic_function():
                # Build parameter list for the function
                param_list = []
                param_annotations = {}

                # Collect required and optional parameters separately
                required_params = []
                optional_params = []

                # Add other parameters from schema
                for param_name, param_info in props.items():
                    param_type = param_info.get(&quot;type&quot;, &quot;string&quot;)
                    param_desc = param_info.get(&quot;description&quot;, f&quot;Parameter {param_name}&quot;).replace(&quot;&apos;&quot;, &apos;&quot;&apos;).replace(&apos;&quot;&apos;, &apos;\\&quot;&apos;)
                    is_required = param_name in req

                    # Special handling for tool_call_id - always make it optional
                    if param_name == &quot;tool_call_id&quot;:
                        optional_params.append(&quot;tool_call_id: Annotated[str, &apos;Unique identifier for this tool call&apos;] = &apos;mcp_call&apos;&quot;)
                        continue

                    # Convert JSON schema types to Python types
                    if param_type == &quot;string&quot;:
                        py_type = &quot;str&quot;
                    elif param_type == &quot;integer&quot;:
                        py_type = &quot;int&quot;
                    elif param_type == &quot;number&quot;:
                        py_type = &quot;float&quot;
                    elif param_type == &quot;boolean&quot;:
                        py_type = &quot;bool&quot;
                    elif param_type == &quot;array&quot;:
                        items_type = param_info.get(&quot;items&quot;, {}).get(&quot;type&quot;, &quot;string&quot;)
                        if items_type == &quot;string&quot;:
                            py_type = &quot;list[str]&quot;
                        else:
                            py_type = &quot;list&quot;
                    else:
                        py_type = &quot;str&quot;  # Default fallback

                    # Handle optional parameters (anyOf with null)
                    if &quot;anyOf&quot; in param_info:
                        py_type = f&quot;{py_type} | None&quot;
                        if not is_required:
                            default_val = param_info.get(&quot;default&quot;, &quot;None&quot;)
                            if isinstance(default_val, str) and default_val != &quot;None&quot;:
                                default_val = f&apos;&quot;{default_val}&quot;&apos;
                            optional_params.append(f&quot;{param_name}: Annotated[{py_type}, &apos;{param_desc}&apos;] = {default_val}&quot;)
                        else:
                            required_params.append(f&quot;{param_name}: Annotated[{py_type}, &apos;{param_desc}&apos;]&quot;)
                    elif is_required:
                        required_params.append(f&quot;{param_name}: Annotated[{py_type}, &apos;{param_desc}&apos;]&quot;)
                    else:
                        # Optional parameter with default
                        default_val = param_info.get(&quot;default&quot;, &quot;None&quot;)
                        if isinstance(default_val, str) and default_val not in [&quot;None&quot;, &quot;null&quot;]:
                            default_val = f&apos;&quot;{default_val}&quot;&apos;
                        elif isinstance(default_val, bool):
                            default_val = str(default_val)
                        elif default_val is None or default_val == &quot;null&quot;:
                            default_val = &quot;None&quot;
                        optional_params.append(f&quot;{param_name}: Annotated[{py_type}, &apos;{param_desc}&apos;] = {default_val}&quot;)

                # Only add tool_call_id if it wasn&apos;t already in the schema
                tool_call_id_found = any(&quot;tool_call_id&quot; in param for param in optional_params)
                if not tool_call_id_found:
                    optional_params.append(&quot;tool_call_id: Annotated[str, &apos;Unique identifier for this tool call&apos;] = &apos;mcp_call&apos;&quot;)

                # Combine required params first, then optional params
                param_list = required_params + optional_params

                # Create the function code
                params_str = &quot;, &quot;.join(param_list)

                # Create a list of parameter names for the function
                param_names = []
                for param in param_list:
                    # Extract parameter name from the type annotation
                    param_name = param.split(&quot;:&quot;)[0].strip()
                    param_names.append(param_name)

                param_names_str = repr(param_names)

                func_code = f&quot;&quot;&quot;
def tool_function({params_str}) -&gt; str:
    &apos;&apos;&apos;Dynamically created tool function: {description}&apos;&apos;&apos;
    # Collect all parameters by name to avoid circular references
    param_names = {param_names_str}
    arguments = {{}}

    # Get the current frame&apos;s local variables
    import inspect
    frame = inspect.currentframe()
    try:
        locals_dict = frame.f_locals
        for param_name in param_names:
            if param_name in locals_dict:
                value = locals_dict[param_name]
                # Handle None values and ensure JSON serializable
                if value is not None:
                    arguments[param_name] = value
    finally:
        del frame

    # Execute the tool via API
    result = execute_tool_via_api(&apos;{name}&apos;, arguments)

    # Return formatted result
    return json.dumps(result, indent=2)
&quot;&quot;&quot;

                # Execute the function code to create the function
                namespace = {&quot;Annotated&quot;: Annotated, &quot;json&quot;: json, &quot;execute_tool_via_api&quot;: execute_tool_via_api, &quot;inspect&quot;: inspect}
                try:
                    exec(func_code, namespace)
                    func = namespace[&quot;tool_function&quot;]
                except SyntaxError as e:
                    print(f&quot;âŒ Syntax error in tool {name}:&quot;)
                    print(f&quot;Error: {e}&quot;)
                    print(&quot;Generated code:&quot;)
                    for i, line in enumerate(func_code.split(&quot;\n&quot;), 1):
                        print(f&quot;{i:3}: {line}&quot;)
                    raise

                # Set metadata
                func.__name__ = name.replace(&quot;-&quot;, &quot;_&quot;)
                func.__doc__ = description

                return func

            return create_dynamic_function()

        # Create the tool function
        tool_func = make_tool_function(tool_name, tool_description, properties, required)

        # Register with FastMCP using the decorator
        decorated_func = mcp.tool()(tool_func)

        print(f&quot;âœ… Registered dynamic tool: {tool_name}&quot;)</file><file path="src/codegen/cli/mcp/tools/executor.py">import json
import requests

from codegen.cli.api.endpoints import API_ENDPOINT

import requests

from codegen.cli.api.endpoints import API_ENDPOINT
from codegen.cli.auth.token_manager import get_current_token
from codegen.cli.utils.org import resolve_org_id


def execute_tool_via_api(tool_name: str, arguments: dict):
    &quot;&quot;&quot;Execute a tool via the Codegen API.&quot;&quot;&quot;
    try:
        token = get_current_token()
        if not token:
            return {&quot;error&quot;: &quot;Not authenticated. Please run &apos;codegen login&apos; first.&quot;}

        headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}

        # Determine org id: prefer explicit in arguments, else resolve from env/config/API
        org_id = None
        if isinstance(arguments, dict):
            org_id = arguments.get(&quot;org_id&quot;)
        org_id = resolve_org_id(org_id)
        if org_id is None:
            return {&quot;error&quot;: &quot;Organization ID not provided. Include org_id argument, or set CODEGEN_ORG_ID/REPOSITORY_ORG_ID.&quot;}

        url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{org_id}/tools/execute&quot;

        payload = {&quot;tool_name&quot;: tool_name, &quot;arguments&quot;: arguments}

        response = requests.post(url, json=payload, headers=headers)
        response.raise_for_status()

        return response.json()

    except Exception as e:
        return {&quot;error&quot;: f&quot;Error executing tool {tool_name}: {e}&quot;}</file><file path="src/codegen/cli/mcp/tools/static.py">&quot;&quot;&quot;Static Codegen API tools for the MCP server.&quot;&quot;&quot;

import json
from typing import Annotated

from fastmcp import Context, FastMCP

from ..api_client import get_api_client


def register_static_tools(mcp: FastMCP):
    &quot;&quot;&quot;Register static Codegen API tools with the MCP server.&quot;&quot;&quot;

    @mcp.tool()
    def create_agent_run(
        org_id: Annotated[int, &quot;Organization ID&quot;],
        prompt: Annotated[str, &quot;The prompt/task for the agent to execute&quot;],
        repo_name: Annotated[str | None, &quot;Repository name (optional)&quot;] = None,
        branch_name: Annotated[str | None, &quot;Branch name (optional)&quot;] = None,
        ctx: Context | None = None,
    ) -&gt; str:
        &quot;&quot;&quot;Create a new agent run in the specified organization.&quot;&quot;&quot;
        try:
            from codegen_api_client.models import CreateAgentRunInput

            _, agents_api, _, _ = get_api_client()

            # Create the input object
            agent_input = CreateAgentRunInput(prompt=prompt)
            # Make the API call
            response = agents_api.create_agent_run_v1_organizations_org_id_agent_run_post(org_id=org_id, create_agent_run_input=agent_input)

            return json.dumps(
                {
                    &quot;id&quot;: response.id,
                    &quot;status&quot;: response.status,
                    &quot;created_at&quot;: response.created_at.isoformat() if response.created_at else None,
                    &quot;prompt&quot;: response.prompt,
                    &quot;repo_name&quot;: response.repo_name,
                    &quot;branch_name&quot;: response.branch_name,
                },
                indent=2,
            )

        except Exception as e:
            return f&quot;Error creating agent run: {e}&quot;

    @mcp.tool()
    def get_agent_run(
        org_id: Annotated[int, &quot;Organization ID&quot;],
        agent_run_id: Annotated[int, &quot;Agent run ID&quot;],
        ctx: Context | None = None,
    ) -&gt; str:
        &quot;&quot;&quot;Get details of a specific agent run.&quot;&quot;&quot;
        try:
            _, agents_api, _, _ = get_api_client()

            response = agents_api.get_agent_run_v1_organizations_org_id_agent_run_agent_run_id_get(org_id=org_id, agent_run_id=agent_run_id)

            return json.dumps(
                {
                    &quot;id&quot;: response.id,
                    &quot;status&quot;: response.status,
                    &quot;created_at&quot;: response.created_at.isoformat() if response.created_at else None,
                    &quot;updated_at&quot;: response.updated_at.isoformat() if response.updated_at else None,
                    &quot;prompt&quot;: response.prompt,
                    &quot;repo_name&quot;: response.repo_name,
                    &quot;branch_name&quot;: response.branch_name,
                    &quot;result&quot;: response.result,
                },
                indent=2,
            )

        except Exception as e:
            return f&quot;Error getting agent run: {e}&quot;

    @mcp.tool()
    def get_organizations(
        page: Annotated[int, &quot;Page number (default: 1)&quot;] = 1,
        limit: Annotated[int, &quot;Number of organizations per page (default: 10)&quot;] = 10,
        ctx: Context | None = None,
    ) -&gt; str:
        &quot;&quot;&quot;Get list of organizations the user has access to.&quot;&quot;&quot;
        try:
            _, _, organizations_api, _ = get_api_client()

            response = organizations_api.get_organizations_v1_organizations_get()

            # Format the response
            organizations = []
            for org in response.items:
                organizations.append(
                    {
                        &quot;id&quot;: org.id,
                        &quot;name&quot;: org.name,
                        &quot;slug&quot;: org.slug,
                        &quot;created_at&quot;: org.created_at.isoformat() if org.created_at else None,
                    }
                )

            return json.dumps(
                {
                    &quot;organizations&quot;: organizations,
                    &quot;total&quot;: response.total,
                    &quot;page&quot;: response.page,
                    &quot;limit&quot;: response.limit,
                },
                indent=2,
            )

        except Exception as e:
            return f&quot;Error getting organizations: {e}&quot;

    @mcp.tool()
    def get_users(
        org_id: Annotated[int, &quot;Organization ID&quot;],
        page: Annotated[int, &quot;Page number (default: 1)&quot;] = 1,
        limit: Annotated[int, &quot;Number of users per page (default: 10)&quot;] = 10,
        ctx: Context | None = None,
    ) -&gt; str:
        &quot;&quot;&quot;Get list of users in an organization.&quot;&quot;&quot;
        try:
            _, _, _, users_api = get_api_client()

            response = users_api.get_users_v1_organizations_org_id_users_get(org_id=org_id)

            # Format the response
            users = []
            for user in response.items:
                users.append(
                    {
                        &quot;id&quot;: user.id,
                        &quot;email&quot;: user.email,
                        &quot;name&quot;: user.name,
                        &quot;created_at&quot;: user.created_at.isoformat() if user.created_at else None,
                    }
                )

            return json.dumps(
                {
                    &quot;users&quot;: users,
                    &quot;total&quot;: response.total,
                    &quot;page&quot;: response.page,
                    &quot;limit&quot;: response.limit,
                },
                indent=2,
            )

        except Exception as e:
            return f&quot;Error getting users: {e}&quot;

    @mcp.tool()
    def get_user(
        org_id: Annotated[int, &quot;Organization ID&quot;],
        user_id: Annotated[int, &quot;User ID&quot;],
        ctx: Context | None = None,
    ) -&gt; str:
        &quot;&quot;&quot;Get details of a specific user in an organization.&quot;&quot;&quot;
        try:
            _, _, _, users_api = get_api_client()

            response = users_api.get_user_v1_organizations_org_id_users_user_id_get(org_id=org_id, user_id=user_id)

            return json.dumps(
                {
                    &quot;id&quot;: response.id,
                    &quot;email&quot;: response.email,
                    &quot;name&quot;: response.name,
                    &quot;created_at&quot;: response.created_at.isoformat() if response.created_at else None,
                    &quot;updated_at&quot;: response.updated_at.isoformat() if response.updated_at else None,
                },
                indent=2,
            )

        except Exception as e:
            return f&quot;Error getting user: {e}&quot;</file><file path="src/codegen/cli/mcp/__init__.py">&quot;&quot;&quot;MCP (Model Context Protocol) server for Codegen.&quot;&quot;&quot;</file><file path="src/codegen/cli/mcp/api_client.py">&quot;&quot;&quot;API client management for the Codegen MCP server.&quot;&quot;&quot;

import os

# Import API client components
try:
    from codegen_api_client import ApiClient, Configuration
    from codegen_api_client.api import AgentsApi, OrganizationsApi, UsersApi

    API_CLIENT_AVAILABLE = True
except ImportError:
    API_CLIENT_AVAILABLE = False

# Global API client instances
_api_client = None
_agents_api = None
_organizations_api = None
_users_api = None


def get_api_client():
    &quot;&quot;&quot;Get or create the API client instance.&quot;&quot;&quot;
    global _api_client, _agents_api, _organizations_api, _users_api

    if not API_CLIENT_AVAILABLE:
        msg = &quot;codegen-api-client is not available&quot;
        raise RuntimeError(msg)

    if _api_client is None:
        # Configure the API client
        configuration = Configuration()

        # Set base URL from environment or use the CLI endpoint for consistency
        # Prefer explicit env override; else match API_ENDPOINT used by CLI commands
        from codegen.cli.api.endpoints import API_ENDPOINT
        base_url = os.getenv(&quot;CODEGEN_API_BASE_URL&quot;, API_ENDPOINT.rstrip(&quot;/&quot;))
        configuration.host = base_url

        # Set authentication
        api_key = os.getenv(&quot;CODEGEN_API_KEY&quot;)
        if api_key:
            configuration.api_key = {&quot;Authorization&quot;: f&quot;Bearer {api_key}&quot;}

        _api_client = ApiClient(configuration)
        _agents_api = AgentsApi(_api_client)
        _organizations_api = OrganizationsApi(_api_client)
        _users_api = UsersApi(_api_client)

    return _api_client, _agents_api, _organizations_api, _users_api


def is_api_client_available() -&gt; bool:
    &quot;&quot;&quot;Check if the API client is available.&quot;&quot;&quot;
    return API_CLIENT_AVAILABLE</file><file path="src/codegen/cli/mcp/prompts.py">&quot;&quot;&quot;Prompts and instructions for the Codegen MCP server.&quot;&quot;&quot;

MCP_SERVER_INSTRUCTIONS = (
    &quot;Codegen is an operating system for agents. &quot;
    &quot;It allows organizations to run Claude Code instances with superpowers, including unified observability, &quot;
    &quot;dynamic sandboxes, powerful MCP integrations, security and more.\n\n&quot;
    &quot;This MCP server provides permissioned access to integrations configured by your organization. &quot;
    &quot;All tools shown (GitHub, Linear, ClickUp, Notion, Sentry, etc.) are pre-configured and ready to use - &quot;
    &quot;they&apos;ve been provisioned based on your organization&apos;s setup and your role permissions. &quot;
    &quot;You can confidently use any available tool without worrying about authentication or configuration.\n\n&quot;
    &quot;Learn more at https://codegen.com.\n&quot;
    &quot;For documentation, visit https://docs.codegen.com/integrations/mcp.\n&quot;
    &quot;To install and authenticate this server, run: `uv tool install codegen` then `codegen login`.&quot;
)</file><file path="src/codegen/cli/mcp/README.md"># Codegen MCP server

A MCP server implementation that provides tools and resources for interacting with the Codegen platform APIs, enabling AI agents to manage development workflows and access Codegen services.

### Dependencies

- [fastmcp](https://github.com/codegen-sh/fastmcp)

## Usage

Most AI Agents that support MCP will have some way to configure the server startup.

### Cline

Add this to your `cline_mcp_settings.json` file to get started:

```
{
  &quot;mcpServers&quot;: {
    &quot;codegen-cli&quot;: {
        &quot;command&quot;: &quot;uv&quot;,
        &quot;args&quot;: [
            &quot;--directory&quot;,
            &quot;&lt;path to codegen installation&gt;/codegen-sdk/src/codegen/cli/mcp&quot;,
            &quot;run&quot;,
            &quot;server.py&quot;
        ]
    }
  }
}
```

Cursor:
Under the `Settings` &gt; `Feature` &gt; `MCP Servers` section, click &quot;Add New MCP Server&quot; and add the following:

```
Name: codegen-mcp
Type: Command
Command: uv --directory &lt;path to codegen installation&gt;/codegen-sdk/src/codegen/cli/mcp run server.py
```</file><file path="src/codegen/cli/mcp/resources.py">&quot;&quot;&quot;MCP resources for the Codegen server.&quot;&quot;&quot;

from typing import Any

from fastmcp import FastMCP


def register_resources(mcp: FastMCP):
    &quot;&quot;&quot;Register MCP resources with the server.&quot;&quot;&quot;

    @mcp.resource(&quot;system://manifest&quot;, mime_type=&quot;application/json&quot;)
    def get_service_config() -&gt; dict[str, Any]:
        &quot;&quot;&quot;Get the service config.&quot;&quot;&quot;
        return {
            &quot;name&quot;: &quot;mcp-codegen&quot;,
            &quot;version&quot;: &quot;0.1.0&quot;,
            &quot;description&quot;: &quot;The MCP server for the Codegen platform API integration.&quot;,
        }</file><file path="src/codegen/cli/mcp/runner.py">&quot;&quot;&quot;MCP server runner for the Codegen platform.&quot;&quot;&quot;

from fastmcp import FastMCP

from .resources import register_resources
from .tools.dynamic import register_dynamic_tools
from .tools.static import register_static_tools


def run_server(transport: str = &quot;stdio&quot;, host: str = &quot;localhost&quot;, port: int | None = None, available_tools: list | None = None):
    &quot;&quot;&quot;Run the MCP server with the specified transport.&quot;&quot;&quot;
    from .prompts import MCP_SERVER_INSTRUCTIONS

    # Initialize FastMCP server
    mcp = FastMCP(
        &quot;codegen-mcp&quot;,
        instructions=MCP_SERVER_INSTRUCTIONS,
    )

    # Register all components
    register_resources(mcp)
    register_static_tools(mcp)

    # Register dynamic tools if provided
    if available_tools:
        print(&quot;ðŸ”§ Registering dynamic tools from API...&quot;)
        register_dynamic_tools(mcp, available_tools)
        print(f&quot;âœ… Registered {len(available_tools)} dynamic tools&quot;)

    if transport == &quot;stdio&quot;:
        print(&quot;ðŸš€ MCP server running on stdio transport&quot;)
        mcp.run(transport=&quot;stdio&quot;)
    elif transport == &quot;http&quot;:
        if port is None:
            port = 8000
        print(f&quot;ðŸš€ MCP server running on http://{host}:{port}&quot;)
        # Note: FastMCP may not support HTTP transport directly
        # This is a placeholder for future HTTP transport support
        print(f&quot;HTTP transport not yet implemented. Would run on {host}:{port}&quot;)
        mcp.run(transport=&quot;stdio&quot;)  # Fallback to stdio for now
    else:
        msg = f&quot;Unsupported transport: {transport}&quot;
        raise ValueError(msg)</file><file path="src/codegen/cli/mcp/server.py">&quot;&quot;&quot;Main MCP server entry point for the Codegen platform.

This module provides the main entry point for the Codegen MCP server.
The actual server functionality is distributed across several modules:

- api_client.py: API client management
- prompts.py: Server instructions and prompts
- resources.py: MCP resources
- tools/: Tool modules (static and dynamic)
- runner.py: Server runner and configuration
&quot;&quot;&quot;

from .runner import run_server

if __name__ == &quot;__main__&quot;:
    # Initialize and run the server
    print(&quot;Starting codegen server...&quot;)
    run_server()</file><file path="src/codegen/cli/rich/codeblocks.py">def format_command(command: str) -&gt; str:
    &quot;&quot;&quot;Format a command in a consistent style.

    Args:
        command: The command to format

    Returns:
        The formatted command with consistent styling and spacing

    &quot;&quot;&quot;
    return f&quot;\n\t[cyan]{command}[/cyan]\n&quot;


def format_codeblock(code: str) -&gt; str:
    &quot;&quot;&quot;Format a code block in a consistent style.

    Args:
        code: The code to format

    Returns:
        The formatted code with consistent styling

    &quot;&quot;&quot;
    return f&quot;\n\t[cyan]{code}[/cyan]\n&quot;


def format_code(code: str) -&gt; str:
    &quot;&quot;&quot;Just blue for a span&quot;&quot;&quot;
    return f&quot;[cyan]{code}[/cyan]&quot;


def format_path(path: str) -&gt; str:
    &quot;&quot;&quot;Format a path in a consistent style.

    Args:
        path: The path to format

    Returns:
        The formatted path with consistent styling

    &quot;&quot;&quot;
    return f&quot;[cyan]{path}[/cyan]&quot;</file><file path="src/codegen/cli/rich/pretty_print.py">import rich
from rich import box
from rich.markdown import Markdown
from rich.panel import Panel

from codegen.cli.api.schemas import RunCodemodOutput


def pretty_print_output(output: RunCodemodOutput):
    &quot;&quot;&quot;Pretty print the codemod run output with panels.&quot;&quot;&quot;
    if output.web_link:
        rich.print(&quot;\nâ€¢ [blue underline]&quot; + output.web_link + &quot;[/blue underline]\n&quot;)

    if output.logs:
        pretty_print_logs(output.logs)

    if output.error:
        pretty_print_error(output.error)

    if output.observation:
        pretty_print_diff(output.observation)


def pretty_print_logs(logs: str):
    &quot;&quot;&quot;Pretty print logs in a panel.&quot;&quot;&quot;
    rich.print(
        Panel(
            logs,
            title=&quot;[bold blue]Logs&quot;,
            border_style=&quot;blue&quot;,
            box=box.ROUNDED,
            padding=(1, 2),
        )
    )
    rich.print()  # spacing


def pretty_print_error(error: str):
    &quot;&quot;&quot;Pretty print error in a panel.&quot;&quot;&quot;
    rich.print(
        Panel(
            error,
            title=&quot;[bold red]Error&quot;,
            border_style=&quot;red&quot;,
            box=box.ROUNDED,
            padding=(1, 2),
        )
    )
    rich.print()  # spacing


def pretty_print_diff(diff: str):
    &quot;&quot;&quot;Pretty print diff in a panel.&quot;&quot;&quot;
    rich.print(
        Panel(
            Markdown(
                f&quot;&quot;&quot;```diff\n{diff}\n```&quot;&quot;&quot;,
                code_theme=&quot;monokai&quot;,
            ),
            title=&quot;[bold green]Diff&quot;,
            border_style=&quot;green&quot;,
            box=box.ROUNDED,
            padding=(1, 2),
        )
    )
    rich.print()  # spacing</file><file path="src/codegen/cli/rich/spinners.py">&quot;&quot;&quot;Consistent spinner styles for the CLI.&quot;&quot;&quot;

from dataclasses import dataclass

from rich.status import Status


@dataclass
class SpinnerConfig:
    &quot;&quot;&quot;Configuration for a consistent spinner style.&quot;&quot;&quot;

    text: str
    spinner: str = &quot;dots&quot;
    style: str = &quot;bold&quot;
    spinner_style: str = &quot;blue&quot;


def create_spinner(text: str) -&gt; Status:
    &quot;&quot;&quot;Create a spinner with consistent styling.

    Args:
        text: The text to show next to the spinner

    Returns:
        A rich Status object with consistent styling

    &quot;&quot;&quot;
    config = SpinnerConfig(text)
    return Status(f&quot;[{config.style}]{config.text}&quot;, spinner=config.spinner, spinner_style=config.spinner_style)</file><file path="src/codegen/cli/telemetry/__init__.py">&quot;&quot;&quot;CLI telemetry module for analytics and observability.&quot;&quot;&quot;

from codegen.cli.telemetry.consent import (
    ensure_telemetry_consent,
    update_telemetry_consent,
)
from codegen.cli.telemetry.exception_logger import (
    setup_global_exception_logging,
    teardown_global_exception_logging,
)

__all__ = [
    &quot;ensure_telemetry_consent&quot;,
    &quot;setup_global_exception_logging&quot;,
    &quot;teardown_global_exception_logging&quot;,
    &quot;update_telemetry_consent&quot;,
]</file><file path="src/codegen/cli/telemetry/consent.py">&quot;&quot;&quot;Telemetry consent management for the CLI.&quot;&quot;&quot;

import uuid
from pathlib import Path

import rich
import typer

from codegen.configs.constants import GLOBAL_ENV_FILE
from codegen.configs.models.telemetry import TelemetryConfig


def prompt_telemetry_consent() -&gt; bool:
    &quot;&quot;&quot;Prompt user for telemetry consent during first-time setup.

    Returns:
        bool: True if user consents to telemetry, False otherwise
    &quot;&quot;&quot;
    # Display Codegen header
    print(&quot;\033[38;2;82;19;217m&quot; + &quot;/&quot; * 20 + &quot; Codegen\033[0m&quot;)
    print()

    rich.print(&quot;[bold]ðŸ“Š Help Improve Codegen CLI[/bold]&quot;)
    rich.print(
        &quot;We&apos;d like to collect anonymous usage data to improve the CLI experience.\n&quot;
        &quot;This includes:\n&quot;
        &quot;  â€¢ Command usage patterns\n&quot;
        &quot;  â€¢ Performance metrics\n&quot;
        &quot;  â€¢ Error diagnostics (no source code or PII)\n&quot;
        &quot;  â€¢ CLI version and platform info\n&quot;
    )
    rich.print(&quot;[dim]You can change this setting anytime with &apos;codegen config telemetry&apos;[/dim]\n&quot;)

    consent = typer.confirm(&quot;Enable anonymous telemetry?&quot;, default=False)
    return consent


def ensure_telemetry_consent() -&gt; TelemetryConfig:
    &quot;&quot;&quot;Ensure telemetry consent has been obtained and configured.

    This function:
    1. Loads existing telemetry config
    2. If not previously prompted, asks for consent
    3. Saves the configuration

    Returns:
        TelemetryConfig: The telemetry configuration
    &quot;&quot;&quot;
    # Load telemetry config (uses global config file)
    telemetry = TelemetryConfig(env_filepath=GLOBAL_ENV_FILE)

    # If already prompted, return existing config
    if telemetry.consent_prompted:
        return telemetry

    # Prompt for consent
    consent = prompt_telemetry_consent()

    # Update configuration
    telemetry.enabled = consent
    telemetry.consent_prompted = True

    if consent:
        rich.print(&quot;[green]âœ“ Telemetry enabled. Thank you for helping improve Codegen![/green]&quot;)
    else:
        rich.print(&quot;[yellow]âœ“ Telemetry disabled. You can enable it later with &apos;codegen config telemetry&apos;[/yellow]&quot;)

    # Save to global config
    telemetry.write_to_file(GLOBAL_ENV_FILE)

    # Refresh logging configuration to apply the new settings
    try:
        from codegen.shared.logging.get_logger import refresh_telemetry_config

        refresh_telemetry_config()
    except ImportError:
        pass  # Logging refresh not available

    return telemetry


def update_telemetry_consent(enabled: bool) -&gt; None:
    &quot;&quot;&quot;Update telemetry consent preference.

    Args:
        enabled: Whether to enable telemetry
    &quot;&quot;&quot;
    telemetry = TelemetryConfig(env_filepath=GLOBAL_ENV_FILE)
    telemetry.enabled = enabled
    telemetry.consent_prompted = True

    telemetry.write_to_file(GLOBAL_ENV_FILE)

    # Refresh logging configuration to apply the new settings
    try:
        from codegen.shared.logging.get_logger import refresh_telemetry_config

        refresh_telemetry_config()
    except ImportError:
        pass  # Logging refresh not available

    if enabled:
        rich.print(&quot;[green]âœ“ Telemetry enabled[/green]&quot;)
    else:
        rich.print(&quot;[yellow]âœ“ Telemetry disabled[/yellow]&quot;)</file><file path="src/codegen/cli/telemetry/debug_exporter.py">&quot;&quot;&quot;Debug exporter for OpenTelemetry that writes spans to local files.

This module provides a debug exporter that writes telemetry data to disk
for easy inspection and debugging of CLI telemetry.
&quot;&quot;&quot;

import json
import os
from collections.abc import Sequence
from datetime import datetime
from pathlib import Path

from opentelemetry.sdk.trace import ReadableSpan
from opentelemetry.sdk.trace.export import SpanExporter, SpanExportResult
from opentelemetry.trace import format_span_id, format_trace_id

from codegen.configs.constants import GLOBAL_CONFIG_DIR


class DebugFileSpanExporter(SpanExporter):
    &quot;&quot;&quot;Exports spans to JSON files for debugging.&quot;&quot;&quot;

    def __init__(self, output_dir: Path | None = None):
        &quot;&quot;&quot;Initialize the debug exporter.

        Args:
            output_dir: Directory to write debug files. Defaults to ~/.config/codegen-sh/telemetry_debug
        &quot;&quot;&quot;
        if output_dir is None:
            output_dir = GLOBAL_CONFIG_DIR / &quot;telemetry_debug&quot;

        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Create a session file for this CLI run
        self.session_id = datetime.now().strftime(&quot;%Y%m%d_%H%M%S&quot;)
        self.session_file = self.output_dir / f&quot;session_{self.session_id}.jsonl&quot;

        # Write session header
        with open(self.session_file, &quot;w&quot;) as f:
            f.write(
                json.dumps(
                    {
                        &quot;type&quot;: &quot;session_start&quot;,
                        &quot;timestamp&quot;: datetime.now().isoformat(),
                        &quot;pid&quot;: os.getpid(),
                    }
                )
                + &quot;\n&quot;
            )

    def export(self, spans: Sequence[ReadableSpan]) -&gt; SpanExportResult:
        &quot;&quot;&quot;Export spans to file.

        Args:
            spans: Spans to export

        Returns:
            Export result status
        &quot;&quot;&quot;
        try:
            with open(self.session_file, &quot;a&quot;) as f:
                for span in spans:
                    # Convert span to JSON-serializable format
                    span_data = {
                        &quot;type&quot;: &quot;span&quot;,
                        &quot;name&quot;: span.name,
                        &quot;trace_id&quot;: format_trace_id(span.context.trace_id),
                        &quot;span_id&quot;: format_span_id(span.context.span_id),
                        &quot;parent_span_id&quot;: format_span_id(span.parent.span_id) if span.parent else None,
                        &quot;start_time&quot;: span.start_time,
                        &quot;end_time&quot;: span.end_time,
                        &quot;duration_ms&quot;: (span.end_time - span.start_time) / 1_000_000 if span.end_time else None,
                        &quot;status&quot;: {
                            &quot;status_code&quot;: span.status.status_code.name,
                            &quot;description&quot;: span.status.description,
                        },
                        &quot;attributes&quot;: dict(span.attributes or {}),
                        &quot;events&quot;: [
                            {
                                &quot;name&quot;: event.name,
                                &quot;timestamp&quot;: event.timestamp,
                                &quot;attributes&quot;: dict(event.attributes or {}),
                            }
                            for event in span.events
                        ],
                        &quot;resource&quot;: dict(span.resource.attributes),
                    }

                    # Handle exceptions
                    if span.status.status_code.name == &quot;ERROR&quot; and span.events:
                        for event in span.events:
                            if event.name == &quot;exception&quot;:
                                span_data[&quot;exception&quot;] = dict(event.attributes or {})

                    f.write(json.dumps(span_data, default=str) + &quot;\n&quot;)

            return SpanExportResult.SUCCESS

        except Exception as e:
            print(f&quot;[Telemetry Debug] Failed to write spans: {e}&quot;)
            return SpanExportResult.FAILURE

    def shutdown(self) -&gt; None:
        &quot;&quot;&quot;Shutdown the exporter.&quot;&quot;&quot;
        # Write session end marker
        try:
            with open(self.session_file, &quot;a&quot;) as f:
                f.write(
                    json.dumps(
                        {
                            &quot;type&quot;: &quot;session_end&quot;,
                            &quot;timestamp&quot;: datetime.now().isoformat(),
                        }
                    )
                    + &quot;\n&quot;
                )
        except Exception:
            pass


class DebugConsoleSpanExporter(SpanExporter):
    &quot;&quot;&quot;Exports spans to console for debugging.&quot;&quot;&quot;

    def export(self, spans: Sequence[ReadableSpan]) -&gt; SpanExportResult:
        &quot;&quot;&quot;Export spans to console.

        Args:
            spans: Spans to export

        Returns:
            Export result status
        &quot;&quot;&quot;
        try:
            for span in spans:
                duration_ms = (span.end_time - span.start_time) / 1_000_000 if span.end_time else 0

                print(f&quot;\n[Telemetry] {span.name}&quot;)
                print(f&quot;  Duration: {duration_ms:.2f}ms&quot;)
                print(f&quot;  Status: {span.status.status_code.name}&quot;)

                if span.attributes:
                    print(&quot;  Attributes:&quot;)
                    for key, value in span.attributes.items():
                        print(f&quot;    {key}: {value}&quot;)

                if span.events:
                    print(&quot;  Events:&quot;)
                    for event in span.events:
                        print(f&quot;    - {event.name}&quot;)
                        if event.attributes:
                            for key, value in event.attributes.items():
                                print(f&quot;      {key}: {value}&quot;)

                if span.status.description:
                    print(f&quot;  Error: {span.status.description}&quot;)

            return SpanExportResult.SUCCESS

        except Exception as e:
            print(f&quot;[Telemetry Debug] Console export failed: {e}&quot;)
            return SpanExportResult.FAILURE

    def shutdown(self) -&gt; None:
        &quot;&quot;&quot;Shutdown the exporter.&quot;&quot;&quot;
        pass</file><file path="src/codegen/cli/telemetry/exception_logger.py">&quot;&quot;&quot;Global exception logging for CLI telemetry.

This module provides a global exception handler that captures unhandled exceptions
and logs them through the existing OpenTelemetry telemetry system.
&quot;&quot;&quot;

import sys
import traceback
from typing import Any

from codegen.shared.logging.get_logger import get_logger
from codegen.cli.telemetry.otel_setup import get_session_uuid, get_otel_logging_handler
from codegen.cli.telemetry.consent import ensure_telemetry_consent

# Initialize logger for exception handling
logger = get_logger(__name__)

# Store the original excepthook to allow chaining
_original_excepthook = sys.excepthook


def _get_exception_context(exc_type: type[BaseException], exc_value: BaseException, tb: Any) -&gt; dict[str, Any]:
    &quot;&quot;&quot;Extract relevant context from an exception for logging.

    Args:
        exc_type: The exception type
        exc_value: The exception instance
        tb: The traceback object

    Returns:
        Dictionary with exception context for structured logging
    &quot;&quot;&quot;
    context = {
        &quot;operation&quot;: &quot;cli.unhandled_exception&quot;,
        &quot;exception_type&quot;: exc_type.__name__,
        &quot;exception_message&quot;: str(exc_value),
        &quot;session_id&quot;: get_session_uuid(),
    }

    # Add module and function information from the traceback
    if tb is not None:
        # Get the last frame (where the exception occurred)
        last_frame = tb
        while last_frame.tb_next is not None:
            last_frame = last_frame.tb_next

        frame = last_frame.tb_frame
        context.update(
            {
                &quot;exception_file&quot;: frame.f_code.co_filename,
                &quot;exception_function&quot;: frame.f_code.co_name,
                &quot;exception_line&quot;: last_frame.tb_lineno,
            }
        )

        # Get the full stack trace as a string
        context[&quot;stack_trace&quot;] = &quot;&quot;.join(traceback.format_exception(exc_type, exc_value, tb))

        # Add command context if available from CLI args
        try:
            # Try to extract command information from sys.argv
            if len(sys.argv) &gt; 1:
                context[&quot;cli_command&quot;] = sys.argv[1]
                context[&quot;cli_args&quot;] = sys.argv[2:] if len(sys.argv) &gt; 2 else []
        except Exception:
            # Don&apos;t let context extraction break exception logging
            pass

    return context


def global_exception_handler(exc_type: type[BaseException], exc_value: BaseException, tb: Any) -&gt; None:
    &quot;&quot;&quot;Global exception handler that logs unhandled exceptions.

    This function is designed to be set as sys.excepthook to capture all unhandled
    exceptions in the CLI and log them through the telemetry system.

    Args:
        exc_type: The exception type
        exc_value: The exception instance
        tb: The traceback object
    &quot;&quot;&quot;
    # Skip logging for KeyboardInterrupt (Ctrl+C) - this is expected user behavior
    if issubclass(exc_type, KeyboardInterrupt):
        # Call the original excepthook for normal handling
        _original_excepthook(exc_type, exc_value, tb)
        return

    # Skip logging for SystemExit with code 0 (normal exit)
    if issubclass(exc_type, SystemExit) and getattr(exc_value, &quot;code&quot;, None) == 0:
        _original_excepthook(exc_type, exc_value, tb)
        return

    try:
        # Check telemetry configuration to determine logging behavior
        telemetry_config = ensure_telemetry_consent()

        # Extract context for structured logging
        context = _get_exception_context(exc_type, exc_value, tb)

        # Always send to telemetry backend if enabled (regardless of debug mode)
        if telemetry_config.enabled:
            # Get the OpenTelemetry handler for backend logging
            otel_handler = get_otel_logging_handler()
            if otel_handler:
                # Create a separate logger that only sends to OTEL backend
                import logging

                telemetry_logger = logging.getLogger(&quot;codegen.telemetry.exceptions&quot;)
                telemetry_logger.setLevel(logging.ERROR)

                # Remove any existing handlers to avoid console output
                telemetry_logger.handlers.clear()
                telemetry_logger.addHandler(otel_handler)
                telemetry_logger.propagate = False  # Don&apos;t propagate to parent loggers

                # Log to telemetry backend only
                telemetry_logger.error(f&quot;Unhandled CLI exception: {exc_type.__name__}: {exc_value}&quot;, extra=context, exc_info=(exc_type, exc_value, tb))

        # Only log to console if debug mode is enabled
        if telemetry_config.debug:
            logger.error(f&quot;Unhandled CLI exception: {exc_type.__name__}: {exc_value}&quot;, extra=context, exc_info=(exc_type, exc_value, tb))
            logger.debug(&quot;Exception details logged for telemetry&quot;, extra={&quot;operation&quot;: &quot;cli.exception_logging&quot;, &quot;session_id&quot;: get_session_uuid()})

    except Exception as logging_error:
        # If logging itself fails, at least print to stderr in debug mode or if telemetry is disabled
        try:
            telemetry_config = ensure_telemetry_consent()
            if telemetry_config.debug or not telemetry_config.enabled:
                print(f&quot;Failed to log exception: {logging_error}&quot;, file=sys.stderr)
                print(f&quot;Original exception: {exc_type.__name__}: {exc_value}&quot;, file=sys.stderr)
        except Exception:
            # If even the telemetry config check fails, always print to stderr
            print(f&quot;Failed to log exception: {logging_error}&quot;, file=sys.stderr)
            print(f&quot;Original exception: {exc_type.__name__}: {exc_value}&quot;, file=sys.stderr)

    # Always call the original excepthook to preserve normal error handling behavior
    _original_excepthook(exc_type, exc_value, tb)


def setup_global_exception_logging() -&gt; None:
    &quot;&quot;&quot;Set up global exception logging by installing the custom excepthook.

    This should be called early in the CLI initialization to ensure all unhandled
    exceptions are captured and logged.
    &quot;&quot;&quot;
    # Only install if not already installed (avoid double installation)
    if sys.excepthook != global_exception_handler:
        sys.excepthook = global_exception_handler

        # Only log setup message to console if debug mode is enabled
        try:
            telemetry_config = ensure_telemetry_consent()
            if telemetry_config.debug:
                logger.debug(&quot;Global exception logging enabled&quot;, extra={&quot;operation&quot;: &quot;cli.exception_logging_setup&quot;, &quot;session_id&quot;: get_session_uuid()})
        except Exception:
            # If we can&apos;t check telemetry config, silently continue
            pass


def teardown_global_exception_logging() -&gt; None:
    &quot;&quot;&quot;Restore the original exception handler.

    This can be called during cleanup to restore normal exception handling.
    &quot;&quot;&quot;
    if sys.excepthook == global_exception_handler:
        sys.excepthook = _original_excepthook

        # Only log teardown message to console if debug mode is enabled
        try:
            telemetry_config = ensure_telemetry_consent()
            if telemetry_config.debug:
                logger.debug(&quot;Global exception logging disabled&quot;, extra={&quot;operation&quot;: &quot;cli.exception_logging_teardown&quot;, &quot;session_id&quot;: get_session_uuid()})
        except Exception:
            # If we can&apos;t check telemetry config, silently continue
            pass</file><file path="src/codegen/cli/telemetry/otel_setup.py">&quot;&quot;&quot;Simple OpenTelemetry logging setup for CLI telemetry.

This module provides a clean, minimal setup for sending CLI logs to the
OTLP collector when telemetry is enabled by the user.
&quot;&quot;&quot;

import logging
import os
import platform
import subprocess
import sys
import uuid
from typing import Any

from opentelemetry import _logs as logs
from opentelemetry.exporter.otlp.proto.http._log_exporter import OTLPLogExporter
from opentelemetry.sdk._logs import LoggerProvider, LoggingHandler
from opentelemetry.sdk._logs.export import BatchLogRecordProcessor
from opentelemetry.sdk.resources import Resource

from codegen import __version__
from codegen.cli.api.modal import get_modal_prefix
from codegen.cli.auth.token_manager import TokenManager
from codegen.cli.env.enums import Environment
from codegen.cli.env.global_env import global_env
from codegen.cli.utils.org import resolve_org_id
from codegen.configs.models.telemetry import TelemetryConfig

# Global logger provider instance
_logger_provider: LoggerProvider | None = None

# Global session UUID for this CLI invocation
_session_uuid: str = str(uuid.uuid4())


def _get_otlp_logs_endpoint() -&gt; tuple[str, dict[str, str]]:
    &quot;&quot;&quot;Get the OTLP logs endpoint and headers based on environment.

    This replicates the backend logic for determining the correct collector endpoint
    based on whether we&apos;re running in Kubernetes or Modal environment.

    Returns:
        Tuple of (endpoint_url, headers_dict)
    &quot;&quot;&quot;
    # Check if we&apos;re running in Kubernetes by looking for K8S_POD_NAME env var
    k8s_pod_name = os.environ.get(&quot;K8S_POD_NAME&quot;)
    if k8s_pod_name:
        # Running in Kubernetes - use Grafana Alloy
        return &quot;http://grafana-monitoring-staging-alloy-receiver.monitoring.svc.cluster.local:4318/v1/logs&quot;, {}

    # Running in Modal - use Modal OTEL collector
    modal_prefix = get_modal_prefix()
    suffix = &quot;otel-collector.modal.run&quot;

    if global_env.ENV == Environment.PRODUCTION:
        collector_endpoint = f&quot;https://{modal_prefix}--{suffix}/cli/v1/logs&quot;
    elif global_env.ENV == Environment.STAGING:
        collector_endpoint = f&quot;https://{modal_prefix}--{suffix}/cli/v1/logs&quot;
    else:  # DEVELOPMENT
        collector_endpoint = f&quot;https://{modal_prefix}--{suffix}/cli/v1/logs&quot;

    # Create basic auth header for Modal collector
    token_manager = TokenManager()
    token = token_manager.get_token()
    if not token:
        # Return empty headers if no auth configured
        return collector_endpoint, {}

    return collector_endpoint, {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}


def _get_claude_info() -&gt; dict[str, str]:
    &quot;&quot;&quot;Get Claude Code path and version information quickly.&quot;&quot;&quot;
    claude_info = {}

    try:
        # Use the same logic as the Claude command to find the CLI
        # Import here to avoid circular imports
        try:
            from codegen.cli.commands.claude.utils import resolve_claude_path

            claude_path = resolve_claude_path()
        except ImportError:
            # Fallback to basic path detection if utils not available
            claude_path = None

            # Quick check in PATH first
            import shutil

            claude_path = shutil.which(&quot;claude&quot;)

            # If not found, check common local paths
            if not claude_path:
                local_path = os.path.expanduser(&quot;~/.claude/local/claude&quot;)
                if os.path.isfile(local_path) and os.access(local_path, os.X_OK):
                    claude_path = local_path

        if claude_path:
            claude_info[&quot;claude.path&quot;] = claude_path

            # Only get version if we found the path - use short timeout
            try:
                version_result = subprocess.run(
                    [claude_path, &quot;--version&quot;],
                    capture_output=True,
                    text=True,
                    timeout=3,  # Short timeout for telemetry setup
                )
                if version_result.returncode == 0:
                    version_output = version_result.stdout.strip()
                    claude_info[&quot;claude.version&quot;] = version_output if version_output else &quot;unknown&quot;
                else:
                    claude_info[&quot;claude.version&quot;] = &quot;check_failed&quot;
            except (subprocess.TimeoutExpired, Exception):
                claude_info[&quot;claude.version&quot;] = &quot;check_timeout&quot;
        else:
            claude_info[&quot;claude.available&quot;] = &quot;false&quot;

    except Exception:
        # If anything fails, mark as error but don&apos;t break telemetry setup
        claude_info[&quot;claude.available&quot;] = &quot;detection_error&quot;

    return claude_info


def _create_cli_resource(telemetry_config: TelemetryConfig) -&gt; Resource:
    &quot;&quot;&quot;Create OpenTelemetry resource with CLI-specific attributes.&quot;&quot;&quot;
    global _session_uuid

    # Base service attributes
    resource_attributes: dict[str, Any] = {
        &quot;service.name&quot;: &quot;codegen-cli&quot;,
        &quot;service.version&quot;: __version__,
        &quot;session.id&quot;: _session_uuid,  # Unique UUID for this CLI invocation
        &quot;os.type&quot;: platform.system().lower(),
        &quot;os.version&quot;: platform.version(),
        &quot;python.version&quot;: sys.version.split()[0],
    }

    # Add user context if logged in
    try:
        # Try to get the current user ID (if authenticated)
        auth_data = TokenManager().get_auth_data()
        if auth_data:
            user = auth_data.get(&quot;user&quot;)
            if user:
                resource_attributes[&quot;user.id&quot;] = str(user.get(&quot;id&quot;))

            organization = auth_data.get(&quot;organization&quot;)
            if organization:
                resource_attributes[&quot;organization.id&quot;] = str(organization.get(&quot;id&quot;))
                resource_attributes[&quot;cli_session_id&quot;] = _session_uuid

    except Exception:
        # If user ID lookup fails, continue without it
        pass

    # Add organization context if available
    try:
        org_id = resolve_org_id()
        if org_id:
            resource_attributes[&quot;org.id&quot;] = str(org_id)
    except Exception:
        # If org ID lookup fails, continue without it
        pass

    # Add environment context
    if os.environ.get(&quot;CI&quot;):
        resource_attributes[&quot;deployment.environment&quot;] = &quot;ci&quot;
    elif os.environ.get(&quot;CODESPACES&quot;):
        resource_attributes[&quot;deployment.environment&quot;] = &quot;codespaces&quot;
    elif os.environ.get(&quot;GITPOD_WORKSPACE_ID&quot;):
        resource_attributes[&quot;deployment.environment&quot;] = &quot;gitpod&quot;
    else:
        resource_attributes[&quot;deployment.environment&quot;] = &quot;local&quot;

    # Add Claude Code information
    claude_info = _get_claude_info()
    resource_attributes.update(claude_info)

    return Resource.create(resource_attributes)


def setup_otel_logging() -&gt; LoggerProvider | None:
    &quot;&quot;&quot;Set up OpenTelemetry logging if telemetry is enabled.

    Returns:
        LoggerProvider if telemetry is enabled and setup succeeds, None otherwise
    &quot;&quot;&quot;
    global _logger_provider

    # Return cached provider if already set up
    if _logger_provider is not None:
        return _logger_provider

    # Ensure telemetry consent and load configuration
    from codegen.cli.telemetry.consent import ensure_telemetry_consent

    telemetry_config = ensure_telemetry_consent()

    # Only set up if explicitly enabled
    if not telemetry_config.enabled:
        return None

    try:
        # Create resource with CLI metadata
        resource = _create_cli_resource(telemetry_config)

        # Create logger provider
        logger_provider = LoggerProvider(resource=resource)

        # Get OTLP endpoint and headers
        endpoint, headers = _get_otlp_logs_endpoint()

        # Create OTLP log exporter
        log_exporter = OTLPLogExporter(
            endpoint=endpoint,
            headers=headers,
            timeout=10,  # 10 second timeout
        )

        # Create batch processor for performance
        log_processor = BatchLogRecordProcessor(
            log_exporter,
            max_queue_size=1024,
            max_export_batch_size=256,
            export_timeout_millis=10000,  # 10 seconds
            schedule_delay_millis=2000,  # Export every 2 seconds
        )

        logger_provider.add_log_record_processor(log_processor)

        # Set as global provider
        logs.set_logger_provider(logger_provider)
        _logger_provider = logger_provider

        # Debug output if enabled
        if telemetry_config.debug:
            print(f&quot;[Telemetry] Logging initialized with endpoint: {endpoint}&quot;)
            print(f&quot;[Telemetry] Session UUID: {_session_uuid}&quot;)
            # Show key resource attributes
            resource_attrs = resource.attributes
            if &quot;user.id&quot; in resource_attrs:
                print(f&quot;[Telemetry] User ID: {resource_attrs[&apos;user.id&apos;]}&quot;)
            if &quot;org.id&quot; in resource_attrs:
                print(f&quot;[Telemetry] Org ID: {resource_attrs[&apos;org.id&apos;]}&quot;)
            if &quot;claude.path&quot; in resource_attrs:
                print(f&quot;[Telemetry] Claude Path: {resource_attrs[&apos;claude.path&apos;]}&quot;)
            if &quot;claude.version&quot; in resource_attrs:
                print(f&quot;[Telemetry] Claude Version: {resource_attrs[&apos;claude.version&apos;]}&quot;)
            elif &quot;claude.available&quot; in resource_attrs:
                print(f&quot;[Telemetry] Claude Available: {resource_attrs[&apos;claude.available&apos;]}&quot;)

        return logger_provider

    except Exception as e:
        if telemetry_config.debug:
            print(f&quot;[Telemetry] Failed to initialize logging: {e}&quot;)
        return None


def get_otel_logging_handler() -&gt; logging.Handler | None:
    &quot;&quot;&quot;Get an OpenTelemetry logging handler.

    This handler will send logs to the OTLP collector when telemetry is enabled.

    Returns:
        LoggingHandler if telemetry is enabled, None otherwise
    &quot;&quot;&quot;
    logger_provider = setup_otel_logging()
    if logger_provider is None:
        return None

    # Create handler that bridges Python logging to OpenTelemetry
    handler = LoggingHandler(level=logging.NOTSET, logger_provider=logger_provider)
    return handler


def get_session_uuid() -&gt; str:
    &quot;&quot;&quot;Get the session UUID for this CLI invocation.

    Returns:
        The session UUID string that uniquely identifies this CLI run
    &quot;&quot;&quot;
    global _session_uuid
    return _session_uuid


def shutdown_otel_logging():
    &quot;&quot;&quot;Gracefully shutdown OpenTelemetry logging and flush pending data.&quot;&quot;&quot;
    global _logger_provider

    if _logger_provider is not None:
        try:
            # Type checker workaround: assert that provider is not None after the check
            assert _logger_provider is not None
            _logger_provider.shutdown()
        except Exception:
            pass  # Ignore shutdown errors
        _logger_provider = None</file><file path="src/codegen/cli/telemetry/viewer.py">&quot;&quot;&quot;Simple telemetry log viewer for debugging.

This script provides utilities for analyzing telemetry debug logs.
&quot;&quot;&quot;

import json
from pathlib import Path
from typing import Any

from rich.console import Console
from rich.tree import Tree

from codegen.configs.constants import GLOBAL_CONFIG_DIR


def load_session(session_file: Path) -&gt; list[dict[str, Any]]:
    &quot;&quot;&quot;Load all records from a session file.&quot;&quot;&quot;
    records = []
    with open(session_file) as f:
        for line in f:
            records.append(json.loads(line))
    return records


def print_span_tree(spans: list[dict[str, Any]], console: Console):
    &quot;&quot;&quot;Print spans as a tree structure.&quot;&quot;&quot;
    # Build parent-child relationships
    span_by_id = {span[&quot;span_id&quot;]: span for span in spans}
    root_spans = []

    for span in spans:
        if not span.get(&quot;parent_span_id&quot;) or span[&quot;parent_span_id&quot;] not in span_by_id:
            root_spans.append(span)

    # Create tree
    tree = Tree(&quot;Telemetry Trace Tree&quot;)

    def add_span_to_tree(span: dict[str, Any], parent_node):
        &quot;&quot;&quot;Recursively add span and its children to tree.&quot;&quot;&quot;
        duration = span.get(&quot;duration_ms&quot;, 0)
        status = span[&quot;status&quot;][&quot;status_code&quot;]
        status_icon = &quot;âœ…&quot; if status == &quot;OK&quot; else &quot;âŒ&quot;

        label = f&quot;{status_icon} {span[&apos;name&apos;]} ({duration:.2f}ms)&quot;
        node = parent_node.add(label)

        # Add key attributes
        attrs = span.get(&quot;attributes&quot;, {})
        for key, value in attrs.items():
            if key.startswith(&quot;cli.&quot;) or key.startswith(&quot;event.&quot;):
                node.add(f&quot;[dim]{key}: {value}[/dim]&quot;)

        # Find children
        for other_span in spans:
            if other_span.get(&quot;parent_span_id&quot;) == span[&quot;span_id&quot;]:
                add_span_to_tree(other_span, node)

    # Add root spans
    for root_span in root_spans:
        add_span_to_tree(root_span, tree)

    console.print(tree)


def analyze_session(session_file: Path):
    &quot;&quot;&quot;Analyze a telemetry session file.&quot;&quot;&quot;
    console = Console()

    console.print(f&quot;\n[bold]Analyzing session:[/bold] {session_file.name}\n&quot;)

    records = load_session(session_file)
    spans = [r for r in records if r[&quot;type&quot;] == &quot;span&quot;]

    if not spans:
        console.print(&quot;[yellow]No spans found in session[/yellow]&quot;)
        return

    # Basic stats
    total_duration = sum(s.get(&quot;duration_ms&quot;, 0) for s in spans)
    error_count = sum(1 for s in spans if s[&quot;status&quot;][&quot;status_code&quot;] == &quot;ERROR&quot;)

    console.print(f&quot;[cyan]Total spans:[/cyan] {len(spans)}&quot;)
    console.print(f&quot;[cyan]Total duration:[/cyan] {total_duration:.2f}ms&quot;)
    console.print(f&quot;[cyan]Errors:[/cyan] {error_count}&quot;)
    console.print()

    # Show errors if any
    if error_count &gt; 0:
        console.print(&quot;[bold red]Errors:[/bold red]&quot;)
        for span in spans:
            if span[&quot;status&quot;][&quot;status_code&quot;] == &quot;ERROR&quot;:
                console.print(f&quot;  - {span[&apos;name&apos;]}: {span[&apos;status&apos;].get(&apos;description&apos;, &apos;Unknown error&apos;)}&quot;)
        console.print()

    # Show span tree
    print_span_tree(spans, console)

    # Show slowest operations
    console.print(&quot;\n[bold]Slowest Operations:[/bold]&quot;)
    sorted_spans = sorted(spans, key=lambda s: s.get(&quot;duration_ms&quot;, 0), reverse=True)
    for span in sorted_spans[:5]:
        duration = span.get(&quot;duration_ms&quot;, 0)
        console.print(f&quot;  - {span[&apos;name&apos;]}: {duration:.2f}ms&quot;)


def latest_session() -&gt; Path | None:
    &quot;&quot;&quot;Get the latest session file.&quot;&quot;&quot;
    debug_dir = GLOBAL_CONFIG_DIR / &quot;telemetry_debug&quot;
    if not debug_dir.exists():
        return None

    session_files = sorted(debug_dir.glob(&quot;session_*.jsonl&quot;), reverse=True)
    return session_files[0] if session_files else None


if __name__ == &quot;__main__&quot;:
    # Simple CLI for viewing logs
    import sys

    if len(sys.argv) &gt; 1:
        session_file = Path(sys.argv[1])
    else:
        session_file = latest_session()

    if session_file and session_file.exists():
        analyze_session(session_file)
    else:
        print(&quot;No session file found. Run with debug enabled first.&quot;)
        print(&quot;Usage: python -m codegen.cli.telemetry.viewer [session_file.jsonl]&quot;)</file><file path="src/codegen/cli/tui/__init__.py">&quot;&quot;&quot;TUI (Terminal User Interface) module for Codegen CLI.&quot;&quot;&quot;</file><file path="src/codegen/cli/tui/agent_detail.py">&quot;&quot;&quot;Agent Detail TUI screen for viewing individual agent runs.&quot;&quot;&quot;

import asyncio
import json
from pathlib import Path
from typing import Any, Dict

import requests
from textual.app import ComposeResult
from textual.binding import Binding
from textual.containers import Container, Vertical, Horizontal
from textual.screen import Screen
from textual.widgets import Button, Footer, Header, Static, DataTable

from codegen.cli.auth.token_manager import get_current_token
from codegen.cli.utils.org import resolve_org_id
from codegen.cli.api.endpoints import API_ENDPOINT
from codegen.git.repo_operator.local_git_repo import LocalGitRepo


class AgentDetailTUI(Screen):
    &quot;&quot;&quot;TUI screen for viewing agent run details and performing actions.&quot;&quot;&quot;

    CSS_PATH = &quot;codegen_theme.tcss&quot;
    BINDINGS = [
        Binding(&quot;escape,q&quot;, &quot;back&quot;, &quot;Back&quot;, show=True),
        Binding(&quot;j&quot;, &quot;view_json&quot;, &quot;View JSON&quot;, show=True),
        Binding(&quot;p&quot;, &quot;pull_branch&quot;, &quot;Pull Branch&quot;, show=True),
        Binding(&quot;w&quot;, &quot;open_web&quot;, &quot;Open Web&quot;, show=True),
    ]

    def __init__(self, agent_run: Dict[str, Any], org_id: int | None = None):
        super().__init__()
        self.agent_run = agent_run
        self.org_id = org_id or resolve_org_id()
        self.agent_data: Dict[str, Any] | None = None
        self.is_loading = False

    def compose(self) -&gt; ComposeResult:
        &quot;&quot;&quot;Create child widgets for the agent detail screen.&quot;&quot;&quot;
        run_id = self.agent_run.get(&quot;id&quot;, &quot;Unknown&quot;)
        summary = self.agent_run.get(&quot;summary&quot;, &quot;No summary available&quot;)
        
        yield Header()
        
        with Vertical():
            yield Static(f&quot;ðŸ¤– Agent Run Details - ID: {run_id}&quot;, classes=&quot;title&quot;, id=&quot;detail-title&quot;)
            yield Static(&quot;Use J for JSON, P to pull branch, W for web, Q/Esc to go back&quot;, classes=&quot;help&quot;)
            
            # Basic info section
            info_table = DataTable(id=&quot;info-table&quot;, cursor_type=&quot;none&quot;)
            info_table.add_columns(&quot;Property&quot;, &quot;Value&quot;)
            yield info_table
            
            # Actions section
            with Horizontal(id=&quot;actions-section&quot;):
                yield Button(&quot;ðŸ“„ View JSON&quot;, id=&quot;json-btn&quot;, variant=&quot;primary&quot;)
                yield Button(&quot;ðŸ”€ Pull Branch&quot;, id=&quot;pull-btn&quot;, variant=&quot;default&quot;)
                yield Button(&quot;ðŸŒ Open Web&quot;, id=&quot;web-btn&quot;, variant=&quot;default&quot;)
                yield Button(&quot;â¬…ï¸ Back&quot;, id=&quot;back-btn&quot;, variant=&quot;default&quot;)
            
            # Status/loading area
            yield Static(&quot;&quot;, id=&quot;status-text&quot;)
            
        yield Footer()

    def on_mount(self) -&gt; None:
        &quot;&quot;&quot;Called when the screen is mounted.&quot;&quot;&quot;
        self._populate_basic_info()
        # Load detailed data in background
        task = asyncio.create_task(self._load_detailed_data())
        self._load_task = task

    def _populate_basic_info(self) -&gt; None:
        &quot;&quot;&quot;Populate the info table with basic agent run information.&quot;&quot;&quot;
        info_table = self.query_one(&quot;#info-table&quot;, DataTable)
        
        # Basic info from the agent run data
        run_id = self.agent_run.get(&quot;id&quot;, &quot;Unknown&quot;)
        status = self.agent_run.get(&quot;status&quot;, &quot;Unknown&quot;)
        created_at = self.agent_run.get(&quot;created_at&quot;, &quot;Unknown&quot;)
        summary = self.agent_run.get(&quot;summary&quot;, &quot;No summary available&quot;)
        web_url = self.agent_run.get(&quot;web_url&quot;, &quot;Not available&quot;)

        # Format status with emoji
        status_display = status
        if status == &quot;COMPLETE&quot;:
            status_display = &quot;âœ… Complete&quot;
        elif status == &quot;RUNNING&quot;:
            status_display = &quot;ðŸƒ Running&quot;
        elif status == &quot;FAILED&quot;:
            status_display = &quot;âŒ Failed&quot;
        elif status == &quot;STOPPED&quot;:
            status_display = &quot;â¹ï¸ Stopped&quot;
        elif status == &quot;PENDING&quot;:
            status_display = &quot;â³ Pending&quot;

        # Add rows to info table
        info_table.add_row(&quot;ID&quot;, str(run_id))
        info_table.add_row(&quot;Status&quot;, status_display)
        info_table.add_row(&quot;Created&quot;, created_at)
        info_table.add_row(&quot;Summary&quot;, summary)
        info_table.add_row(&quot;Web URL&quot;, web_url)

    async def _load_detailed_data(self) -&gt; None:
        &quot;&quot;&quot;Load detailed agent run data from the API.&quot;&quot;&quot;
        if self.is_loading:
            return
            
        self.is_loading = True
        status_text = self.query_one(&quot;#status-text&quot;, Static)
        status_text.update(&quot;ðŸ”„ Loading detailed agent data...&quot;)

        try:
            token = get_current_token()
            if not token:
                status_text.update(&quot;âŒ Not authenticated&quot;)
                return

            run_id = self.agent_run.get(&quot;id&quot;)
            if not run_id:
                status_text.update(&quot;âŒ No agent run ID available&quot;)
                return

            headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}
            url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{self.org_id}/agent/run/{run_id}&quot;
            
            response = requests.get(url, headers=headers)
            response.raise_for_status()
            self.agent_data = response.json()
            
            # Update info table with additional details
            self._update_info_with_detailed_data()
            status_text.update(&quot;âœ… Agent data loaded successfully&quot;)
            
        except requests.HTTPError as e:
            if e.response.status_code == 404:
                status_text.update(f&quot;âŒ Agent run {run_id} not found&quot;)
            elif e.response.status_code == 403:
                status_text.update(f&quot;âŒ Access denied to agent run {run_id}&quot;)
            else:
                status_text.update(f&quot;âŒ HTTP {e.response.status_code}: {e}&quot;)
        except Exception as e:
            status_text.update(f&quot;âŒ Error loading data: {e}&quot;)
        finally:
            self.is_loading = False

    def _update_info_with_detailed_data(self) -&gt; None:
        &quot;&quot;&quot;Update the info table with detailed data from the API.&quot;&quot;&quot;
        if not self.agent_data:
            return
            
        info_table = self.query_one(&quot;#info-table&quot;, DataTable)
        
        # Check for GitHub PRs
        github_prs = self.agent_data.get(&quot;github_pull_requests&quot;, [])
        if github_prs:
            pr_info = f&quot;{len(github_prs)} PR(s) available&quot;
            for i, pr in enumerate(github_prs[:3]):  # Show up to 3 PRs
                branch = pr.get(&quot;head&quot;, {}).get(&quot;ref&quot;, &quot;unknown&quot;)
                pr_info += f&quot;\n  â€¢ {branch}&quot;
            if len(github_prs) &gt; 3:
                pr_info += f&quot;\n  â€¢ ... and {len(github_prs) - 3} more&quot;
        else:
            pr_info = &quot;No PRs available&quot;
            
        info_table.add_row(&quot;PR Branches&quot;, pr_info)
        
        # Add model info if available
        model = self.agent_data.get(&quot;model&quot;, &quot;Unknown&quot;)
        info_table.add_row(&quot;Model&quot;, model)

    # Action handlers
    def action_back(self) -&gt; None:
        &quot;&quot;&quot;Go back to the main screen.&quot;&quot;&quot;
        self.app.pop_screen()

    def action_view_json(self) -&gt; None:
        &quot;&quot;&quot;View the full JSON data for the agent run.&quot;&quot;&quot;
        if not self.agent_data:
            self.notify(&quot;âŒ Detailed data not loaded yet&quot;, severity=&quot;error&quot;)
            return
            
        # Create a JSON viewer screen
        json_screen = JSONViewerTUI(self.agent_data)
        self.app.push_screen(json_screen)

    def action_pull_branch(self) -&gt; None:
        &quot;&quot;&quot;Pull the PR branch for this agent run.&quot;&quot;&quot;
        if not self.agent_data:
            self.notify(&quot;âŒ Detailed data not loaded yet&quot;, severity=&quot;error&quot;)
            return
            
        # Check if we&apos;re in a git repository
        try:
            current_repo = LocalGitRepo(Path.cwd())
            if not current_repo.has_remote():
                self.notify(&quot;âŒ Not in a git repository with remotes&quot;, severity=&quot;error&quot;)
                return
        except Exception:
            self.notify(&quot;âŒ Not in a valid git repository&quot;, severity=&quot;error&quot;)
            return

        # Check for GitHub PRs
        github_prs = self.agent_data.get(&quot;github_pull_requests&quot;, [])
        if not github_prs:
            self.notify(&quot;âŒ No PR branches available for this agent run&quot;, severity=&quot;error&quot;)
            return

        # For now, take the first PR - in the future we could show a selector
        pr = github_prs[0]
        branch_name = pr.get(&quot;head&quot;, {}).get(&quot;ref&quot;)
        repo_clone_url = pr.get(&quot;head&quot;, {}).get(&quot;repo&quot;, {}).get(&quot;clone_url&quot;)

        if not branch_name or not repo_clone_url:
            self.notify(&quot;âŒ Invalid PR data&quot;, severity=&quot;error&quot;)
            return

        # Start the pull process
        task = asyncio.create_task(self._pull_branch_async(branch_name, repo_clone_url))
        self._pull_task = task

    async def _pull_branch_async(self, branch_name: str, repo_clone_url: str) -&gt; None:
        &quot;&quot;&quot;Asynchronously pull the PR branch.&quot;&quot;&quot;
        status_text = self.query_one(&quot;#status-text&quot;, Static)
        status_text.update(f&quot;ðŸ”„ Pulling branch {branch_name}...&quot;)
        
        try:
            current_repo = LocalGitRepo(Path.cwd())
            
            # Add remote if it doesn&apos;t exist
            remote_name = &quot;codegen-pr&quot;
            try:
                current_repo.add_remote(remote_name, repo_clone_url)
            except Exception:
                # Remote might already exist
                pass
            
            # Fetch and checkout the branch
            current_repo.fetch_remote(remote_name)
            current_repo.checkout_branch(f&quot;{remote_name}/{branch_name}&quot;, branch_name)
            
            status_text.update(f&quot;âœ… Successfully checked out branch: {branch_name}&quot;)
            self.notify(f&quot;âœ… Switched to branch: {branch_name}&quot;)
            
        except Exception as e:
            error_msg = f&quot;âŒ Failed to pull branch: {e}&quot;
            status_text.update(error_msg)
            self.notify(error_msg, severity=&quot;error&quot;)

    def action_open_web(self) -&gt; None:
        &quot;&quot;&quot;Open the agent run in the web browser.&quot;&quot;&quot;
        web_url = self.agent_run.get(&quot;web_url&quot;)
        if not web_url:
            run_id = self.agent_run.get(&quot;id&quot;)
            web_url = f&quot;https://codegen.com/traces/{run_id}&quot;

        try:
            import webbrowser
            webbrowser.open(web_url)
            self.notify(f&quot;ðŸŒ Opened {web_url}&quot;)
        except Exception as e:
            self.notify(f&quot;âŒ Failed to open URL: {e}&quot;, severity=&quot;error&quot;)

    # Button event handlers
    def on_button_pressed(self, event: Button.Pressed) -&gt; None:
        &quot;&quot;&quot;Handle button press events.&quot;&quot;&quot;
        if event.button.id == &quot;json-btn&quot;:
            self.action_view_json()
        elif event.button.id == &quot;pull-btn&quot;:
            self.action_pull_branch()
        elif event.button.id == &quot;web-btn&quot;:
            self.action_open_web()
        elif event.button.id == &quot;back-btn&quot;:
            self.action_back()


class JSONViewerTUI(Screen):
    &quot;&quot;&quot;TUI screen for viewing JSON data.&quot;&quot;&quot;

    CSS_PATH = &quot;codegen_theme.tcss&quot;
    BINDINGS = [
        Binding(&quot;escape,q&quot;, &quot;back&quot;, &quot;Back&quot;, show=True),
    ]

    def __init__(self, data: Dict[str, Any]):
        super().__init__()
        self.data = data

    def compose(self) -&gt; ComposeResult:
        &quot;&quot;&quot;Create child widgets for the JSON viewer.&quot;&quot;&quot;
        yield Header()
        
        with Vertical():
            yield Static(&quot;ðŸ“„ Agent Run JSON Data&quot;, classes=&quot;title&quot;)
            yield Static(&quot;Use Q/Esc to go back&quot;, classes=&quot;help&quot;)
            
            # Format JSON with pretty printing
            try:
                json_text = json.dumps(self.data, indent=2, sort_keys=True)
                yield Static(json_text, id=&quot;json-content&quot;)
            except Exception as e:
                yield Static(f&quot;Error formatting JSON: {e}&quot;, id=&quot;json-content&quot;)
                
        yield Footer()

    def action_back(self) -&gt; None:
        &quot;&quot;&quot;Go back to the agent detail screen.&quot;&quot;&quot;
        self.app.pop_screen()</file><file path="src/codegen/cli/tui/app.py">&quot;&quot;&quot;Minimal TUI interface for Codegen CLI.&quot;&quot;&quot;

import signal
import sys
import termios
import threading
import time
import tty
from datetime import datetime
from typing import Any

import requests
import typer

from codegen.cli.api.endpoints import API_ENDPOINT
from codegen.cli.auth.token_manager import get_current_org_name, get_current_token
from codegen.cli.commands.agent.main import pull
from codegen.cli.commands.claude.main import _run_claude_interactive
from codegen.cli.utils.org import resolve_org_id
from codegen.cli.utils.url import generate_webapp_url, get_domain
from codegen.shared.logging.get_logger import get_logger

# Initialize logger for TUI telemetry
logger = get_logger(__name__)


class MinimalTUI:
    &quot;&quot;&quot;Minimal non-full-screen TUI for browsing agent runs.&quot;&quot;&quot;

    def __init__(self):
        # Log TUI initialization
        logger.info(&quot;TUI session started&quot;, extra={&quot;operation&quot;: &quot;tui.init&quot;, &quot;component&quot;: &quot;minimal_tui&quot;})

        self.token = get_current_token()
        self.is_authenticated = bool(self.token)
        if self.is_authenticated:
            self.org_id = resolve_org_id()
            logger.info(&quot;TUI authenticated successfully&quot;, extra={&quot;operation&quot;: &quot;tui.auth&quot;, &quot;org_id&quot;: self.org_id, &quot;authenticated&quot;: True})
        else:
            logger.warning(&quot;TUI started without authentication&quot;, extra={&quot;operation&quot;: &quot;tui.auth&quot;, &quot;authenticated&quot;: False})

        self.agent_runs: list[dict[str, Any]] = []
        self.selected_index = 0
        self.running = True
        self.show_action_menu = False
        self.action_menu_selection = 0

        # Tab management
        self.tabs = [&quot;recent&quot;, &quot;claude&quot;, &quot;new&quot;, &quot;kanban&quot;]
        self.current_tab = 0

        # Refresh state
        self.is_refreshing = False
        self.initial_loading = True  # Track if we&apos;re still doing the initial load
        self._auto_refresh_interval_seconds = 10
        self._refresh_lock = threading.Lock()

        # New tab state
        self.prompt_input = &quot;&quot;

        self.cursor_position = 0
        self.input_mode = False  # When true, we&apos;re typing in the input box

        # Set up signal handler for Ctrl+C
        signal.signal(signal.SIGINT, self._signal_handler)

        # Start background auto-refresh thread (daemon)
        self._auto_refresh_thread = threading.Thread(target=self._auto_refresh_loop, daemon=True)
        self._auto_refresh_thread.start()

        logger.debug(&quot;TUI initialization completed&quot;, extra={&quot;operation&quot;: &quot;tui.init&quot;, &quot;tabs&quot;: self.tabs, &quot;auto_refresh_interval&quot;: self._auto_refresh_interval_seconds})

    def _auto_refresh_loop(self):
        &quot;&quot;&quot;Background loop to auto-refresh recent tab every interval.&quot;&quot;&quot;
        while True:
            # Sleep first so we don&apos;t immediately spam a refresh on start
            time.sleep(self._auto_refresh_interval_seconds)

            if not self.running:
                break

            # Only refresh when on recent tab and not currently refreshing
            if self.current_tab == 0 and not self.is_refreshing:
                # Try background refresh; if lock is busy, skip this tick
                acquired = self._refresh_lock.acquire(blocking=False)
                if not acquired:
                    continue
                try:
                    # Double-check state after acquiring lock
                    if self.running and self.current_tab == 0 and not self.is_refreshing:
                        self._background_refresh()
                finally:
                    self._refresh_lock.release()

    def _background_refresh(self):
        &quot;&quot;&quot;Refresh data without disrupting selection/menu state; redraw if still on recent.&quot;&quot;&quot;
        self.is_refreshing = True
        # Do not redraw immediately to reduce flicker; header shows indicator on next paint

        previous_index = self.selected_index
        try:
            if self._load_agent_runs():
                # Preserve selection but clamp to new list bounds
                if self.agent_runs:
                    self.selected_index = max(0, min(previous_index, len(self.agent_runs) - 1))
                else:
                    self.selected_index = 0
        finally:
            self.is_refreshing = False

        # Redraw only if still on recent and app running
        if self.running and self.current_tab == 0:
            self._clear_and_redraw()

    def _get_webapp_domain(self) -&gt; str:
        &quot;&quot;&quot;Get the webapp domain based on environment.&quot;&quot;&quot;
        return get_domain()

    def _generate_agent_url(self, agent_id: str) -&gt; str:
        &quot;&quot;&quot;Generate the complete agent URL.&quot;&quot;&quot;
        return generate_webapp_url(f&quot;x/{agent_id}&quot;)

    def _signal_handler(self, signum, frame):
        &quot;&quot;&quot;Handle Ctrl+C gracefully without clearing screen.&quot;&quot;&quot;
        self.running = False
        print(&quot;\n&quot;)  # Just add a newline and exit
        sys.exit(0)

    def _format_status_line(self, left_text: str) -&gt; str:
        &quot;&quot;&quot;Format status line with instructions and org info on a new line below.&quot;&quot;&quot;
        # Get organization name
        org_name = get_current_org_name()
        if not org_name:
            org_name = f&quot;Org {self.org_id}&quot; if hasattr(self, &quot;org_id&quot;) and self.org_id else &quot;No Org&quot;

        # Use the same purple color as the Codegen logo
        purple_color = &quot;\033[38;2;82;19;217m&quot;
        reset_color = &quot;\033[0m&quot;

        # Return instructions on first line, org on second line (bottom left)
        instructions_line = f&quot;\033[90m{left_text}\033[0m&quot;
        org_line = f&quot;{purple_color}â€¢ {org_name}{reset_color}&quot;

        # Append a subtle refresh indicator when a refresh is in progress
        if getattr(self, &quot;is_refreshing&quot;, False):
            org_line += &quot;  \033[90mâ–  Refreshingâ€¦\033[0m&quot;

        return f&quot;{instructions_line}\n{org_line}&quot;

    def _load_agent_runs(self) -&gt; bool:
        &quot;&quot;&quot;Load the last 10 agent runs.&quot;&quot;&quot;
        if not self.token or not self.org_id:
            logger.warning(&quot;Cannot load agent runs - missing auth&quot;, extra={&quot;operation&quot;: &quot;tui.load_agent_runs&quot;, &quot;has_token&quot;: bool(self.token), &quot;has_org_id&quot;: bool(getattr(self, &quot;org_id&quot;, None))})
            return False

        start_time = time.time()

        # Only log debug info for initial load, not refreshes
        is_initial_load = not hasattr(self, &quot;_has_loaded_before&quot;)
        if is_initial_load:
            logger.debug(&quot;Loading agent runs&quot;, extra={&quot;operation&quot;: &quot;tui.load_agent_runs&quot;, &quot;org_id&quot;: self.org_id, &quot;is_initial_load&quot;: True})

        try:
            import requests

            from codegen.cli.api.endpoints import API_ENDPOINT

            headers = {&quot;Authorization&quot;: f&quot;Bearer {self.token}&quot;}

            # Get current user ID
            user_response = requests.get(f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/users/me&quot;, headers=headers)
            user_response.raise_for_status()
            user_data = user_response.json()
            user_id = user_data.get(&quot;id&quot;)

            # Fetch agent runs - limit to 10
            params = {
                &quot;source_type&quot;: &quot;API&quot;,
                &quot;limit&quot;: 10,
            }

            if user_id:
                params[&quot;user_id&quot;] = user_id

            url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{self.org_id}/agent/runs&quot;
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()
            response_data = response.json()

            self.agent_runs = response_data.get(&quot;items&quot;, [])
            self.initial_loading = False  # Mark initial loading as complete

            duration_ms = (time.time() - start_time) * 1000

            # Only log the initial load, not refreshes to avoid noise
            is_initial_load = not hasattr(self, &quot;_has_loaded_before&quot;)
            if is_initial_load:
                logger.info(
                    &quot;Agent runs loaded successfully&quot;,
                    extra={
                        &quot;operation&quot;: &quot;tui.load_agent_runs&quot;,
                        &quot;org_id&quot;: self.org_id,
                        &quot;user_id&quot;: user_id,
                        &quot;agent_count&quot;: len(self.agent_runs),
                        &quot;duration_ms&quot;: duration_ms,
                        &quot;is_initial_load&quot;: True,
                    },
                )

            # Mark that we&apos;ve loaded at least once
            self._has_loaded_before = True
            return True

        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            # Always log errors regardless of refresh vs initial load
            logger.error(
                &quot;Failed to load agent runs&quot;,
                extra={&quot;operation&quot;: &quot;tui.load_agent_runs&quot;, &quot;org_id&quot;: self.org_id, &quot;error_type&quot;: type(e).__name__, &quot;error_message&quot;: str(e), &quot;duration_ms&quot;: duration_ms},
                exc_info=True,
            )
            print(f&quot;Error loading agent runs: {e}&quot;)
            return False

    def _format_status(self, status: str, agent_run: dict | None = None) -&gt; tuple[str, str]:
        &quot;&quot;&quot;Format status with colored indicators matching kanban style.&quot;&quot;&quot;
        # Check if this agent has a merged PR (done status)
        is_done = False
        if agent_run:
            github_prs = agent_run.get(&quot;github_pull_requests&quot;, [])
            for pr in github_prs:
                if pr.get(&quot;state&quot;) == &quot;closed&quot; and pr.get(&quot;merged&quot;, False):
                    is_done = True
                    break

        if is_done:
            return &quot;\033[38;2;130;226;255mâœ“\033[0m&quot;, &quot;done&quot;  # aura blue #82e2ff checkmark for merged PR

        status_map = {
            &quot;COMPLETE&quot;: &quot;\033[38;2;66;196;153mâ—‹\033[0m&quot;,  # oklch(43.2% 0.095 166.913) â‰ˆ rgb(66,196,153) hollow circle
            &quot;ACTIVE&quot;: &quot;\033[38;2;162;119;255mâ—‹\033[0m&quot;,  # aura purple #a277ff (hollow circle)
            &quot;RUNNING&quot;: &quot;\033[38;2;162;119;255mâ—\033[0m&quot;,  # aura purple #a277ff
            &quot;ERROR&quot;: &quot;\033[38;2;255;103;103mâ—‹\033[0m&quot;,  # aura red #ff6767 (empty circle)
            &quot;FAILED&quot;: &quot;\033[38;2;255;103;103mâ—‹\033[0m&quot;,  # aura red #ff6767 (empty circle)
            &quot;CANCELLED&quot;: &quot;\033[38;2;109;109;109mâ—‹\033[0m&quot;,  # aura gray #6d6d6d
            &quot;STOPPED&quot;: &quot;\033[38;2;109;109;109mâ—‹\033[0m&quot;,  # aura gray #6d6d6d
            &quot;PENDING&quot;: &quot;\033[38;2;109;109;109mâ—‹\033[0m&quot;,  # aura gray #6d6d6d
            &quot;TIMEOUT&quot;: &quot;\033[38;2;255;202;133mâ—\033[0m&quot;,  # aura orange #ffca85
            &quot;MAX_ITERATIONS_REACHED&quot;: &quot;\033[38;2;255;202;133mâ—\033[0m&quot;,  # aura orange #ffca85
            &quot;OUT_OF_TOKENS&quot;: &quot;\033[38;2;255;202;133mâ—\033[0m&quot;,  # aura orange #ffca85
            &quot;EVALUATION&quot;: &quot;\033[38;2;246;148;255mâ—\033[0m&quot;,  # aura pink #f694ff
        }

        status_text_map = {
            &quot;COMPLETE&quot;: &quot;complete&quot;,
            &quot;ACTIVE&quot;: &quot;active&quot;,
            &quot;RUNNING&quot;: &quot;running&quot;,
            &quot;ERROR&quot;: &quot;error&quot;,
            &quot;FAILED&quot;: &quot;failed&quot;,
            &quot;CANCELLED&quot;: &quot;cancelled&quot;,
            &quot;STOPPED&quot;: &quot;stopped&quot;,
            &quot;PENDING&quot;: &quot;pending&quot;,
            &quot;TIMEOUT&quot;: &quot;timeout&quot;,
            &quot;MAX_ITERATIONS_REACHED&quot;: &quot;max iterations&quot;,
            &quot;OUT_OF_TOKENS&quot;: &quot;out of tokens&quot;,
            &quot;EVALUATION&quot;: &quot;evaluation&quot;,
        }

        circle = status_map.get(status, &quot;\033[37mâ—‹\033[0m&quot;)
        text = status_text_map.get(status, status.lower() if status else &quot;unknown&quot;)
        return circle, text

    def _format_pr_info(self, agent_run: dict) -&gt; str:
        &quot;&quot;&quot;Format PR information as &apos;PR #123&apos; or empty string.&quot;&quot;&quot;
        github_prs = agent_run.get(&quot;github_pull_requests&quot;, [])
        if not github_prs:
            return &quot;&quot;

        pr = github_prs[0]  # Take the first PR
        pr_url = pr.get(&quot;url&quot;, &quot;&quot;)
        if not pr_url:
            return &quot;&quot;

        # Extract PR number from URL like &quot;https://github.com/org/repo/pull/123&quot;
        try:
            pr_number = pr_url.split(&quot;/pull/&quot;)[-1].split(&quot;/&quot;)[0]
            return f&quot;PR #{pr_number}&quot;
        except (IndexError, AttributeError):
            return &quot;&quot;

    def _strip_ansi_codes(self, text: str) -&gt; str:
        &quot;&quot;&quot;Strip ANSI color codes from text.&quot;&quot;&quot;
        import re

        ansi_escape = re.compile(r&quot;\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])&quot;)
        return ansi_escape.sub(&quot;&quot;, text)

    def _format_date(self, created_at: str) -&gt; str:
        &quot;&quot;&quot;Format creation date.&quot;&quot;&quot;
        if not created_at or created_at == &quot;Unknown&quot;:
            return &quot;Unknown&quot;

        try:
            dt = datetime.fromisoformat(created_at.replace(&quot;Z&quot;, &quot;+00:00&quot;))
            return dt.strftime(&quot;%m/%d %H:%M&quot;)
        except (ValueError, TypeError):
            return created_at[:16] if len(created_at) &gt; 16 else created_at

    def _display_header(self):
        &quot;&quot;&quot;Display the header with tabs.&quot;&quot;&quot;
        # Simple header with indigo slashes and Codegen text
        print(&quot;\033[38;2;82;19;217m&quot; + &quot;/&quot; * 20 + &quot; Codegen\033[0m&quot;)
        print()  # Add blank line between header and tabs

        # Display tabs
        tab_line = &quot;&quot;
        for i, tab in enumerate(self.tabs):
            if i == self.current_tab:
                tab_line += f&quot;\033[38;2;255;202;133m/{tab}\033[0m  &quot;  # Orange for active tab with slash
            else:
                tab_line += f&quot;\033[90m{tab}\033[0m  &quot;  # Gray for inactive tabs

        print(tab_line)
        print()

    def _display_agent_list(self):
        &quot;&quot;&quot;Display the list of agent runs, fixed to 10 lines of main content.&quot;&quot;&quot;
        if not self.agent_runs:
            if self.initial_loading:
                print(&quot;Loading...&quot;)
            else:
                print(&quot;No agent runs found.&quot;)
            self._pad_to_lines(1)
            return

        # Determine how many extra lines the inline action menu will print (if open)
        menu_lines = 0
        if self.show_action_menu and 0 &lt;= self.selected_index &lt; len(self.agent_runs):
            selected_run = self.agent_runs[self.selected_index]
            github_prs = selected_run.get(&quot;github_pull_requests&quot;, [])
            options_count = 1  # &quot;open in web&quot;
            if github_prs:
                options_count += 1  # &quot;pull locally&quot;
            if github_prs and github_prs[0].get(&quot;url&quot;):
                options_count += 1  # &quot;open PR&quot;
            menu_lines = options_count + 1  # +1 for the hint line

        # We want total printed lines (rows + menu) to be 10
        window_size = max(1, 10 - menu_lines)

        total = len(self.agent_runs)
        if total &lt;= window_size:
            start = 0
            end = total
        else:
            start = max(0, min(self.selected_index - window_size // 2, total - window_size))
            end = start + window_size

        printed_rows = 0
        for i in range(start, end):
            agent_run = self.agent_runs[i]
            # Highlight selected item
            prefix = &quot;â†’ &quot; if i == self.selected_index and not self.show_action_menu else &quot;  &quot;

            status_circle, status_text = self._format_status(agent_run.get(&quot;status&quot;, &quot;Unknown&quot;), agent_run)
            created = self._format_date(agent_run.get(&quot;created_at&quot;, &quot;Unknown&quot;))
            summary = agent_run.get(&quot;summary&quot;, &quot;No summary&quot;) or &quot;No summary&quot;

            # Append PR info to summary if available
            pr_info = self._format_pr_info(agent_run)
            if pr_info:
                summary = f&quot;{summary} ({pr_info})&quot;

            if len(summary) &gt; 60:
                summary = summary[:57] + &quot;...&quot;

            # Calculate display width of status (without ANSI codes) for alignment
            status_display = f&quot;{status_circle} {status_text}&quot;
            status_display_width = len(self._strip_ansi_codes(status_display))
            status_padding = &quot; &quot; * max(0, 17 - status_display_width)

            if i == self.selected_index and not self.show_action_menu:
                line = f&quot;\033[37m{prefix}{created:&lt;10}\033[0m {status_circle} \033[37m{status_text}\033[0m{status_padding}\033[37m{summary}\033[0m&quot;
            else:
                line = f&quot;\033[90m{prefix}{created:&lt;10}\033[0m {status_circle} \033[90m{status_text}\033[0m{status_padding}\033[90m{summary}\033[0m&quot;

            print(line)
            printed_rows += 1

            # Show action menu right below the selected row if it&apos;s expanded
            if i == self.selected_index and self.show_action_menu:
                self._display_inline_action_menu(agent_run)

        # If fewer than needed to reach 10 lines, pad blank lines
        total_printed = printed_rows + menu_lines
        if total_printed &lt; 10:
            self._pad_to_lines(total_printed)

    def _display_new_tab(self):
        &quot;&quot;&quot;Display the new agent creation interface.&quot;&quot;&quot;
        print(&quot;Create new background agent (Claude Code):&quot;)
        print()

        # Get terminal width, default to 80 if can&apos;t determine
        try:
            import os

            terminal_width = os.get_terminal_size().columns
        except (OSError, AttributeError):
            terminal_width = 80

        # Calculate input box width (leave some margin)
        box_width = max(60, terminal_width - 4)

        # Input box with cursor
        input_display = self.prompt_input
        if self.input_mode:
            # Add cursor indicator when in input mode
            if self.cursor_position &lt;= len(input_display):
                input_display = input_display[: self.cursor_position] + &quot;â–ˆ&quot; + input_display[self.cursor_position :]

        # Handle long input that exceeds box width
        if len(input_display) &gt; box_width - 4:
            # Show portion around cursor
            start_pos = max(0, self.cursor_position - (box_width // 2))
            input_display = input_display[start_pos : start_pos + box_width - 4]

        # Display full-width input box with simple border like Claude Code
        border_style = &quot;\033[37m&quot; if self.input_mode else &quot;\033[90m&quot;  # White when active, gray when inactive
        reset = &quot;\033[0m&quot;

        print(border_style + &quot;â”Œ&quot; + &quot;â”€&quot; * (box_width - 2) + &quot;â”&quot; + reset)
        padding = box_width - 4 - len(input_display.replace(&quot;â–ˆ&quot;, &quot;&quot;))
        print(border_style + &quot;â”‚&quot; + reset + f&quot; {input_display}{&apos; &apos; * max(0, padding)} &quot; + border_style + &quot;â”‚&quot; + reset)
        print(border_style + &quot;â””&quot; + &quot;â”€&quot; * (box_width - 2) + &quot;â”˜&quot; + reset)
        print()

        # The new tab main content area should be a fixed 10 lines
        self._pad_to_lines(6)

    def _create_background_agent(self, prompt: str):
        &quot;&quot;&quot;Create a background agent run.&quot;&quot;&quot;
        logger.info(&quot;Creating background agent via TUI&quot;, extra={&quot;operation&quot;: &quot;tui.create_agent&quot;, &quot;org_id&quot;: getattr(self, &quot;org_id&quot;, None), &quot;prompt_length&quot;: len(prompt), &quot;client&quot;: &quot;tui&quot;})

        if not self.token or not self.org_id:
            logger.error(&quot;Cannot create agent - missing auth&quot;, extra={&quot;operation&quot;: &quot;tui.create_agent&quot;, &quot;has_token&quot;: bool(self.token), &quot;has_org_id&quot;: bool(getattr(self, &quot;org_id&quot;, None))})
            print(&quot;\nâŒ Not authenticated or no organization configured.&quot;)
            input(&quot;Press Enter to continue...&quot;)
            return

        if not prompt.strip():
            logger.warning(&quot;Agent creation cancelled - empty prompt&quot;, extra={&quot;operation&quot;: &quot;tui.create_agent&quot;, &quot;org_id&quot;: self.org_id, &quot;prompt_length&quot;: len(prompt)})
            print(&quot;\nâŒ Please enter a prompt.&quot;)
            input(&quot;Press Enter to continue...&quot;)
            return

        print(f&quot;\n\033[90mCreating agent run with prompt: &apos;{prompt[:50]}{&apos;...&apos; if len(prompt) &gt; 50 else &apos;&apos;}&apos;\033[0m&quot;)

        start_time = time.time()
        try:
            payload = {&quot;prompt&quot;: prompt.strip()}
            headers = {
                &quot;Authorization&quot;: f&quot;Bearer {self.token}&quot;,
                &quot;Content-Type&quot;: &quot;application/json&quot;,
                &quot;x-codegen-client&quot;: &quot;codegen__claude_code&quot;,
            }
            url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{self.org_id}/agent/run&quot;

            # API request details not needed in logs - focus on user actions and results

            response = requests.post(url, headers=headers, json=payload, timeout=30)
            response.raise_for_status()
            agent_run_data = response.json()

            run_id = agent_run_data.get(&quot;id&quot;, &quot;Unknown&quot;)
            status = agent_run_data.get(&quot;status&quot;, &quot;Unknown&quot;)
            web_url = self._generate_agent_url(run_id)

            duration_ms = (time.time() - start_time) * 1000
            logger.info(
                &quot;Background agent created successfully&quot;,
                extra={&quot;operation&quot;: &quot;tui.create_agent&quot;, &quot;org_id&quot;: self.org_id, &quot;agent_run_id&quot;: run_id, &quot;status&quot;: status, &quot;duration_ms&quot;: duration_ms, &quot;prompt_length&quot;: len(prompt.strip())},
            )

            print(&quot;\n\033[90mAgent run created successfully!\033[0m&quot;)
            print(f&quot;\033[90m   Run ID: {run_id}\033[0m&quot;)
            print(f&quot;\033[90m   Status: {status}\033[0m&quot;)
            print(f&quot;\033[90m   Web URL: \033[38;2;255;202;133m{web_url}\033[0m&quot;)

            # Clear the input
            self.prompt_input = &quot;&quot;
            self.cursor_position = 0
            self.input_mode = False

            # Show post-creation menu
            self._show_post_creation_menu(web_url)

        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            logger.error(
                &quot;Failed to create background agent&quot;,
                extra={&quot;operation&quot;: &quot;tui.create_agent&quot;, &quot;org_id&quot;: self.org_id, &quot;error_type&quot;: type(e).__name__, &quot;error_message&quot;: str(e), &quot;duration_ms&quot;: duration_ms, &quot;prompt_length&quot;: len(prompt)},
                exc_info=True,
            )
            print(f&quot;\nâŒ Failed to create agent run: {e}&quot;)
            input(&quot;\nPress Enter to continue...&quot;)

    def _show_post_creation_menu(self, web_url: str):
        &quot;&quot;&quot;Show menu after successful agent creation.&quot;&quot;&quot;
        from codegen.cli.utils.inplace_print import inplace_print

        print(&quot;\n\033[90mWhat would you like to do next?\033[0m&quot;)
        options = [&quot;Open Trace â†—&quot;, &quot;Go to Recent&quot;]
        selected = 0
        prev_lines = 0

        def build_lines():
            menu_lines = []
            # Options
            for i, option in enumerate(options):
                if i == selected:
                    menu_lines.append(f&quot;    \033[37mâ†’ {option}\033[0m&quot;)
                else:
                    menu_lines.append(f&quot;    \033[90m  {option}\033[0m&quot;)
            # Hint line last
            menu_lines.append(&quot;\033[90m[Enter] select â€¢ [â†‘â†“] navigate â€¢ [B] back to new tab\033[0m&quot;)
            return menu_lines

        # Initial render
        prev_lines = inplace_print(build_lines(), prev_lines)

        while True:
            key = self._get_char()
            if key == &quot;\x1b[A&quot; or key.lower() == &quot;w&quot;:  # Up arrow or W
                selected = (selected - 1) % len(options)
                prev_lines = inplace_print(build_lines(), prev_lines)
            elif key == &quot;\x1b[B&quot; or key.lower() == &quot;s&quot;:  # Down arrow or S
                selected = (selected + 1) % len(options)
                prev_lines = inplace_print(build_lines(), prev_lines)
            elif key == &quot;\r&quot; or key == &quot;\n&quot;:  # Enter - select option
                if selected == 0:  # Open Trace
                    try:
                        import webbrowser

                        webbrowser.open(web_url)
                    except Exception as e:
                        print(f&quot;\nâŒ Failed to open browser: {e}&quot;)
                        input(&quot;Press Enter to continue...&quot;)
                elif selected == 1:  # Go to Recent
                    self.current_tab = 0  # Switch to recent tab
                    self.input_mode = False
                    self._load_agent_runs()  # Refresh the data
                break
            elif key == &quot;B&quot;:  # Back to new tab
                self.current_tab = 2  # &apos;new&apos; tab index
                self.input_mode = True
                break

    def _display_dashboard_tab(self):
        &quot;&quot;&quot;Display the kanban interface access tab.&quot;&quot;&quot;
        # Generate the proper domain-based URL for display
        me_url = generate_webapp_url(&quot;me&quot;)
        display_url = me_url.replace(&quot;https://&quot;, &quot;&quot;).replace(&quot;http://&quot;, &quot;&quot;)

        print(f&quot;  \033[37mâ†’ Open Kanban ({display_url})\033[0m&quot;)
        print()
        print(&quot;Press Enter to open web kanban.&quot;)
        # The kanban tab main content area should be a fixed 10 lines
        self._pad_to_lines(7)

    def _display_claude_tab(self):
        &quot;&quot;&quot;Display the Claude Code interface tab.&quot;&quot;&quot;
        # Check if Claude Code is installed
        from codegen.cli.commands.claude.utils import resolve_claude_path

        claude_path = resolve_claude_path()
        if not claude_path:
            # Display error message when Claude is not installed
            print(&quot;  \033[31mâœ— Claude Code Not Installed\033[0m&quot;)
            print()
            print(&quot;\033[33mâš  Claude Code CLI is not installed or cannot be found.\033[0m&quot;)
            print()
            print(&quot;To install Claude Code:&quot;)
            print(&quot;  â€¢ Install globally: \033[36mnpm install -g @anthropic-ai/claude-code\033[0m&quot;)
            print(&quot;  â€¢ Or run: \033[36mclaude /migrate-installer\033[0m for local installation&quot;)
            print()
            print(&quot;Once installed, restart this CLI to use Claude Code.&quot;)
        else:
            print(&quot;  \033[37mâ†’ Run Claude Code\033[0m&quot;)
            print()
            print(&quot;Press Enter to launch Claude Code with session tracking.&quot;)

        # The claude tab main content area should be a fixed 10 lines
        self._pad_to_lines(7)

    def _pull_agent_branch(self, agent_id: str):
        &quot;&quot;&quot;Pull the PR branch for an agent run locally.&quot;&quot;&quot;
        logger.info(&quot;Starting local pull via TUI&quot;, extra={&quot;operation&quot;: &quot;tui.pull_branch&quot;, &quot;agent_id&quot;: agent_id, &quot;org_id&quot;: getattr(self, &quot;org_id&quot;, None)})

        print(f&quot;\nðŸ”„ Pulling PR branch for agent {agent_id}...&quot;)
        print(&quot;â”€&quot; * 50)

        start_time = time.time()
        try:
            # Call the existing pull command with the agent_id
            pull(agent_id=int(agent_id), org_id=self.org_id)

            duration_ms = (time.time() - start_time) * 1000
            logger.info(&quot;Local pull completed successfully&quot;, extra={&quot;operation&quot;: &quot;tui.pull_branch&quot;, &quot;agent_id&quot;: agent_id, &quot;org_id&quot;: self.org_id, &quot;duration_ms&quot;: duration_ms, &quot;success&quot;: True})

        except typer.Exit as e:
            duration_ms = (time.time() - start_time) * 1000
            # typer.Exit is expected for both success and failure cases
            if e.exit_code == 0:
                logger.info(
                    &quot;Local pull completed via typer exit&quot;,
                    extra={&quot;operation&quot;: &quot;tui.pull_branch&quot;, &quot;agent_id&quot;: agent_id, &quot;org_id&quot;: self.org_id, &quot;duration_ms&quot;: duration_ms, &quot;exit_code&quot;: e.exit_code, &quot;success&quot;: True},
                )
                print(&quot;\nâœ… Pull completed successfully!&quot;)
            else:
                logger.error(
                    &quot;Local pull failed via typer exit&quot;,
                    extra={&quot;operation&quot;: &quot;tui.pull_branch&quot;, &quot;agent_id&quot;: agent_id, &quot;org_id&quot;: self.org_id, &quot;duration_ms&quot;: duration_ms, &quot;exit_code&quot;: e.exit_code, &quot;success&quot;: False},
                )
                print(f&quot;\nâŒ Pull failed (exit code: {e.exit_code})&quot;)
        except ValueError:
            duration_ms = (time.time() - start_time) * 1000
            logger.error(
                &quot;Invalid agent ID for pull&quot;,
                extra={&quot;operation&quot;: &quot;tui.pull_branch&quot;, &quot;agent_id&quot;: agent_id, &quot;org_id&quot;: getattr(self, &quot;org_id&quot;, None), &quot;duration_ms&quot;: duration_ms, &quot;error_type&quot;: &quot;invalid_agent_id&quot;},
            )
            print(f&quot;\nâŒ Invalid agent ID: {agent_id}&quot;)
        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            logger.error(
                &quot;Unexpected error during pull&quot;,
                extra={
                    &quot;operation&quot;: &quot;tui.pull_branch&quot;,
                    &quot;agent_id&quot;: agent_id,
                    &quot;org_id&quot;: getattr(self, &quot;org_id&quot;, None),
                    &quot;duration_ms&quot;: duration_ms,
                    &quot;error_type&quot;: type(e).__name__,
                    &quot;error_message&quot;: str(e),
                },
                exc_info=True,
            )
            print(f&quot;\nâŒ Unexpected error during pull: {e}&quot;)

        print(&quot;â”€&quot; * 50)
        input(&quot;Press Enter to continue...&quot;)

    def _display_content(self):
        &quot;&quot;&quot;Display content based on current tab.&quot;&quot;&quot;
        if self.current_tab == 0:  # recent
            self._display_agent_list()
        elif self.current_tab == 1:  # claude
            self._display_claude_tab()
        elif self.current_tab == 2:  # new
            self._display_new_tab()
        elif self.current_tab == 3:  # kanban
            self._display_dashboard_tab()

    def _pad_to_lines(self, lines_printed: int, target: int = 10):
        &quot;&quot;&quot;Pad the main content area with blank lines to reach a fixed height.&quot;&quot;&quot;
        for _ in range(max(0, target - lines_printed)):
            print()

    def _display_inline_action_menu(self, agent_run: dict):
        &quot;&quot;&quot;Display action menu inline below the selected row.&quot;&quot;&quot;
        agent_id = agent_run.get(&quot;id&quot;, &quot;unknown&quot;)
        web_url = self._generate_agent_url(agent_id)

        # Check if there are GitHub PRs associated with this agent run
        github_prs = agent_run.get(&quot;github_pull_requests&quot;, [])

        # Build options in the requested order
        options = []

        # 1. Open PR (if available)
        if github_prs:
            pr_url = github_prs[0].get(&quot;url&quot;, &quot;&quot;)
            if pr_url:
                # Extract PR number for display
                try:
                    pr_number = pr_url.split(&quot;/pull/&quot;)[-1].split(&quot;/&quot;)[0]
                    options.append(f&quot;Open PR #{pr_number} â†—&quot;)
                except (IndexError, AttributeError):
                    options.append(&quot;Open PR â†—&quot;)

        # 2. Pull locally (if PRs available)
        if github_prs:
            options.append(&quot;Pull locally&quot;)

        # 3. Open Trace (always available)
        options.append(&quot;Open Trace â†—&quot;)

        for i, option in enumerate(options):
            if i == self.action_menu_selection:
                # Highlight selected option in white
                print(f&quot;    \033[37mâ†’ {option}\033[0m&quot;)
            else:
                # All other options in gray
                print(f&quot;    \033[90m  {option}\033[0m&quot;)

        print(&quot;\033[90m    [Enter] select â€¢ [â†‘â†“] navigate â€¢ [C] close\033[0m&quot;)

    def _get_char(self):
        &quot;&quot;&quot;Get a single character from stdin, handling arrow keys.&quot;&quot;&quot;
        try:
            fd = sys.stdin.fileno()
            old_settings = termios.tcgetattr(fd)
            try:
                tty.setcbreak(fd)
                ch = sys.stdin.read(1)

                # Handle escape sequences (arrow keys)
                if ch == &quot;\x1b&quot;:  # ESC
                    # Read the rest of the escape sequence synchronously
                    ch2 = sys.stdin.read(1)
                    if ch2 == &quot;[&quot;:
                        ch3 = sys.stdin.read(1)
                        return f&quot;\x1b[{ch3}&quot;
                    else:
                        # Return combined sequence (e.g., Alt+&lt;key&gt;)
                        return ch + ch2
                return ch
            finally:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        except (ImportError, OSError, termios.error):
            # Fallback for systems where tty manipulation doesn&apos;t work
            print(&quot;\nUse: â†‘(w)/â†“(s) navigate, Enter details, R refresh, Q quit&quot;)
            try:
                return input(&quot;&gt; &quot;).strip()[:1].lower() or &quot;\n&quot;
            except KeyboardInterrupt:
                return &quot;q&quot;

    def _handle_keypress(self, key: str):
        &quot;&quot;&quot;Handle key presses for navigation.&quot;&quot;&quot;
        # Global quit (but not when typing in new tab)
        if key == &quot;\x03&quot;:  # Ctrl+C
            logger.info(
                &quot;TUI session ended by user&quot;,
                extra={
                    &quot;operation&quot;: &quot;tui.session_end&quot;,
                    &quot;org_id&quot;: getattr(self, &quot;org_id&quot;, None),
                    &quot;reason&quot;: &quot;ctrl_c&quot;,
                    &quot;current_tab&quot;: self.tabs[self.current_tab] if self.current_tab &lt; len(self.tabs) else &quot;unknown&quot;,
                },
            )
            self.running = False
            return
        elif key.lower() == &quot;q&quot; and not (self.input_mode and self.current_tab == 2):  # q only if not typing in new tab
            logger.info(
                &quot;TUI session ended by user&quot;,
                extra={
                    &quot;operation&quot;: &quot;tui.session_end&quot;,
                    &quot;org_id&quot;: getattr(self, &quot;org_id&quot;, None),
                    &quot;reason&quot;: &quot;quit_key&quot;,
                    &quot;current_tab&quot;: self.tabs[self.current_tab] if self.current_tab &lt; len(self.tabs) else &quot;unknown&quot;,
                },
            )
            self.running = False
            return

        # Tab switching (works even in input mode)
        if key == &quot;\t&quot;:  # Tab key
            old_tab = self.current_tab
            self.current_tab = (self.current_tab + 1) % len(self.tabs)

            # Log significant tab switches but at info level since it&apos;s user action
            logger.info(
                f&quot;TUI tab switched to {self.tabs[self.current_tab]}&quot;,
                extra={
                    &quot;operation&quot;: &quot;tui.tab_switch&quot;,
                    &quot;from_tab&quot;: self.tabs[old_tab] if old_tab &lt; len(self.tabs) else &quot;unknown&quot;,
                    &quot;to_tab&quot;: self.tabs[self.current_tab] if self.current_tab &lt; len(self.tabs) else &quot;unknown&quot;,
                },
            )

            # Reset state when switching tabs
            self.show_action_menu = False
            self.action_menu_selection = 0
            self.selected_index = 0
            # Auto-focus prompt when switching to new tab
            if self.current_tab == 2:  # new tab
                self.input_mode = True
                self.cursor_position = len(self.prompt_input)
            else:
                self.input_mode = False
            return

        # Handle based on current context
        if self.input_mode:
            self._handle_input_mode_keypress(key)
        elif self.show_action_menu:
            self._handle_action_menu_keypress(key)
        elif self.current_tab == 0:  # recent tab
            self._handle_recent_keypress(key)
        elif self.current_tab == 1:  # claude tab
            self._handle_claude_tab_keypress(key)
        elif self.current_tab == 2:  # new tab
            self._handle_new_tab_keypress(key)
        elif self.current_tab == 3:  # kanban tab
            self._handle_dashboard_tab_keypress(key)

    def _handle_input_mode_keypress(self, key: str):
        &quot;&quot;&quot;Handle keypresses when in text input mode.&quot;&quot;&quot;
        if key == &quot;B&quot;:  # Back action in new tab
            self.input_mode = False
        elif key == &quot;\r&quot; or key == &quot;\n&quot;:  # Enter - create agent run
            if self.prompt_input.strip():  # Only create if there&apos;s actual content
                self._create_background_agent(self.prompt_input)
            else:
                self.input_mode = False  # Exit input mode if empty
        elif key == &quot;\x7f&quot; or key == &quot;\b&quot;:  # Backspace
            if self.cursor_position &gt; 0:
                self.prompt_input = self.prompt_input[: self.cursor_position - 1] + self.prompt_input[self.cursor_position :]
                self.cursor_position -= 1
        elif key == &quot;\x1b[C&quot;:  # Right arrow
            self.cursor_position = min(len(self.prompt_input), self.cursor_position + 1)
        elif key == &quot;\x1b[D&quot;:  # Left arrow
            self.cursor_position = max(0, self.cursor_position - 1)
        elif len(key) == 1 and key.isprintable():  # Regular character
            self.prompt_input = self.prompt_input[: self.cursor_position] + key + self.prompt_input[self.cursor_position :]
            self.cursor_position += 1

    def _handle_action_menu_keypress(self, key: str):
        &quot;&quot;&quot;Handle action menu keypresses.&quot;&quot;&quot;
        if key == &quot;\r&quot; or key == &quot;\n&quot;:  # Enter
            self._execute_inline_action()
            self.show_action_menu = False  # Close menu after action
        elif key.lower() == &quot;c&quot; or key == &quot;\x1b[D&quot;:  # &apos;C&apos; key or Left arrow to close
            self.show_action_menu = False  # Close menu
            self.action_menu_selection = 0  # Reset selection
        elif key == &quot;\x1b[A&quot; or key.lower() == &quot;w&quot;:  # Up arrow or W
            # Get available options count
            if 0 &lt;= self.selected_index &lt; len(self.agent_runs):
                agent_run = self.agent_runs[self.selected_index]
                github_prs = agent_run.get(&quot;github_pull_requests&quot;, [])
                options_count = 1  # Always have &quot;Open Trace&quot;
                if github_prs:
                    options_count += 1  # &quot;Pull locally&quot;
                if github_prs and github_prs[0].get(&quot;url&quot;):
                    options_count += 1  # &quot;Open PR&quot;

                self.action_menu_selection = max(0, self.action_menu_selection - 1)
        elif key == &quot;\x1b[B&quot; or key.lower() == &quot;s&quot;:  # Down arrow or S
            # Get available options count
            if 0 &lt;= self.selected_index &lt; len(self.agent_runs):
                agent_run = self.agent_runs[self.selected_index]
                github_prs = agent_run.get(&quot;github_pull_requests&quot;, [])
                options_count = 1  # Always have &quot;Open Trace&quot;
                if github_prs:
                    options_count += 1  # &quot;Pull locally&quot;
                if github_prs and github_prs[0].get(&quot;url&quot;):
                    options_count += 1  # &quot;Open PR&quot;

                self.action_menu_selection = min(options_count - 1, self.action_menu_selection + 1)

    def _handle_recent_keypress(self, key: str):
        &quot;&quot;&quot;Handle keypresses in the recent tab.&quot;&quot;&quot;
        if key == &quot;\x1b[A&quot; or key.lower() == &quot;w&quot;:  # Up arrow or W
            self.selected_index = max(0, self.selected_index - 1)
            self.show_action_menu = False  # Close any open menu
            self.action_menu_selection = 0
        elif key == &quot;\x1b[B&quot; or key.lower() == &quot;s&quot;:  # Down arrow or S
            self.selected_index = min(len(self.agent_runs) - 1, self.selected_index + 1)
            self.show_action_menu = False  # Close any open menu
            self.action_menu_selection = 0
        elif key == &quot;\x1b[C&quot;:  # Right arrow - open action menu
            self.show_action_menu = True  # Open action menu
            self.action_menu_selection = 0  # Reset to first option
        elif key == &quot;\x1b[D&quot;:  # Left arrow - close action menu
            self.show_action_menu = False  # Close action menu
            self.action_menu_selection = 0
        elif key == &quot;\r&quot; or key == &quot;\n&quot; or key.lower() == &quot;e&quot;:  # Enter or E
            self.show_action_menu = True  # Open action menu
            self.action_menu_selection = 0  # Reset to first option
        elif key.lower() == &quot;r&quot;:
            self._refresh()
            self.show_action_menu = False  # Close menu on refresh
            self.action_menu_selection = 0

    def _handle_new_tab_keypress(self, key: str):
        &quot;&quot;&quot;Handle keypresses in the new tab.&quot;&quot;&quot;
        if key == &quot;\r&quot; or key == &quot;\n&quot;:  # Enter - start input mode
            if not self.input_mode:
                self.input_mode = True
                self.cursor_position = len(self.prompt_input)
            else:
                # If already in input mode, Enter should create the agent
                self._create_background_agent(self.prompt_input)

    def _handle_dashboard_tab_keypress(self, key: str):
        &quot;&quot;&quot;Handle keypresses in the kanban tab.&quot;&quot;&quot;
        if key == &quot;\r&quot; or key == &quot;\n&quot;:  # Enter - open web kanban
            logger.info(&quot;Opening web kanban from TUI&quot;, extra={&quot;operation&quot;: &quot;tui.open_kanban&quot;, &quot;org_id&quot;: getattr(self, &quot;org_id&quot;, None)})
            try:
                import webbrowser

                me_url = generate_webapp_url(&quot;me&quot;)
                webbrowser.open(me_url)
                # Debug details not needed for successful browser opens
            except Exception as e:
                logger.error(&quot;Failed to open kanban in browser&quot;, extra={&quot;operation&quot;: &quot;tui.open_kanban&quot;, &quot;error&quot;: str(e)})
                print(f&quot;\nâŒ Failed to open browser: {e}&quot;)
                input(&quot;Press Enter to continue...&quot;)

    def _handle_claude_tab_keypress(self, key: str):
        &quot;&quot;&quot;Handle keypresses in the claude tab.&quot;&quot;&quot;
        if key == &quot;\r&quot; or key == &quot;\n&quot;:  # Enter - run Claude Code
            # Check if Claude is installed before attempting to run
            from codegen.cli.commands.claude.utils import resolve_claude_path

            claude_path = resolve_claude_path()
            if not claude_path:
                # Claude is not installed, don&apos;t try to launch
                logger.warning(&quot;Attempted to launch Claude Code but it&apos;s not installed&quot;, extra={&quot;operation&quot;: &quot;tui.launch_claude&quot;, &quot;error&quot;: &quot;not_installed&quot;})
                return

            self._run_claude_code()

    def _run_claude_code(self):
        &quot;&quot;&quot;Launch Claude Code with session tracking.&quot;&quot;&quot;
        logger.info(&quot;Launching Claude Code from TUI&quot;, extra={&quot;operation&quot;: &quot;tui.launch_claude&quot;, &quot;org_id&quot;: getattr(self, &quot;org_id&quot;, None), &quot;source&quot;: &quot;tui&quot;})

        if not self.token or not self.org_id:
            logger.error(&quot;Cannot launch Claude - missing auth&quot;, extra={&quot;operation&quot;: &quot;tui.launch_claude&quot;, &quot;has_token&quot;: bool(self.token), &quot;has_org_id&quot;: bool(getattr(self, &quot;org_id&quot;, None))})
            print(&quot;\nâŒ Not authenticated or no organization configured.&quot;)
            input(&quot;Press Enter to continue...&quot;)
            return

        # Show immediate feedback in orange
        print(&quot;\n\033[38;2;255;202;133m&gt; claude code mode\033[0m&quot;)

        # Stop the TUI and clear screen completely after brief moment
        self.running = False
        print(&quot;\033[2J\033[H&quot;, end=&quot;&quot;)  # Clear entire screen and move cursor to top

        start_time = time.time()
        try:
            # Transition details not needed - the launch and completion logs are sufficient

            # Call the interactive claude function with the current org_id
            # The function handles all the session tracking and launching
            _run_claude_interactive(self.org_id, no_mcp=False)

            duration_ms = (time.time() - start_time) * 1000
            logger.info(&quot;Claude Code session completed via TUI&quot;, extra={&quot;operation&quot;: &quot;tui.launch_claude&quot;, &quot;org_id&quot;: self.org_id, &quot;duration_ms&quot;: duration_ms, &quot;exit_reason&quot;: &quot;normal&quot;})

        except typer.Exit:
            # Claude Code finished, just continue silently
            duration_ms = (time.time() - start_time) * 1000
            logger.info(&quot;Claude Code session exited via TUI&quot;, extra={&quot;operation&quot;: &quot;tui.launch_claude&quot;, &quot;org_id&quot;: self.org_id, &quot;duration_ms&quot;: duration_ms, &quot;exit_reason&quot;: &quot;typer_exit&quot;})
            pass
        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            logger.error(
                &quot;Error launching Claude Code from TUI&quot;,
                extra={&quot;operation&quot;: &quot;tui.launch_claude&quot;, &quot;org_id&quot;: self.org_id, &quot;error_type&quot;: type(e).__name__, &quot;error_message&quot;: str(e), &quot;duration_ms&quot;: duration_ms},
                exc_info=True,
            )
            print(f&quot;\nâŒ Unexpected error launching Claude Code: {e}&quot;)
            input(&quot;Press Enter to continue...&quot;)

        # Exit the TUI completely - don&apos;t return to it
        logger.info(&quot;TUI session ended - transitioning to Claude&quot;, extra={&quot;operation&quot;: &quot;tui.session_end&quot;, &quot;org_id&quot;: getattr(self, &quot;org_id&quot;, None), &quot;reason&quot;: &quot;claude_launch&quot;})
        sys.exit(0)

    def _execute_inline_action(self):
        &quot;&quot;&quot;Execute the selected action from the inline menu.&quot;&quot;&quot;
        if not (0 &lt;= self.selected_index &lt; len(self.agent_runs)):
            return

        agent_run = self.agent_runs[self.selected_index]
        agent_id = agent_run.get(&quot;id&quot;, &quot;unknown&quot;)
        web_url = self._generate_agent_url(agent_id)

        # Build options in the same order as display
        github_prs = agent_run.get(&quot;github_pull_requests&quot;, [])
        options = []

        # 1. Open PR (if available)
        if github_prs and github_prs[0].get(&quot;url&quot;):
            options.append(&quot;open PR&quot;)

        # 2. Pull locally (if PRs available)
        if github_prs:
            options.append(&quot;pull locally&quot;)

        # 3. Open Trace (always available)
        options.append(&quot;open trace&quot;)

        # Execute the currently selected option
        if len(options) &gt; self.action_menu_selection:
            selected_option = options[self.action_menu_selection]

            logger.info(
                &quot;TUI action executed&quot;, extra={&quot;operation&quot;: &quot;tui.execute_action&quot;, &quot;action&quot;: selected_option, &quot;agent_id&quot;: agent_id, &quot;org_id&quot;: getattr(self, &quot;org_id&quot;, None), &quot;has_prs&quot;: bool(github_prs)}
            )

            if selected_option == &quot;open PR&quot;:
                pr_url = github_prs[0][&quot;url&quot;]
                try:
                    import webbrowser

                    webbrowser.open(pr_url)
                    # Debug details not needed for successful browser opens
                    # No pause - seamless flow back to collapsed state
                except Exception as e:
                    logger.error(&quot;Failed to open PR in browser&quot;, extra={&quot;operation&quot;: &quot;tui.open_pr&quot;, &quot;agent_id&quot;: agent_id, &quot;error&quot;: str(e)})
                    print(f&quot;\nâŒ Failed to open PR: {e}&quot;)
                    input(&quot;Press Enter to continue...&quot;)  # Only pause on errors
            elif selected_option == &quot;pull locally&quot;:
                self._pull_agent_branch(agent_id)
            elif selected_option == &quot;open trace&quot;:
                try:
                    import webbrowser

                    webbrowser.open(web_url)
                    # Debug details not needed for successful browser opens
                    # No pause - let it flow back naturally to collapsed state
                except Exception as e:
                    logger.error(&quot;Failed to open trace in browser&quot;, extra={&quot;operation&quot;: &quot;tui.open_trace&quot;, &quot;agent_id&quot;: agent_id, &quot;error&quot;: str(e)})
                    print(f&quot;\nâŒ Failed to open browser: {e}&quot;)
                    input(&quot;Press Enter to continue...&quot;)  # Only pause on errors

    def _open_agent_details(self):
        &quot;&quot;&quot;Toggle the inline action menu.&quot;&quot;&quot;
        self.show_action_menu = not self.show_action_menu
        if not self.show_action_menu:
            self.action_menu_selection = 0  # Reset selection when closing

    def _refresh(self):
        &quot;&quot;&quot;Refresh the agent runs list.&quot;&quot;&quot;
        # Indicate refresh and redraw immediately so the user sees it
        self.is_refreshing = True
        self._clear_and_redraw()

        if self._load_agent_runs():
            self.selected_index = 0  # Reset selection

        # Clear refresh indicator and redraw with updated data
        self.is_refreshing = False
        self._clear_and_redraw()

    def _clear_and_redraw(self):
        &quot;&quot;&quot;Clear screen and redraw everything.&quot;&quot;&quot;
        # Move cursor to top and clear screen from cursor down
        print(&quot;\033[H\033[J&quot;, end=&quot;&quot;)
        self._display_header()
        self._display_content()

        # Show appropriate instructions based on context
        if self.input_mode and self.current_tab == 2:  # new tab input mode
            print(f&quot;\n{self._format_status_line(&apos;Type your prompt â€¢ [Enter] create â€¢ [B] cancel â€¢ [Tab] switch tabs â€¢ [Ctrl+C] quit&apos;)}&quot;)
        elif self.input_mode:  # other input modes
            print(f&quot;\n{self._format_status_line(&apos;Type your prompt â€¢ [Enter] create â€¢ [B] cancel â€¢ [Ctrl+C] quit&apos;)}&quot;)
        elif self.show_action_menu:
            print(f&quot;\n{self._format_status_line(&apos;[Enter] select â€¢ [â†‘â†“] navigate â€¢ [C] close â€¢ [Q] quit&apos;)}&quot;)
        elif self.current_tab == 0:  # recent
            print(f&quot;\n{self._format_status_line(&apos;[Tab] switch tabs â€¢ (â†‘â†“) navigate â€¢ (â†â†’) open/close â€¢ [Enter] actions â€¢ [R] refresh â€¢ [Q] quit&apos;)}&quot;)
        elif self.current_tab == 1:  # claude
            print(f&quot;\n{self._format_status_line(&apos;[Tab] switch tabs â€¢ [Enter] launch claude code with telemetry â€¢ [Q] quit&apos;)}&quot;)
        elif self.current_tab == 2:  # new
            print(f&quot;\n{self._format_status_line(&apos;[Tab] switch tabs â€¢ [Enter] start typing â€¢ [Q] quit&apos;)}&quot;)
        elif self.current_tab == 3:  # kanban
            print(f&quot;\n{self._format_status_line(&apos;[Tab] switch tabs â€¢ [Enter] open web kanban â€¢ [Q] quit&apos;)}&quot;)

    def run(self):
        &quot;&quot;&quot;Run the minimal TUI.&quot;&quot;&quot;
        if not self.is_authenticated:
            # Automatically start login flow for first-time users
            from codegen.cli.auth.login import login_routine

            try:
                login_routine()
                # login_routine will launch TUI after successful authentication
                return
            except Exception:
                # If login fails, just exit gracefully
                return

        # Show UI immediately
        self._clear_and_redraw()

        # Start initial data load in background (non-blocking)
        def initial_load():
            self._load_agent_runs()
            if self.running:  # Only redraw if still running
                self._clear_and_redraw()

        load_thread = threading.Thread(target=initial_load, daemon=True)
        load_thread.start()

        # Main event loop
        while self.running:
            try:
                key = self._get_char()
                self._handle_keypress(key)
                if self.running:  # Only redraw if we&apos;re still running
                    self._clear_and_redraw()
            except KeyboardInterrupt:
                # This should be handled by the signal handler, but just in case
                break

        print()  # Add newline before exiting


def run_tui():
    &quot;&quot;&quot;Run the minimal Codegen TUI.&quot;&quot;&quot;
    logger.info(&quot;Starting TUI session&quot;, extra={&quot;operation&quot;: &quot;tui.start&quot;, &quot;component&quot;: &quot;run_tui&quot;})

    try:
        tui = MinimalTUI()
        tui.run()
    except Exception as e:
        logger.error(&quot;TUI session crashed&quot;, extra={&quot;operation&quot;: &quot;tui.crash&quot;, &quot;error_type&quot;: type(e).__name__, &quot;error_message&quot;: str(e)}, exc_info=True)
        raise
    finally:
        logger.info(&quot;TUI session ended&quot;, extra={&quot;operation&quot;: &quot;tui.end&quot;, &quot;component&quot;: &quot;run_tui&quot;})</file><file path="src/codegen/cli/tui/codegen_theme.tcss">/* Codegen Custom Theme - Indigo, Black, White, Teal */

/* 
Color Palette:
- Indigo: #4f46e5 (primary), #6366f1 (light), #3730a3 (dark)
- Black/Charcoal: #000000, #1a1a1a  
- White: #ffffff, #f8fafc
- Teal: #14b8a6 (accent), #2dd4bf (light), #0f766e (dark)
- Grays: #111827, #1f2937, #374151, #4b5563, #9ca3af, #d1d5db, #e5e7eb, #f3f4f6
*/

/* Main app background */
Screen {
    background: #1a1a1a;
}

/* Header and Footer - Primary Indigo */
Header {
    dock: top;
    height: 3;
    background: #4f46e5;
    color: #ffffff;
}

Footer {
    dock: bottom;
    height: 3;
    background: #4f46e5;
    color: #ffffff;
}

/* Title styling - Light Indigo with bold text */
.title {
    text-style: bold;
    margin: 1;
    color: #6366f1;
    text-align: center;
}

/* Help text - Muted gray */
.help {
    margin-bottom: 1;
    color: #9ca3af;
    text-align: center;
}

/* Warning messages - Black background with white text and teal border */
.warning-message {
    text-align: center;
    margin: 2;
    padding: 2;
    background: #000000;
    color: #ffffff;
    text-style: bold;
    border: solid #14b8a6;
}

/* DataTable styling */
DataTable {
    height: 1fr;
    margin-top: 1;
    background: #111827;
}

DataTable &gt; .datatable--header {
    text-style: bold;
    background: #4f46e5;
    color: #ffffff;
}

DataTable &gt; .datatable--odd-row {
    background: #1f2937;
    color: #ffffff;
}

DataTable &gt; .datatable--even-row {
    background: #111827;
    color: #ffffff;
}

DataTable &gt; .datatable--cursor {
    background: #14b8a6;
    color: #000000;
    text-style: bold;
}

DataTable &gt; .datatable--hover {
    background: #0f766e;
    color: #ffffff;
}

/* Organization selector specific styling */
#auth-warning {
    height: 100%;
    align: center middle;
}

Vertical {
    height: 100%;
    background: #1a1a1a;
}

/* Button styling */
Button {
    background: #4f46e5;
    color: #ffffff;
    border: solid #14b8a6;
}

Button:hover {
    background: #6366f1;
    color: #ffffff;
}

Button.-active {
    background: #14b8a6;
    color: #000000;
}

/* Static widget styling */
Static {
    color: #ffffff;
}

/* Container styling */
Container {
    background: #1a1a1a;
}

/* Focus styling */
*:focus {
    border: solid #14b8a6;
}

/* Success/Error/Info colors using our palette */
.success {
    background: #14b8a6;
    color: #000000;
}

.error {
    background: #000000;
    color: #ffffff;
    border: solid #14b8a6;
}

.info {
    background: #4f46e5;
    color: #ffffff;
}

/* Notification styling */
.notification {
    background: #1f2937;
    color: #ffffff;
    border: solid #14b8a6;
}

/* Organization-specific styling for current org indicator */
.org-current {
    color: #14b8a6;
    text-style: bold;
}

.org-name {
    color: #6366f1;
}

/* Status indicators */
.status-active {
    color: #14b8a6;
}

.status-complete {
    color: #2dd4bf;
}

.status-error {
    color: #ffffff;
    background: #000000;
}

.status-pending {
    color: #9ca3af;
}</file><file path="src/codegen/cli/tui/codegen_tui.tcss">/* Codegen TUI Styles */

Screen {
    background: $background;
}

Header {
    dock: top;
    height: 3;
    background: $primary;
    color: $text;
}

Footer {
    dock: bottom;
    height: 3;
    background: $primary;
    color: $text;
}

.title {
    text-style: bold;
    margin: 1;
    color: $primary;
    text-align: center;
}

.help {
    margin-bottom: 1;
    color: $text-muted;
    text-align: center;
}

.warning-message {
    text-align: center;
    margin: 2;
    padding: 2;
    background: $warning;
    color: $text;
    text-style: bold;
}

DataTable {
    height: 1fr;
    margin-top: 1;
}

DataTable &gt; .datatable--header {
    text-style: bold;
    background: $primary;
    color: $text;
}

DataTable &gt; .datatable--odd-row {
    background: $surface;
}

DataTable &gt; .datatable--even-row {
    background: $background;
}

DataTable &gt; .datatable--cursor {
    background: $accent;
    color: $text;
}

#auth-warning {
    height: 100%;
    align: center middle;
}

Vertical {
    height: 100%;
}</file><file path="src/codegen/cli/utils/codemod_manager.py">import builtins
from pathlib import Path

import rich
import typer

from codegen.cli.utils.function_finder import DecoratedFunction, find_codegen_functions


def _might_have_decorators(file_path: Path) -&gt; bool:
    &quot;&quot;&quot;Quick check if a file might contain codegen decorators.

    This is a fast pre-filter that checks if &apos;@codegen&apos; appears anywhere in the file.
    Much faster than parsing the AST for files that definitely don&apos;t have decorators.
    &quot;&quot;&quot;
    try:
        # Read in binary mode and check for b&apos;@codegen&apos; to handle any encoding
        with open(file_path, &quot;rb&quot;) as f:
            return b&quot;@codegen&quot; in f.read()
    except Exception:
        return False


class CodemodManager:
    &quot;&quot;&quot;Manages codemod operations in the local filesystem.&quot;&quot;&quot;

    @staticmethod
    def get_valid_name(name: str) -&gt; str:
        return name.lower().replace(&quot; &quot;, &quot;_&quot;).replace(&quot;-&quot;, &quot;_&quot;)

    @classmethod
    def get_codemod(cls, name: str, start_path: Path | None = None) -&gt; DecoratedFunction:
        &quot;&quot;&quot;Get and validate a codemod by name.

        Args:
            name: Name of the codemod to find
            start_path: Directory to start searching from (default: current directory)

        Returns:
            The validated DecoratedFunction

        Raises:
            typer.Exit: If codemod can&apos;t be found or loaded
        &quot;&quot;&quot;
        # First try to find the codemod
        codemod = cls.get(name, start_path)
        if not codemod:
            # If not found, check if any codemods exist
            all_codemods = cls.list(start_path)
            if not all_codemods:
                rich.print(&quot;[red]Error:[/red] No codemods found. Create one with:&quot;)
                rich.print(&quot;  codegen create my-codemod&quot;)
                raise typer.Exit(1)
            else:
                available = &quot;\n  &quot;.join(f&quot;- {c.name}&quot; for c in all_codemods)
                rich.print(f&quot;[red]Error:[/red] Codemod &apos;{name}&apos; not found. Available codemods:&quot;)
                rich.print(f&quot;  {available}&quot;)
                raise typer.Exit(1)

        # Verify we can import it
        try:
            # This will raise ValueError if function can&apos;t be imported
            codemod.validate()
            return codemod
        except Exception as e:
            rich.print(f&quot;[red]Error:[/red] Error loading codemod &apos;{name}&apos;: {e!s}&quot;)
            raise typer.Exit(1)

    @classmethod
    def list(cls, start_path: Path | None = None) -&gt; builtins.list[DecoratedFunction]:
        &quot;&quot;&quot;List all codegen decorated functions in Python files under the given path.

        This is an alias for get_decorated for better readability.
        &quot;&quot;&quot;
        return cls.get_decorated(start_path)

    @classmethod
    def get(cls, name: str, start_path: Path | None = None) -&gt; DecoratedFunction | None:
        &quot;&quot;&quot;Get a specific codegen decorated function by name.

        Args:
            name: Name of the function to find (case-insensitive, spaces/hyphens converted to underscores)
            start_path: Directory or file to start searching from. Defaults to current working directory.

        Returns:
            The DecoratedFunction if found, None otherwise

        &quot;&quot;&quot;
        valid_name = cls.get_valid_name(name)
        functions = cls.get_decorated(start_path)

        for func in functions:
            if cls.get_valid_name(func.name) == valid_name:
                return func
        return None

    @classmethod
    def exists(cls, name: str, start_path: Path | None = None) -&gt; bool:
        &quot;&quot;&quot;Check if a codegen decorated function with the given name exists.

        Args:
            name: Name of the function to check (case-insensitive, spaces/hyphens converted to underscores)
            start_path: Directory or file to start searching from. Defaults to current working directory.

        Returns:
            True if the function exists, False otherwise

        &quot;&quot;&quot;
        return cls.get(name, start_path) is not None

    @classmethod
    def get_decorated(cls, start_path: Path | None = None) -&gt; builtins.list[DecoratedFunction]:
        &quot;&quot;&quot;Find all codegen decorated functions in Python files under the given path.

        Args:
            start_path: Directory or file to start searching from. Defaults to current working directory.

        Returns:
            List of DecoratedFunction objects found in the files

        &quot;&quot;&quot;
        if start_path is None:
            start_path = Path.cwd()

        # Look only in .codegen/codemods
        codemods_dir = start_path / &quot;.codegen&quot; / &quot;codemods&quot;
        if not codemods_dir.exists():
            return []

        all_functions = []
        seen_paths = set()  # Track unique file paths

        for path in codemods_dir.rglob(&quot;*.py&quot;):
            # Skip if we&apos;ve already processed this file
            if path in seen_paths:
                continue
            seen_paths.add(path)

            if _might_have_decorators(path):
                try:
                    functions = find_codegen_functions(path)
                    all_functions.extend(functions)
                except Exception:
                    pass  # Skip files we can&apos;t parse

        return all_functions</file><file path="src/codegen/cli/utils/codemods.py">from dataclasses import dataclass
from pathlib import Path

from codegen.cli.api.webapp_routes import generate_webapp_url
from codegen.cli.utils.schema import CodemodConfig


@dataclass
class Codemod:
    &quot;&quot;&quot;Represents a codemod in the local filesystem.&quot;&quot;&quot;

    name: str
    path: Path
    config: CodemodConfig | None = None

    def get_url(self) -&gt; str:
        &quot;&quot;&quot;Get the URL for this codemod.&quot;&quot;&quot;
        if self.config is None:
            return &quot;&quot;
        return generate_webapp_url(path=f&quot;codemod/{self.config.codemod_id}&quot;)

    def relative_path(self) -&gt; str:
        &quot;&quot;&quot;Get the relative path to this codemod.&quot;&quot;&quot;
        return str(self.path.relative_to(Path.cwd()))

    def get_current_source(self) -&gt; str:
        &quot;&quot;&quot;Get the current source code for this codemod.&quot;&quot;&quot;
        text = self.path.read_text()
        text = text.strip()
        return text

    def get_system_prompt_path(self) -&gt; Path:
        &quot;&quot;&quot;Get the path to the system prompt for this codemod.&quot;&quot;&quot;
        return self.path.parent / &quot;system-prompt.md&quot;

    def get_system_prompt(self) -&gt; str:
        &quot;&quot;&quot;Get the system prompt for this codemod.&quot;&quot;&quot;
        path = self.get_system_prompt_path()
        if not path.exists():
            return &quot;&quot;
        return path.read_text()</file><file path="src/codegen/cli/utils/count_functions_2.py">NumberType = int | float</file><file path="src/codegen/cli/utils/default_code.py">DEFAULT_CODEMOD = &apos;&apos;&apos;import codegen
from codegen.sdk.core.codebase import Codebase


@codegen.function(&quot;{name}&quot;)
def run(codebase: Codebase):
    &quot;&quot;&quot;Add a description of what this codemod does.&quot;&quot;&quot;
    # Add your code here
    print(&apos;Total files: &apos;, len(codebase.files))
    print(&apos;Total functions: &apos;, len(codebase.functions))
    print(&apos;Total imports: &apos;, len(codebase.imports))


if __name__ == &quot;__main__&quot;:
    print(&apos;Parsing codebase...&apos;)
    codebase = Codebase(&quot;./&quot;)

    print(&apos;Running...&apos;)
    run(codebase)
&apos;&apos;&apos;</file><file path="src/codegen/cli/utils/function_finder.py">import ast
import dataclasses
import importlib
import importlib.util
from dataclasses import dataclass
from pathlib import Path

from codegen.shared.enums.programming_language import ProgrammingLanguage


@dataclass
class DecoratedFunction:
    &quot;&quot;&quot;Represents a function decorated with @codegen.&quot;&quot;&quot;

    name: str
    source: str
    lint_mode: bool
    lint_user_whitelist: list[str]
    subdirectories: list[str] | None = None
    language: ProgrammingLanguage | None = None
    filepath: Path | None = None
    parameters: list[tuple[str, str | None]] = dataclasses.field(default_factory=list)
    arguments_type_schema: dict | None = None

    def run(self, codebase) -&gt; str | None:
        &quot;&quot;&quot;Import and run the actual function from its file.

        Args:
            codebase: The codebase to run the function on

        Returns:
            The result of running the function (usually a diff string)
        &quot;&quot;&quot;
        if not self.filepath:
            msg = &quot;Cannot run function without filepath&quot;
            raise ValueError(msg)

        # Import the module containing the function
        spec = importlib.util.spec_from_file_location(&quot;module&quot;, self.filepath)
        if not spec or not spec.loader:
            msg = f&quot;Could not load module from {self.filepath}&quot;
            raise ImportError(msg)

        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # Find the decorated function
        for item_name in dir(module):
            item = getattr(module, item_name)
            if hasattr(item, &quot;__codegen_name__&quot;) and item.__codegen_name__ == self.name:
                # Found our function, run it
                return item(codebase)

        msg = f&quot;Could not find function &apos;{self.name}&apos; in {self.filepath}&quot;
        raise ValueError(msg)

    def validate(self) -&gt; None:
        &quot;&quot;&quot;Verify that this function can be imported and accessed.

        Raises:
            ValueError: If the function can&apos;t be found or imported
        &quot;&quot;&quot;
        if not self.filepath:
            msg = &quot;Cannot validate function without filepath&quot;
            raise ValueError(msg)

        # Import the module containing the function
        spec = importlib.util.spec_from_file_location(&quot;module&quot;, self.filepath)
        if not spec or not spec.loader:
            msg = f&quot;Could not load module from {self.filepath}&quot;
            raise ImportError(msg)

        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # Find the decorated function
        for item_name in dir(module):
            item = getattr(module, item_name)
            if hasattr(item, &quot;__codegen_name__&quot;) and item.__codegen_name__ == self.name:
                return  # Found it!

        msg = f&quot;Could not find function &apos;{self.name}&apos; in {self.filepath}&quot;
        raise ValueError(msg)


class CodegenFunctionVisitor(ast.NodeVisitor):
    def __init__(self):
        self.functions: list[DecoratedFunction] = []
        self.file_content: str = &quot;&quot;

    def get_function_name(self, node: ast.Call) -&gt; str:
        keywords = {k.arg: k.value for k in node.keywords}
        if &quot;name&quot; in keywords:
            return ast.literal_eval(keywords[&quot;name&quot;])
        return ast.literal_eval(node.args[0])

    def get_subdirectories(self, node: ast.Call) -&gt; list[str] | None:
        keywords = {k.arg: k.value for k in node.keywords}
        if &quot;subdirectories&quot; in keywords:
            return ast.literal_eval(keywords[&quot;subdirectories&quot;])
        if len(node.args) &gt; 1:
            return ast.literal_eval(node.args[1])
        return None

    def get_language(self, node: ast.Call) -&gt; ProgrammingLanguage | None:
        keywords = {k.arg: k.value for k in node.keywords}
        if &quot;language&quot; in keywords:
            lang_node = keywords[&quot;language&quot;]
            if hasattr(lang_node, &quot;attr&quot;):
                return ProgrammingLanguage(lang_node.attr)
            else:
                return ProgrammingLanguage(ast.literal_eval(lang_node))
        if len(node.args) &gt; 2:
            return ast.literal_eval(node.args[2])
        return None

    def get_function_body(self, node: ast.FunctionDef) -&gt; str:
        &quot;&quot;&quot;Extract and unindent the function body.&quot;&quot;&quot;
        # Get the start and end positions of the function body
        first_stmt = node.body[0]
        last_stmt = node.body[-1]

        # Get the line numbers (1-based in source lines)
        start_line = first_stmt.lineno - 1  # Convert to 0-based
        end_line = last_stmt.end_lineno if hasattr(last_stmt, &quot;end_lineno&quot;) else last_stmt.lineno

        # Get the raw source lines for the entire body
        source_lines = self.source.splitlines()[start_line:end_line]

        # Find the minimum indentation of non-empty lines
        indents = [len(line) - len(line.lstrip()) for line in source_lines if line.strip()]
        if not indents:
            return &quot;&quot;

        min_indent = min(indents)

        # Remove the minimum indentation from each line
        unindented_lines = []
        for line in source_lines:
            if line.strip():  # Non-empty line
                unindented_lines.append(line[min_indent:])
            else:  # Empty line
                unindented_lines.append(&quot;&quot;)

        return &quot;\n&quot;.join(unindented_lines)

    def _get_annotation(self, annotation) -&gt; str:
        &quot;&quot;&quot;Helper function to retrieve the string representation of an annotation.

        Args:
            annotation: The annotation node.

        Returns:
            str: The string representation of the annotation.

        &quot;&quot;&quot;
        if isinstance(annotation, ast.Name):
            return annotation.id
        elif isinstance(annotation, ast.Subscript):
            return f&quot;{self._get_annotation(annotation.value)}[{self._get_annotation(annotation.slice)}]&quot;
        elif isinstance(annotation, ast.Attribute):
            return f&quot;{self._get_annotation(annotation.value)}.{annotation.attr}&quot;
        elif isinstance(annotation, ast.Tuple):
            return &quot;, &quot;.join(self._get_annotation(elt) for elt in annotation.elts)
        else:
            return &quot;Any&quot;

    def get_function_parameters(self, node: ast.FunctionDef) -&gt; list[tuple[str, str | None]]:
        &quot;&quot;&quot;Extracts the parameters and their types from an AST FunctionDef node.

        Args:
            node (ast.FunctionDef): The AST node of the function.

        Returns:
            List[Tuple[str, Optional[str]]]: A list of tuples containing parameter names and their type annotations.
                                            The type is `None` if no annotation is present.

        &quot;&quot;&quot;
        parameters = []
        for arg in node.args.args:
            param_name = arg.arg
            if arg.annotation:
                param_type = ast.unparse(arg.annotation) if hasattr(ast, &quot;unparse&quot;) else self._get_annotation(arg.annotation)
            else:
                param_type = None
            parameters.append((param_name, param_type))

        # Handle *args
        if node.args.vararg:
            param_name = f&quot;*{node.args.vararg.arg}&quot;
            if node.args.vararg.annotation:
                param_type = ast.unparse(node.args.vararg.annotation) if hasattr(ast, &quot;unparse&quot;) else self._get_annotation(node.args.vararg)
            else:
                param_type = None
            parameters.append((param_name, param_type))

        # Handle **kwargs
        if node.args.kwarg:
            param_name = f&quot;**{node.args.kwarg.arg}&quot;
            if node.args.kwarg.annotation:
                param_type = ast.unparse(node.args.kwarg.annotation) if hasattr(ast, &quot;unparse&quot;) else self._get_annotation(node.args.kwarg)
            else:
                param_type = None
            parameters.append((param_name, param_type))

        return parameters

    def visit_FunctionDef(self, node):
        for decorator in node.decorator_list:
            if (
                isinstance(decorator, ast.Call)
                and (len(decorator.args) &gt; 0 or len(decorator.keywords) &gt; 0)
                and (
                    # Check if it&apos;s a direct codegen.X call
                    (isinstance(decorator.func, ast.Attribute) and isinstance(decorator.func.value, ast.Name) and decorator.func.value.id == &quot;codegen&quot;)
                    or
                    # Check if it starts with codegen.anything.anything...
                    (isinstance(decorator.func, ast.Attribute) and isinstance(decorator.func.value, ast.Attribute) and self._has_codegen_root(decorator.func.value))
                )
            ):
                # Get additional metadata for webhook
                lint_mode = decorator.func.attr == &quot;webhook&quot;
                lint_user_whitelist = []
                if lint_mode and len(decorator.keywords) &gt; 0:
                    for keyword in decorator.keywords:
                        if keyword.arg == &quot;users&quot; and isinstance(keyword.value, ast.List):
                            lint_user_whitelist = [ast.literal_eval(elt).lstrip(&quot;@&quot;) for elt in keyword.value.elts]

                self.functions.append(
                    DecoratedFunction(
                        name=self.get_function_name(decorator),
                        subdirectories=self.get_subdirectories(decorator),
                        language=self.get_language(decorator),
                        source=self.get_function_body(node),
                        lint_mode=lint_mode,
                        lint_user_whitelist=lint_user_whitelist,
                        parameters=self.get_function_parameters(node),
                    )
                )

    def _has_codegen_root(self, node):
        &quot;&quot;&quot;Recursively check if an AST node chain starts with codegen.&quot;&quot;&quot;
        if isinstance(node, ast.Name):
            return node.id == &quot;codegen&quot;
        elif isinstance(node, ast.Attribute):
            return self._has_codegen_root(node.value)
        return False

    def _get_decorator_attrs(self, node):
        &quot;&quot;&quot;Get all attribute names in a decorator chain.&quot;&quot;&quot;
        attrs = []
        while isinstance(node, ast.Attribute):
            attrs.append(node.attr)
            node = node.value
        return attrs

    def visit_Module(self, node):
        # Store the full source code for later use
        self.source = self.file_content
        self.generic_visit(node)


def _extract_arguments_type_schema(func: DecoratedFunction) -&gt; dict | None:
    &quot;&quot;&quot;Extracts the arguments type schema from a DecoratedFunction object.&quot;&quot;&quot;
    try:
        spec = importlib.util.spec_from_file_location(&quot;module&quot;, func.filepath)
        if spec is None or spec.loader is None:
            return None
        module = importlib.util.module_from_spec(spec)

        fn_arguments_param_type = None
        for p in func.parameters:
            if p[0] == &quot;arguments&quot;:
                fn_arguments_param_type = p[1]

        if fn_arguments_param_type is not None:
            spec.loader.exec_module(module)

            schema = getattr(module, fn_arguments_param_type).model_json_schema()
            return schema
        return None
    except Exception as e:
        print(f&quot;Error parsing {func.filepath}, could not introspect for arguments parameter&quot;)
        print(e)
        return None


def find_codegen_functions(filepath: Path) -&gt; list[DecoratedFunction]:
    &quot;&quot;&quot;Find all codegen functions in a Python file.

    Args:
        filepath: Path to the Python file to search

    Returns:
        List of DecoratedFunction objects found in the file

    Raises:
        Exception: If the file cannot be parsed

    &quot;&quot;&quot;
    # Read and parse the file
    with open(filepath) as f:
        file_content = f.read()
        tree = ast.parse(file_content)

    # Find all codegen.function decorators
    visitor = CodegenFunctionVisitor()
    visitor.file_content = file_content
    visitor.visit(tree)

    # Add filepath to each function
    for func in visitor.functions:
        func.filepath = filepath
        func.arguments_type_schema = _extract_arguments_type_schema(func)

    return visitor.functions</file><file path="src/codegen/cli/utils/inplace_print.py">import sys
from typing import Iterable


def inplace_print(lines: Iterable[str], prev_lines_rendered: int) -&gt; int:
    &quot;&quot;&quot;Redraw a small block of text in-place without scrolling.

    Args:
            lines: The lines to render (each should NOT include a trailing newline)
            prev_lines_rendered: How many lines were rendered in the previous frame. Pass 0 on first call.

    Returns:
            The number of lines rendered this call. Use as prev_lines_rendered on the next call.
    &quot;&quot;&quot;
    # Move cursor up to the start of the previous block (if any)
    if prev_lines_rendered &gt; 0:
        sys.stdout.write(f&quot;\x1b[{prev_lines_rendered}F&quot;)  # Cursor up N lines

    # Rewrite each line, clearing it first to avoid remnants from previous content
    count = 0
    for line in lines:
        sys.stdout.write(&quot;\x1b[2K\r&quot;)  # Clear entire line and return carriage
        sys.stdout.write(f&quot;{line}\n&quot;)
        count += 1

    sys.stdout.flush()
    return count</file><file path="src/codegen/cli/utils/json_schema.py">import json
from pathlib import Path
from tempfile import TemporaryDirectory
from typing import Any

from datamodel_code_generator import DataModelType, InputFileType, generate
from pydantic import BaseModel

# This utility contains functions for utilizing, transforming and validating JSON schemas generated by Pydantic models.


def get_schema(model: BaseModel) -&gt; dict:
    return model.model_json_schema()


def validate_json(schema: dict, json_data: str) -&gt; bool:
    json_schema = json.dumps(schema)
    exec_scope: dict[str, Any] = {}
    model_name = schema[&quot;title&quot;]
    with TemporaryDirectory() as temporary_directory_name:
        temporary_directory = Path(temporary_directory_name)
        output = Path(temporary_directory / &quot;model.py&quot;)
        generate(
            json_schema,
            input_file_type=InputFileType.JsonSchema,
            input_filename=&quot;temp.json&quot;,
            output=output,
            # set up the output model types
            output_model_type=DataModelType.PydanticV2BaseModel,
        )

        exec(output.read_text(), exec_scope, exec_scope)
    print(f&quot;exec_scope: {exec_scope}&quot;)
    model = exec_scope.get(model_name)
    if model is None:
        return False
    try:
        model.model_validate_json(json_data)
        return True
    except Exception as e:
        return False</file><file path="src/codegen/cli/utils/notebooks.py">import json
from pathlib import Path
from typing import Any

DEFAULT_CELLS = [
    {
        &quot;cell_type&quot;: &quot;code&quot;,
        &quot;source&quot;: &quot;&quot;&quot;from codegen.sdk.core.codebase import Codebase

# Initialize codebase
codebase = Codebase(&apos;../../&apos;)

# Print out stats
print(&quot;ðŸ” Codebase Analysis&quot;)
print(&quot;=&quot; * 50)
print(f&quot;ðŸ“š Total Files: {len(codebase.files)}&quot;)
print(f&quot;âš¡ Total Functions: {len(codebase.functions)}&quot;)
print(f&quot;ðŸ”„ Total Imports: {len(codebase.imports)}&quot;)&quot;&quot;&quot;.strip(),
    }
]

DEMO_CELLS = [
    ##### [ CODEGEN DEMO ] #####
    {
        &quot;cell_type&quot;: &quot;markdown&quot;,
        &quot;source&quot;: &quot;&quot;&quot;# Codegen Demo: FastAPI

Welcome to [Codegen](https://docs.codegen.com)!

This demo notebook will walk you through some features of Codegen applied to [FastAPI](https://github.com/fastapi/fastapi).

See the [getting started](https://docs.codegen.com/introduction/getting-started) guide to learn more.&quot;&quot;&quot;.strip(),
    },
    {
        &quot;cell_type&quot;: &quot;code&quot;,
        &quot;source&quot;: &quot;&quot;&quot;from codegen.sdk.core.codebase import Codebase

# Initialize FastAPI codebase
print(&apos;Cloning and parsing FastAPI to /tmp/codegen/fastapi...&apos;)
codebase = Codebase.from_repo(&apos;fastapi/fastapi&apos;, commit=&quot;eab0653a346196bff6928710410890a300aee4ae&quot;)

# To initialize a local codebase, use this constructor
# codebase = Codebase(&quot;path/to/git/repo&quot;)&quot;&quot;&quot;.strip(),
    },
    ##### [ CODEBASE ANALYSIS ] #####
    {
        &quot;cell_type&quot;: &quot;markdown&quot;,
        &quot;source&quot;: &quot;&quot;&quot;# Codebase Analysis

Let&apos;s do a quick codebase analysis!

- Grab codebase content with [codebase.functions](https://docs.codegen.com/building-with-codegen/symbol-api) et al.
- View inheritance hierarchies with [inhertance APIs](https://docs.codegen.com/building-with-codegen/class-api#working-with-inheritance)
- Identify recursive functions by looking at [FunctionCalls](https://docs.codegen.com/building-with-codegen/function-calls-and-callsites)&quot;&quot;&quot;.strip(),
    },
    {
        &quot;cell_type&quot;: &quot;code&quot;,
        &quot;source&quot;: &quot;&quot;&quot;# Print overall stats
print(&quot;ðŸ” FastAPI Analysis&quot;)
print(&quot;=&quot; * 50)
print(f&quot;ðŸ“š Total Classes: {len(codebase.classes)}&quot;)
print(f&quot;âš¡ Total Functions: {len(codebase.functions)}&quot;)
print(f&quot;ðŸ”„ Total Imports: {len(codebase.imports)}&quot;)

# Find class with most inheritance
if codebase.classes:
    deepest_class = max(codebase.classes, key=lambda x: len(x.superclasses))
    print(f&quot;\\nðŸŒ³ Class with most inheritance: {deepest_class.name}&quot;)
    print(f&quot;   ðŸ“Š Chain Depth: {len(deepest_class.superclasses)}&quot;)
    print(f&quot;   â›“ï¸ Chain: {&apos; -&gt; &apos;.join(s.name for s in deepest_class.superclasses)}&quot;)

# Find first 5 recursive functions
recursive = [f for f in codebase.functions
            if any(call.name == f.name for call in f.function_calls)][:5]
if recursive:
    print(f&quot;\\nðŸ”„ Recursive functions:&quot;)
    for func in recursive:
        print(f&quot;  - {func.name} ({func.file.filepath})&quot;)&quot;&quot;&quot;.strip(),
    },
    ##### [ TEST DRILL DOWN ] #####
    {
        &quot;cell_type&quot;: &quot;markdown&quot;,
        &quot;source&quot;: &quot;&quot;&quot;# Drilling Down on Tests

Let&apos;s specifically drill into large test files, which can be cumbersome to manage:&quot;&quot;&quot;.strip(),
    },
    {
        &quot;cell_type&quot;: &quot;code&quot;,
        &quot;source&quot;: &quot;&quot;&quot;from collections import Counter

# Filter to all test functions and classes
test_functions = [x for x in codebase.functions if x.name.startswith(&apos;test_&apos;)]

print(&quot;ðŸ§ª Test Analysis&quot;)
print(&quot;=&quot; * 50)
print(f&quot;ðŸ“ Total Test Functions: {len(test_functions)}&quot;)
print(f&quot;ðŸ“Š Tests per File: {len(test_functions) / len(codebase.files):.1f}&quot;)

# Find files with the most tests
print(&quot;\\nðŸ“š Top Test Files by Count&quot;)
print(&quot;-&quot; * 50)
file_test_counts = Counter([x.file for x in test_functions])
for file, num_tests in file_test_counts.most_common()[:5]:
    print(f&quot;ðŸ” {num_tests} test functions: {file.filepath}&quot;)
    print(f&quot;   ðŸ“ File Length: {len(file.source.split(&apos;\\n&apos;))} lines&quot;)
    print(f&quot;   ðŸ’¡ Functions: {len(file.functions)}&quot;)&quot;&quot;&quot;.strip(),
    },
    ##### [ TEST SPLITTING ] #####
    {
        &quot;cell_type&quot;: &quot;markdown&quot;,
        &quot;source&quot;: &quot;&quot;&quot;# Splitting Up Large Test Files

Lets split up the largest test files into separate modules for better organization.

This uses Codegen&apos;s [codebase.move_to_file(...)](https://docs.codegen.com/building-with-codegen/moving-symbols), which will:
- update all imports
- (optionally) move depenencies
- do so very fast âš¡ï¸

While maintaining correctness.&quot;&quot;&quot;,
    },
    ##### [ TEST SPLITTING ] #####
    {
        &quot;cell_type&quot;: &quot;code&quot;,
        &quot;source&quot;: &quot;&quot;&quot;filename = &apos;tests/test_path.py&apos;
print(f&quot;ðŸ“¦ Splitting Test File: {filename}&quot;)
print(&quot;=&quot; * 50)

# Grab a file
file = codebase.get_file(filename)
base_name = filename.replace(&apos;.py&apos;, &apos;&apos;)

# Group tests by subpath
test_groups = {}
for test_function in file.functions:
    if test_function.name.startswith(&apos;test_&apos;):
        test_subpath = &apos;_&apos;.join(test_function.name.split(&apos;_&apos;)[:3])
        if test_subpath not in test_groups:
            test_groups[test_subpath] = []
        test_groups[test_subpath].append(test_function)

# Print and process each group
for subpath, tests in test_groups.items():
    print(f&quot;\\n{subpath}/&quot;)
    new_filename = f&quot;{base_name}/{subpath}.py&quot;

    # Create file if it doesn&apos;t exist
    if not codebase.has_file(new_filename):
        new_file = codebase.create_file(new_filename)
    file = codebase.get_file(new_filename)

    # Move each test in the group
    for test_function in tests:
        print(f&quot;    - {test_function.name}&quot;)
        test_function.move_to_file(new_file, strategy=&quot;add_back_edge&quot;)

# Commit changes to disk
codebase.commit()&quot;&quot;&quot;.strip(),
    },
    ##### [ RESET ] #####
    {
        &quot;cell_type&quot;: &quot;markdown&quot;,
        &quot;source&quot;: &quot;&quot;&quot;## View Changes

You can now view changes by `cd /tmp/codegen/fastapi &amp;&amp; git diff`

Enjoy!

# Reset

Reset your codebase to it&apos;s initial state, discarding all changes

Learn more in [commit and reset](https://docs.codegen.com/building-with-codegen/commit-and-reset).&quot;&quot;&quot;.strip(),
    },
    {
        &quot;cell_type&quot;: &quot;code&quot;,
        &quot;source&quot;: &quot;&quot;&quot;codebase.reset()&quot;&quot;&quot;.strip(),
    },
]


def create_cells(cells_data: list[dict[str, str]]) -&gt; list[dict[str, Any]]:
    &quot;&quot;&quot;Convert cell data into Jupyter notebook cell format.&quot;&quot;&quot;
    return [
        {
            &quot;cell_type&quot;: cell[&quot;cell_type&quot;],
            &quot;source&quot;: cell[&quot;source&quot;],
            &quot;metadata&quot;: {},
            &quot;execution_count&quot;: None,
            &quot;outputs&quot;: [] if cell[&quot;cell_type&quot;] == &quot;code&quot; else None,
        }
        for cell in cells_data
    ]


def create_notebook(jupyter_dir: Path, demo: bool = False) -&gt; Path:
    &quot;&quot;&quot;Create a new Jupyter notebook if it doesn&apos;t exist.

    Args:
        jupyter_dir: Directory where the notebook should be created
        demo: Whether to create a demo notebook with FastAPI example code

    Returns:
        Path to the created or existing notebook
    &quot;&quot;&quot;
    notebook_path = jupyter_dir / (&quot;demo.ipynb&quot; if demo else &quot;tmp.ipynb&quot;)
    if not notebook_path.exists():
        cells = create_cells(DEMO_CELLS if demo else DEFAULT_CELLS)
        notebook_content = {
            &quot;cells&quot;: cells,
            &quot;metadata&quot;: {&quot;kernelspec&quot;: {&quot;display_name&quot;: &quot;Python 3&quot;, &quot;language&quot;: &quot;python&quot;, &quot;name&quot;: &quot;python3&quot;}},
            &quot;nbformat&quot;: 4,
            &quot;nbformat_minor&quot;: 4,
        }
        notebook_path.write_text(json.dumps(notebook_content, indent=2))
    return notebook_path</file><file path="src/codegen/cli/utils/org.py">&quot;&quot;&quot;Organization resolution utilities for CLI commands.&quot;&quot;&quot;

import os
import time

import requests

from codegen.cli.api.endpoints import API_ENDPOINT
from codegen.cli.auth.token_manager import (
    get_cached_organizations,
    get_current_org_id,
    get_current_token,
    get_org_name_from_cache,
    is_org_id_cached,
)
from codegen.cli.commands.claude.quiet_console import console

# Cache for org resolution to avoid repeated API calls
_org_cache = {}
_cache_timeout = 300  # 5 minutes


def resolve_org_id(explicit_org_id: int | None = None) -&gt; int | None:
    &quot;&quot;&quot;Resolve organization ID with fallback strategy and cache validation.

    Order of precedence:
    1) explicit_org_id passed by the caller (validated against cache)
    2) CODEGEN_ORG_ID environment variable (validated against cache if available)
    3) REPOSITORY_ORG_ID environment variable (validated against cache if available)
    4) stored org ID from auth data (fast, no API call)
    5) API auto-detection (uses first organization from user&apos;s organizations)

    Returns None if not found.
    &quot;&quot;&quot;
    global _org_cache

    def _validate_org_id_with_cache(org_id: int, source: str) -&gt; int | None:
        &quot;&quot;&quot;Validate an org ID against the cache and show helpful errors.&quot;&quot;&quot;
        if is_org_id_cached(org_id):
            return org_id
        
        # If we have a cache but the org ID is not in it, show helpful error
        cached_orgs = get_cached_organizations()
        if cached_orgs:
            org_list = &quot;, &quot;.join([f&quot;{org[&apos;name&apos;]} ({org[&apos;id&apos;]})&quot; for org in cached_orgs])
            console.print(f&quot;[red]Error:[/red] Organization ID {org_id} from {source} not found in your accessible organizations.&quot;)
            console.print(f&quot;[yellow]Available organizations:[/yellow] {org_list}&quot;)
            return None
        
        # If no cache available, trust the org ID (will be validated by API)
        return org_id

    if explicit_org_id is not None:
        return _validate_org_id_with_cache(explicit_org_id, &quot;command line&quot;)

    env_val = os.environ.get(&quot;CODEGEN_ORG_ID&quot;)
    if env_val is not None and env_val != &quot;&quot;:
        try:
            env_org_id = int(env_val)
            return _validate_org_id_with_cache(env_org_id, &quot;CODEGEN_ORG_ID&quot;)
        except ValueError:
            console.print(f&quot;[red]Error:[/red] Invalid CODEGEN_ORG_ID value: {env_val}&quot;)
            return None

    # Try repository-scoped org id from .env
    repo_org = os.environ.get(&quot;REPOSITORY_ORG_ID&quot;)
    if repo_org:
        try:
            repo_org_id = int(repo_org)
            return _validate_org_id_with_cache(repo_org_id, &quot;REPOSITORY_ORG_ID&quot;)
        except ValueError:
            console.print(f&quot;[red]Error:[/red] Invalid REPOSITORY_ORG_ID value: {repo_org}&quot;)
            return None

    # Try stored org ID from auth data (fast, no API call)
    stored_org_id = get_current_org_id()
    if stored_org_id:
        return stored_org_id

    # Attempt auto-detection via API: if user belongs to organizations, use the first
    try:
        token = get_current_token()
        if not token:
            return None

        # Check cache first
        cache_key = f&quot;org_auto_detect_{token[:10]}&quot;  # Use first 10 chars as key
        current_time = time.time()

        if cache_key in _org_cache:
            cached_data, cache_time = _org_cache[cache_key]
            if current_time - cache_time &lt; _cache_timeout:
                return cached_data

        headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}
        url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations&quot;
        resp = requests.get(url, headers=headers, timeout=10)
        resp.raise_for_status()
        data = resp.json()
        items = data.get(&quot;items&quot;) or []

        org_id = None
        if isinstance(items, list) and len(items) &gt;= 1:
            org = items[0]
            org_id_raw = org.get(&quot;id&quot;)
            try:
                org_id = int(org_id_raw)
            except Exception:
                org_id = None

        # Cache the result
        _org_cache[cache_key] = (org_id, current_time)
        return org_id

    except Exception as e:
        console.print(f&quot;Error during organization auto-detection: {e}&quot;)
        return None</file><file path="src/codegen/cli/utils/repo.py">&quot;&quot;&quot;Repository utilities for managing repository ID resolution and environment variables.&quot;&quot;&quot;

import os
from typing import Dict, List, Any

from rich.console import Console

console = Console()


def resolve_repo_id(explicit_repo_id: int | None = None) -&gt; int | None:
    &quot;&quot;&quot;Resolve repository ID with fallback strategy.
    
    Order of precedence:
    1) explicit_repo_id passed by the caller
    2) CODEGEN_REPO_ID environment variable
    3) REPOSITORY_ID environment variable
    
    Returns None if not found.
    &quot;&quot;&quot;
    if explicit_repo_id is not None:
        return explicit_repo_id

    # Check CODEGEN_REPO_ID environment variable
    env_val = os.environ.get(&quot;CODEGEN_REPO_ID&quot;)
    if env_val is not None and env_val != &quot;&quot;:
        try:
            return int(env_val)
        except ValueError:
            console.print(f&quot;[red]Error:[/red] Invalid CODEGEN_REPO_ID value: {env_val}&quot;)
            return None

    # Check REPOSITORY_ID environment variable
    repo_id_env = os.environ.get(&quot;REPOSITORY_ID&quot;)
    if repo_id_env is not None and repo_id_env != &quot;&quot;:
        try:
            return int(repo_id_env)
        except ValueError:
            console.print(f&quot;[red]Error:[/red] Invalid REPOSITORY_ID value: {repo_id_env}&quot;)
            return None

    return None


def get_current_repo_id() -&gt; int | None:
    &quot;&quot;&quot;Get the current repository ID from environment variables.&quot;&quot;&quot;
    return resolve_repo_id()


def get_repo_env_status() -&gt; Dict[str, str]:
    &quot;&quot;&quot;Get the status of repository-related environment variables.&quot;&quot;&quot;
    return {
        &quot;CODEGEN_REPO_ID&quot;: os.environ.get(&quot;CODEGEN_REPO_ID&quot;, &quot;Not set&quot;),
        &quot;REPOSITORY_ID&quot;: os.environ.get(&quot;REPOSITORY_ID&quot;, &quot;Not set&quot;),
    }


def set_repo_env_variable(repo_id: int, var_name: str = &quot;CODEGEN_REPO_ID&quot;) -&gt; bool:
    &quot;&quot;&quot;Set repository ID in environment variable.
    
    Args:
        repo_id: Repository ID to set
        var_name: Environment variable name (default: CODEGEN_REPO_ID)
        
    Returns:
        True if successful, False otherwise
    &quot;&quot;&quot;
    try:
        os.environ[var_name] = str(repo_id)
        return True
    except Exception as e:
        console.print(f&quot;[red]Error setting {var_name}:[/red] {e}&quot;)
        return False


def clear_repo_env_variables() -&gt; None:
    &quot;&quot;&quot;Clear all repository-related environment variables.&quot;&quot;&quot;
    env_vars = [&quot;CODEGEN_REPO_ID&quot;, &quot;REPOSITORY_ID&quot;]
    for var in env_vars:
        if var in os.environ:
            del os.environ[var]


def update_env_file_with_repo(repo_id: int, env_file_path: str = &quot;.env&quot;) -&gt; bool:
    &quot;&quot;&quot;Update .env file with repository ID.&quot;&quot;&quot;
    try:
        lines = []
        key_updated = False
        key_to_update = &quot;CODEGEN_REPO_ID&quot;
        
        # Read existing .env file if it exists
        if os.path.exists(env_file_path):
            with open(env_file_path, &quot;r&quot;) as f:
                lines = f.readlines()
        
        # Update or add the key
        for i, line in enumerate(lines):
            if line.strip().startswith(f&quot;{key_to_update}=&quot;):
                lines[i] = f&quot;{key_to_update}={repo_id}\n&quot;
                key_updated = True
                break
        
        # If key wasn&apos;t found, add it
        if not key_updated:
            if lines and not lines[-1].endswith(&apos;\n&apos;):
                lines.append(&apos;\n&apos;)
            lines.append(f&quot;{key_to_update}={repo_id}\n&quot;)
        
        # Write back to file
        with open(env_file_path, &quot;w&quot;) as f:
            f.writelines(lines)
        
        return True
        
    except Exception as e:
        console.print(f&quot;[red]Error updating .env file:[/red] {e}&quot;)
        return False


def get_repo_display_info() -&gt; List[Dict[str, str]]:
    &quot;&quot;&quot;Get repository information for display in TUI.&quot;&quot;&quot;
    repo_id = get_current_repo_id()
    env_status = get_repo_env_status()
    
    info = []
    
    # Current repository ID
    if repo_id:
        info.append({
            &quot;label&quot;: &quot;Current Repository ID&quot;,
            &quot;value&quot;: str(repo_id),
            &quot;status&quot;: &quot;active&quot;
        })
    else:
        info.append({
            &quot;label&quot;: &quot;Current Repository ID&quot;, 
            &quot;value&quot;: &quot;Not configured&quot;,
            &quot;status&quot;: &quot;inactive&quot;
        })
    
    # Environment variables status
    for var_name, value in env_status.items():
        info.append({
            &quot;label&quot;: f&quot;{var_name}&quot;,
            &quot;value&quot;: value,
            &quot;status&quot;: &quot;active&quot; if value != &quot;Not set&quot; else &quot;inactive&quot;
        })
    
    return info


def fetch_repositories_for_org(org_id: int) -&gt; List[Dict[str, Any]]:
    &quot;&quot;&quot;Fetch repositories for an organization.
    
    Args:
        org_id: Organization ID to fetch repositories for
        
    Returns:
        List of repository dictionaries
    &quot;&quot;&quot;
    try:
        import requests
        from codegen.cli.api.endpoints import API_ENDPOINT
        from codegen.cli.auth.token_manager import get_current_token
        
        token = get_current_token()
        if not token:
            return []
            
        headers = {&quot;Authorization&quot;: f&quot;Bearer {token}&quot;}
        
        # Try the repository endpoint (may not exist yet)
        url = f&quot;{API_ENDPOINT.rstrip(&apos;/&apos;)}/v1/organizations/{org_id}/repositories&quot;
        response = requests.get(url, headers=headers)
        
        if response.status_code == 200:
            data = response.json()
            return data.get(&quot;items&quot;, [])
        else:
            # API endpoint doesn&apos;t exist yet, return mock data for demo
            return get_mock_repositories()
            
    except Exception:
        # If API fails, return mock data
        return get_mock_repositories()


def get_mock_repositories() -&gt; List[Dict[str, Any]]:
    &quot;&quot;&quot;Get mock repository data for demonstration.
    
    Returns:
        List of mock repository dictionaries
    &quot;&quot;&quot;
    return [
        {&quot;id&quot;: 1, &quot;name&quot;: &quot;codegen-sdk&quot;, &quot;description&quot;: &quot;Codegen SDK repository&quot;},
        {&quot;id&quot;: 2, &quot;name&quot;: &quot;web-frontend&quot;, &quot;description&quot;: &quot;Frontend web application&quot;},
        {&quot;id&quot;: 3, &quot;name&quot;: &quot;api-backend&quot;, &quot;description&quot;: &quot;Backend API service&quot;},
        {&quot;id&quot;: 4, &quot;name&quot;: &quot;mobile-app&quot;, &quot;description&quot;: &quot;Mobile application&quot;},
        {&quot;id&quot;: 5, &quot;name&quot;: &quot;docs-site&quot;, &quot;description&quot;: &quot;Documentation website&quot;},
        {&quot;id&quot;: 6, &quot;name&quot;: &quot;cli-tools&quot;, &quot;description&quot;: &quot;Command line tools&quot;},
        {&quot;id&quot;: 7, &quot;name&quot;: &quot;data-pipeline&quot;, &quot;description&quot;: &quot;Data processing pipeline&quot;},
        {&quot;id&quot;: 8, &quot;name&quot;: &quot;ml-models&quot;, &quot;description&quot;: &quot;Machine learning models&quot;},
    ]


def ensure_repositories_cached(org_id: int | None = None) -&gt; List[Dict[str, Any]]:
    &quot;&quot;&quot;Ensure repositories are cached for the given organization.
    
    Args:
        org_id: Organization ID (will resolve if not provided)
        
    Returns:
        List of cached repositories
    &quot;&quot;&quot;
    from codegen.cli.auth.token_manager import get_cached_repositories, cache_repositories
    from codegen.cli.utils.org import resolve_org_id
    
    # Get cached repositories first
    cached_repos = get_cached_repositories()
    if cached_repos:
        return cached_repos
    
    # If no cache, try to fetch from API
    if org_id is None:
        org_id = resolve_org_id()
    
    if org_id:
        repositories = fetch_repositories_for_org(org_id)
        if repositories:
            cache_repositories(repositories)
            return repositories
    
    # Fallback to mock data
    mock_repos = get_mock_repositories()
    cache_repositories(mock_repos)
    return mock_repos</file><file path="src/codegen/cli/utils/schema.ipynb">{
 &quot;cells&quot;: [
  {
   &quot;cell_type&quot;: &quot;code&quot;,
   &quot;execution_count&quot;: null,
   &quot;metadata&quot;: {},
   &quot;outputs&quot;: [],
   &quot;source&quot;: [
    &quot;# with model that should validate\n&quot;,
    &quot;from codegen.cli.api.schemas import RunCodemodOutput\n&quot;,
    &quot;\n&quot;,
    &quot;\n&quot;,
    &quot;res = RunCodemodOutput.model_validate(\n&quot;,
    &quot;    {\n&quot;,
    &quot;        \&quot;success\&quot;: True,\n&quot;,
    &quot;        \&quot;web_link\&quot;: \&quot;https://chadcode.sh/codemod/13264/code/21435/run/28349/playground/diff\&quot;,\n&quot;,
    &quot;        \&quot;logs\&quot;: \&quot;\&quot;,\n&quot;,
    &quot;        \&quot;observation\&quot;: &apos;diff --git a/codegen-backend/app/utils/slack/interactive/handlers/BaseSlackActionHandler.py b/codegen-backend/app/utils/slack/interactive/handlers/BaseSlackActionHandler.py\\nindex 2dce963196b418caad011d175fb3110e03a8fe73..77c430a5acfb1613ac42c5712cc2859f31d7d773 100644\\n--- a/codegen-backend/app/utils/slack/interactive/handlers/BaseSlackActionHandler.py\\n+++ b/codegen-backend/app/utils/slack/interactive/handlers/BaseSlackActionHandler.py\\n@@ -1,12 +1,1 @@\\n-from sqlalchemy.orm import Session\\n-\\n-\\n-class BaseSlackInteractiveActionHandler:\\n-    db: Session\\n-\\n-    def __init__(self, db: Session) -&gt; None:\\n-        self.db = db\\n-\\n-    # TODO: convert the message information into a shared schema\\n-    def process_action(self, action_payload: str, channel_id: str, thread_ts: str):\\n-        raise NotImplementedError(f\&quot;process_action not implemented for {self.__class__.__name__}!\&quot;)\\n+update\\n\\\\ No newline at end of file\\n&apos;,\n&quot;,
    &quot;    },\n&quot;,
    &quot;)\n&quot;,
    &quot;print(res)&quot;
   ]
  },
  {
   &quot;cell_type&quot;: &quot;code&quot;,
   &quot;execution_count&quot;: null,
   &quot;metadata&quot;: {},
   &quot;outputs&quot;: [],
   &quot;source&quot;: [
    &quot;# with model that should validate\n&quot;,
    &quot;from codegen.cli.api.schemas import RunCodemodOutput\n&quot;,
    &quot;\n&quot;,
    &quot;\n&quot;,
    &quot;res = RunCodemodOutput.model_validate(\n&quot;,
    &quot;    {\n&quot;,
    &quot;        \&quot;success\&quot;: \&quot;testz\&quot;,\n&quot;,
    &quot;        \&quot;web_link\&quot;: \&quot;https://chadcode.sh/codemod/13264/code/21435/run/28349/playground/diff\&quot;,\n&quot;,
    &quot;        \&quot;logs\&quot;: \&quot;\&quot;,\n&quot;,
    &quot;        \&quot;observation\&quot;: &apos;diff --git a/codegen-backend/app/utils/slack/interactive/handlers/BaseSlackActionHandler.py b/codegen-backend/app/utils/slack/interactive/handlers/BaseSlackActionHandler.py\\nindex 2dce963196b418caad011d175fb3110e03a8fe73..77c430a5acfb1613ac42c5712cc2859f31d7d773 100644\\n--- a/codegen-backend/app/utils/slack/interactive/handlers/BaseSlackActionHandler.py\\n+++ b/codegen-backend/app/utils/slack/interactive/handlers/BaseSlackActionHandler.py\\n@@ -1,12 +1,1 @@\\n-from sqlalchemy.orm import Session\\n-\\n-\\n-class BaseSlackInteractiveActionHandler:\\n-    db: Session\\n-\\n-    def __init__(self, db: Session) -&gt; None:\\n-        self.db = db\\n-\\n-    # TODO: convert the message information into a shared schema\\n-    def process_action(self, action_payload: str, channel_id: str, thread_ts: str):\\n-        raise NotImplementedError(f\&quot;process_action not implemented for {self.__class__.__name__}!\&quot;)\\n+update\\n\\\\ No newline at end of file\\n&apos;,\n&quot;,
    &quot;    },\n&quot;,
    &quot;)\n&quot;,
    &quot;print(res)&quot;
   ]
  },
  {
   &quot;cell_type&quot;: &quot;code&quot;,
   &quot;execution_count&quot;: null,
   &quot;metadata&quot;: {},
   &quot;outputs&quot;: [],
   &quot;source&quot;: []
  }
 ],
 &quot;metadata&quot;: {
  &quot;kernelspec&quot;: {
   &quot;display_name&quot;: &quot;.venv&quot;,
   &quot;language&quot;: &quot;python&quot;,
   &quot;name&quot;: &quot;python3&quot;
  },
  &quot;language_info&quot;: {
   &quot;codemirror_mode&quot;: {
    &quot;name&quot;: &quot;ipython&quot;,
    &quot;version&quot;: 3
   },
   &quot;file_extension&quot;: &quot;.py&quot;,
   &quot;mimetype&quot;: &quot;text/x-python&quot;,
   &quot;name&quot;: &quot;python&quot;,
   &quot;nbconvert_exporter&quot;: &quot;python&quot;,
   &quot;pygments_lexer&quot;: &quot;ipython3&quot;,
   &quot;version&quot;: &quot;3.13.0&quot;
  }
 },
 &quot;nbformat&quot;: 4,
 &quot;nbformat_minor&quot;: 2
}</file><file path="src/codegen/cli/utils/schema.py">from typing import Any, Self

from pydantic import BaseModel


class SafeBaseModel(BaseModel):
    @classmethod
    def model_validate(
        cls, obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None
    ) -&gt; &quot;Self&quot;:
        try:
            return super().model_validate(obj, strict=strict, from_attributes=from_attributes, context=context, by_alias=by_alias, by_name=by_name)
        except Exception as e:
            print(e)
            # Return a default instance instead of None to maintain compatibility
            return cls()

    def __str__(self) -&gt; str:
        return self.model_dump_json(indent=4)


class CodemodConfig(BaseModel):
    &quot;&quot;&quot;Configuration for a codemod.&quot;&quot;&quot;

    name: str
    codemod_id: int
    description: str | None = None
    created_at: str
    created_by: str</file><file path="src/codegen/cli/utils/simple_selector.py">&quot;&quot;&quot;Simple terminal-based selector utility.&quot;&quot;&quot;

import signal
import sys
import termios
import tty
from typing import Any


def _get_char():
    &quot;&quot;&quot;Get a single character from stdin, handling arrow keys.&quot;&quot;&quot;
    try:
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setcbreak(fd)
            ch = sys.stdin.read(1)

            # Handle escape sequences (arrow keys)
            if ch == &quot;\x1b&quot;:  # ESC
                ch2 = sys.stdin.read(1)
                if ch2 == &quot;[&quot;:
                    ch3 = sys.stdin.read(1)
                    return f&quot;\x1b[{ch3}&quot;
                else:
                    return ch + ch2
            return ch
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    except (ImportError, OSError, termios.error):
        # Fallback for systems where tty manipulation doesn&apos;t work
        print(&quot;\nUse: â†‘(w)/â†“(s) navigate, Enter select, q quit&quot;)
        try:
            return input(&quot;&gt; &quot;).strip()[:1].lower() or &quot;\n&quot;
        except KeyboardInterrupt:
            return &quot;q&quot;


def simple_select(title: str, options: list[dict[str, Any]], display_key: str = &quot;name&quot;, show_help: bool = True, allow_cancel: bool = True) -&gt; dict[str, Any] | None:
    &quot;&quot;&quot;Show a simple up/down selector for choosing from options.

    Args:
        title: Title to display above the options
        options: List of option dictionaries
        display_key: Key to use for displaying option text
        show_help: Whether to show navigation help text
        allow_cancel: Whether to allow canceling with Esc/q

    Returns:
        Selected option dictionary or None if canceled
    &quot;&quot;&quot;
    if not options:
        print(&quot;No options available.&quot;)
        return None

    if len(options) == 1:
        # Only one option, select it automatically
        return options[0]

    selected = 0
    running = True

    # Set up signal handler for Ctrl+C
    def signal_handler(signum, frame):
        nonlocal running
        running = False
        print(&quot;\n&quot;)
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)

    try:
        print(f&quot;\n{title}&quot;)
        print()

        # Initial display
        for i, option in enumerate(options):
            display_text = str(option.get(display_key, f&quot;Option {i + 1}&quot;))
            if i == selected:
                print(f&quot;  \033[37mâ†’ {display_text}\033[0m&quot;)  # White for selected
            else:
                print(f&quot;  \033[90m  {display_text}\033[0m&quot;)

        if show_help:
            print()
            help_text = &quot;[Enter] select â€¢ [â†‘â†“] navigate&quot;
            if allow_cancel:
                help_text += &quot; â€¢ [q/Esc] cancel&quot;
            print(f&quot;\033[90m{help_text}\033[0m&quot;)

        while running:
            # Get input
            key = _get_char()

            if key == &quot;\x1b[A&quot; or key.lower() == &quot;w&quot;:  # Up arrow or W
                selected = max(0, selected - 1)
                # Redraw options only
                lines_to_move = len(options) + (2 if show_help else 0)
                print(f&quot;\033[{lines_to_move}A&quot;, end=&quot;&quot;)  # Move cursor up to start of options
                for i, option in enumerate(options):
                    display_text = str(option.get(display_key, f&quot;Option {i + 1}&quot;))
                    if i == selected:
                        print(f&quot;  \033[37mâ†’ {display_text}\033[0m\033[K&quot;)  # White for selected, clear to end of line
                    else:
                        print(f&quot;  \033[90m  {display_text}\033[0m\033[K&quot;)  # Clear to end of line
                if show_help:
                    print(&quot;\033[K&quot;)  # Clear help line
                    print(f&quot;\033[90m{help_text}\033[0m\033[K&quot;)  # Redraw help

            elif key == &quot;\x1b[B&quot; or key.lower() == &quot;s&quot;:  # Down arrow or S
                selected = min(len(options) - 1, selected + 1)
                # Redraw options only
                lines_to_move = len(options) + (2 if show_help else 0)
                print(f&quot;\033[{lines_to_move}A&quot;, end=&quot;&quot;)  # Move cursor up to start of options
                for i, option in enumerate(options):
                    display_text = str(option.get(display_key, f&quot;Option {i + 1}&quot;))
                    if i == selected:
                        print(f&quot;  \033[37mâ†’ {display_text}\033[0m\033[K&quot;)  # White for selected, clear to end of line
                    else:
                        print(f&quot;  \033[90m  {display_text}\033[0m\033[K&quot;)  # Clear to end of line
                if show_help:
                    print(&quot;\033[K&quot;)  # Clear help line
                    print(f&quot;\033[90m{help_text}\033[0m\033[K&quot;)  # Redraw help

            elif key == &quot;\r&quot; or key == &quot;\n&quot;:  # Enter - select option
                return options[selected]
            elif allow_cancel and (key.lower() == &quot;q&quot; or key == &quot;\x1b&quot;):  # q or Esc - cancel
                return None
            elif key == &quot;\x03&quot;:  # Ctrl+C
                running = False
                break

    except KeyboardInterrupt:
        return None
    finally:
        # Restore signal handler
        signal.signal(signal.SIGINT, signal.SIG_DFL)

    return None


def simple_org_selector(organizations: list[dict], current_org_id: int | None = None, title: str = &quot;Select Organization&quot;) -&gt; dict | None:
    &quot;&quot;&quot;Show a simple organization selector.

    Args:
        organizations: List of organization dictionaries with &apos;id&apos; and &apos;name&apos;
        current_org_id: Currently selected organization ID (for display)
        title: Title to show above selector

    Returns:
        Selected organization dictionary or None if canceled
    &quot;&quot;&quot;
    if not organizations:
        print(&quot;No organizations available.&quot;)
        return None

    # Format organizations for display with current indicator
    display_orgs = []
    for org in organizations:
        org_id = org.get(&quot;id&quot;)
        org_name = org.get(&quot;name&quot;, f&quot;Organization {org_id}&quot;)

        # Add current indicator
        if org_id == current_org_id:
            display_name = f&quot;{org_name} (current)&quot;
        else:
            display_name = org_name

        display_orgs.append(
            {
                **org,  # Keep original org data
                &quot;display_name&quot;: display_name,
            }
        )

    return simple_select(title=title, options=display_orgs, display_key=&quot;display_name&quot;, show_help=True, allow_cancel=True)</file><file path="src/codegen/cli/utils/url.py">from enum import Enum

from codegen.cli.env.enums import Environment
from codegen.cli.env.global_env import global_env


class DomainRegistry(Enum):
    STAGING = &quot;chadcode.sh&quot;
    PRODUCTION = &quot;codegen.com&quot;
    LOCAL = &quot;localhost:3000&quot;


def get_domain() -&gt; str:
    &quot;&quot;&quot;Get the appropriate domain based on the current environment.&quot;&quot;&quot;
    if global_env.ENV == Environment.PRODUCTION:
        return DomainRegistry.PRODUCTION.value
    elif global_env.ENV == Environment.STAGING:
        return DomainRegistry.STAGING.value
    else:
        return DomainRegistry.LOCAL.value


def generate_webapp_url(path: str = &quot;&quot;, params: dict | None = None, protocol: str = &quot;https&quot;) -&gt; str:
    &quot;&quot;&quot;Generate a complete URL for the web application.

    Args:
        path: The path component of the URL (without leading slash)
        params: Optional query parameters as a dictionary
        protocol: URL protocol (defaults to https, will be http for localhost)

    Returns:
        Complete URL string

    Example:
        generate_webapp_url(&quot;projects/123&quot;, {&quot;tab&quot;: &quot;settings&quot;})
        # In staging: https://chadcode.sh/projects/123?tab=settings

    &quot;&quot;&quot;
    domain = get_domain()
    # Use http for localhost
    if domain == DomainRegistry.LOCAL.value:
        protocol = &quot;http&quot;

    # Build base URL
    base_url = f&quot;{protocol}://{domain}&quot;

    # Add path if provided
    if path:
        path = path.lstrip(&quot;/&quot;)  # Remove leading slash if present
        base_url = f&quot;{base_url}/{path}&quot;

    # Add query parameters if provided
    if params:
        query_string = &quot;&amp;&quot;.join(f&quot;{k}={v}&quot; for k, v in params.items())
        base_url = f&quot;{base_url}?{query_string}&quot;

    return base_url</file><file path="src/codegen/cli/_env.py">ENV = &quot;&quot;</file><file path="src/codegen/cli/cli.py">import atexit

import typer
from rich.traceback import install

from codegen import __version__
from codegen.cli.commands.agent.main import agent
from codegen.cli.commands.agents.main import agents_app
from codegen.cli.commands.claude.main import claude
from codegen.cli.commands.config.main import config_command
from codegen.cli.commands.init.main import init
from codegen.cli.commands.integrations.main import integrations_app
from codegen.cli.commands.login.main import login
from codegen.cli.commands.logout.main import logout
from codegen.cli.commands.org.main import org
from codegen.cli.commands.profile.main import profile_app
from codegen.cli.commands.repo.main import repo
from codegen.cli.commands.tui.main import tui
from codegen.cli.commands.update.main import update
from codegen.shared.logging.get_logger import get_logger

# Initialize logger for CLI command tracking
logger = get_logger(__name__)

# Set up global exception logging early
try:
    from codegen.cli.telemetry.exception_logger import setup_global_exception_logging

    setup_global_exception_logging()
except ImportError:
    # Exception logging dependencies not available - continue without it
    pass


install(show_locals=True)

# Register telemetry shutdown on exit
try:
    from codegen.cli.telemetry.exception_logger import teardown_global_exception_logging
    from codegen.cli.telemetry.otel_setup import shutdown_otel_logging

    atexit.register(shutdown_otel_logging)
    atexit.register(teardown_global_exception_logging)
except ImportError:
    # OTel dependencies not available
    pass


def version_callback(value: bool):
    &quot;&quot;&quot;Print version and exit.&quot;&quot;&quot;
    if value:
        logger.info(&quot;Version command invoked&quot;, extra={&quot;operation&quot;: &quot;cli.version&quot;, &quot;version&quot;: __version__})
        print(__version__)
        raise typer.Exit()


# Create the main Typer app
main = typer.Typer(name=&quot;codegen&quot;, help=&quot;Codegen - the Operating System for Code Agents.&quot;, rich_markup_mode=&quot;rich&quot;)

# Check for updates on startup (non-blocking)
try:
    # Only check when no arguments are passed (just &quot;codegen&quot; to launch TUI)
    import sys

    from codegen.cli.commands.update import check_for_updates_on_startup

    if len(sys.argv) == 1:
        check_for_updates_on_startup()
except ImportError:
    pass  # Update check dependencies not available

# Add individual commands to the main app (logging now handled within each command)
main.command(&quot;agent&quot;, help=&quot;Create a new agent run with a prompt.&quot;)(agent)
main.command(&quot;claude&quot;, help=&quot;Run Claude Code with OpenTelemetry monitoring and logging.&quot;)(claude)
main.command(&quot;init&quot;, help=&quot;Initialize or update the Codegen folder.&quot;)(init)
main.command(&quot;login&quot;, help=&quot;Store authentication token.&quot;)(login)
main.command(&quot;logout&quot;, help=&quot;Clear stored authentication token.&quot;)(logout)
main.command(&quot;org&quot;, help=&quot;Manage and switch between organizations.&quot;)(org)
main.command(&quot;repo&quot;, help=&quot;Manage repository configuration and environment variables.&quot;)(repo)
main.command(&quot;tui&quot;, help=&quot;Launch the interactive TUI interface.&quot;)(tui)
main.command(&quot;update&quot;, help=&quot;Update Codegen to the latest or specified version&quot;)(update)

# Add Typer apps as sub-applications (these will handle their own sub-command logging)
main.add_typer(agents_app, name=&quot;agents&quot;)
main.add_typer(config_command, name=&quot;config&quot;)
main.add_typer(integrations_app, name=&quot;integrations&quot;)
main.add_typer(profile_app, name=&quot;profile&quot;)


@main.callback(invoke_without_command=True)
def main_callback(ctx: typer.Context, version: bool = typer.Option(False, &quot;--version&quot;, callback=version_callback, is_eager=True, help=&quot;Show version and exit&quot;)):
    &quot;&quot;&quot;Codegen - the Operating System for Code Agents&quot;&quot;&quot;
    if ctx.invoked_subcommand is None:
        # No subcommand provided, launch TUI
        logger.info(&quot;CLI launched without subcommand - starting TUI&quot;, extra={&quot;operation&quot;: &quot;cli.main&quot;, &quot;action&quot;: &quot;default_tui_launch&quot;, &quot;command&quot;: &quot;codegen&quot;})
        from codegen.cli.tui.app import run_tui

        run_tui()
    else:
        # Log when a subcommand is being invoked
        logger.debug(&quot;CLI main callback with subcommand&quot;, extra={&quot;operation&quot;: &quot;cli.main&quot;, &quot;subcommand&quot;: ctx.invoked_subcommand, &quot;command&quot;: f&quot;codegen {ctx.invoked_subcommand}&quot;})


if __name__ == &quot;__main__&quot;:
    main()</file><file path="src/codegen/cli/errors.py"># TODO: refactor this file out
import functools

import rich
import typer
from rich.panel import Panel


class AuthError(Exception):
    &quot;&quot;&quot;Error raised if authed user cannot be established.&quot;&quot;&quot;

    pass


class InvalidTokenError(AuthError):
    &quot;&quot;&quot;Error raised if the token is invalid.&quot;&quot;&quot;

    pass


class NoTokenError(AuthError):
    &quot;&quot;&quot;Error raised if no token is provided.&quot;&quot;&quot;

    pass


class CodegenError(Exception):
    &quot;&quot;&quot;Base class for Codegen-specific errors.&quot;&quot;&quot;

    pass


class ServerError(CodegenError):
    &quot;&quot;&quot;Error raised when the server encounters an error.&quot;&quot;&quot;

    pass


def format_error_message(error):
    &quot;&quot;&quot;Format error message based on error type.&quot;&quot;&quot;
    if isinstance(error, AuthError):
        return &quot;[red]Authentication Error:[/red] Please run &apos;codegen login&apos; first.&quot;
    elif isinstance(error, ServerError):
        return &quot;[red]Server Error:[/red] The server encountered an error. Please try again later.&quot;
    else:
        return f&quot;[red]Error:[/red] {error!s}&quot;


def handle_auth_error(f):
    &quot;&quot;&quot;Decorator to handle authentication errors gracefully.&quot;&quot;&quot;

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except AuthError:
            rich.print(Panel(&quot;[red]Authentication Error:[/red] Please run &apos;codegen login&apos; first.&quot;, title=&quot;Codegen Error&quot;, border_style=&quot;red&quot;))
            raise typer.Abort()

    return wrapper</file><file path="src/codegen/cli/README.md"># Codegen CLI

A codegen module that handles all `codegen` CLI commands.

### Dependencies

- [codegen.sdk](https://github.com/codegen-sh/codegen-sdk/tree/develop/src/codegen/sdk)
- [codegen.shared](https://github.com/codegen-sh/codegen-sdk/tree/develop/src/codegen/shared)

## Best Practices

- Each folder in `cli` should correspond to a command group. The name of the folder should be the name of the command group. Ex: `task` for codegen task commands.
- The command group folder should have a file called `commands.py` where the CLI group (i.e. function decorated with `@click.group()`) and CLI commands are defined (i.e. functions decorated with ex: `@task.command()`) and if necessary a folder called `utils` (or a single `utils.py`) that holds any additional files with helpers/utilities that are specific to the command group.
- Store utils specific to a CLI command group within its folder.
- Store utils that can be shared across command groups in an appropriate file in cli/utils. If none exists, create a new appropriately named one!</file><file path="src/codegen/configs/models/base_config.py">from abc import ABC
from pathlib import Path

from dotenv import load_dotenv, set_key
from pydantic_settings import BaseSettings, SettingsConfigDict

from codegen.configs.constants import ENV_FILENAME, GLOBAL_ENV_FILE
from codegen.shared.path import get_git_root_path


class BaseConfig(BaseSettings, ABC):
    &quot;&quot;&quot;Base class for all config classes.
    Handles loading and saving of configuration values from environment files.
    Supports both global and local config files.
    &quot;&quot;&quot;

    model_config = SettingsConfigDict(extra=&quot;ignore&quot;, case_sensitive=False)

    def __init__(self, prefix: str, env_filepath: Path | None = None, *args, **kwargs) -&gt; None:
        if env_filepath is None:
            root_path = get_git_root_path()
            if root_path is not None:
                env_filepath = root_path / ENV_FILENAME

        # Only include env files that exist
        if GLOBAL_ENV_FILE.exists():
            load_dotenv(GLOBAL_ENV_FILE, override=True)

        if env_filepath and env_filepath.exists() and env_filepath != GLOBAL_ENV_FILE:
            load_dotenv(env_filepath, override=True)

        self.model_config[&quot;env_prefix&quot;] = f&quot;{prefix.upper()}_&quot; if len(prefix) &gt; 0 else &quot;&quot;
        super().__init__(*args, **kwargs)

    @property
    def env_prefix(self) -&gt; str:
        return self.model_config[&quot;env_prefix&quot;]

    def set(self, env_filepath: Path, key: str, value: str) -&gt; None:
        &quot;&quot;&quot;Update configuration values&quot;&quot;&quot;
        if key.lower() in self.model_fields:
            setattr(self, key.lower(), value)
            set_key(env_filepath, f&quot;{self.model_config[&apos;env_prefix&apos;]}{key.upper()}&quot;, str(value))

    def write_to_file(self, env_filepath: Path) -&gt; None:
        &quot;&quot;&quot;Dump environment variables to a file&quot;&quot;&quot;
        env_filepath.parent.mkdir(parents=True, exist_ok=True)

        if not env_filepath.exists():
            with open(env_filepath, &quot;w&quot;) as f:
                f.write(&quot;&quot;)

        # Update with new values
        for key, value in self.model_dump().items():
            if value is None:
                continue
            set_key(env_filepath, f&quot;{self.model_config[&apos;env_prefix&apos;]}{key.upper()}&quot;, str(value))</file><file path="src/codegen/configs/models/codebase.py">from enum import IntEnum, auto

from pydantic import Field

from codegen.configs.models.base_config import BaseConfig


class PinkMode(IntEnum):
    # Use the python SDK for all files
    OFF = auto()
    # Use the Rust SDK for all files. Make sure to install the pink extra
    ALL_FILES = auto()
    # Use the Rust SDK for files the python SDK can&apos;t parse (non-source files). Make sure to install the pink extra
    NON_SOURCE_FILES = auto()


class CodebaseConfig(BaseConfig):
    def __init__(self, prefix: str = &quot;CODEBASE&quot;, *args, **kwargs) -&gt; None:
        super().__init__(prefix=prefix, *args, **kwargs)

    debug: bool = False
    verify_graph: bool = False
    track_graph: bool = False
    method_usages: bool = True
    sync_enabled: bool = False
    full_range_index: bool = False
    ignore_process_errors: bool = True
    disable_graph: bool = False
    disable_file_parse: bool = False
    exp_lazy_graph: bool = False
    generics: bool = True
    import_resolution_paths: list[str] = Field(default_factory=lambda: [])
    import_resolution_overrides: dict[str, str] = Field(default_factory=lambda: {})
    py_resolve_syspath: bool = False
    allow_external: bool = False
    ts_dependency_manager: bool = False
    ts_language_engine: bool = False
    v8_ts_engine: bool = False
    unpacking_assignment_partial_removal: bool = True
    use_pink: PinkMode = PinkMode.OFF


DefaultCodebaseConfig = CodebaseConfig()</file><file path="src/codegen/configs/models/repository.py">import os

from codegen.configs.models.base_config import BaseConfig


class RepositoryConfig(BaseConfig):
    &quot;&quot;&quot;Configuration for the repository context to run codegen.
    To automatically populate this config, call `codegen init` from within a git repository.
    &quot;&quot;&quot;

    path: str | None = None
    owner: str | None = None
    language: str | None = None
    user_name: str | None = None
    user_email: str | None = None

    def __init__(self, prefix: str = &quot;REPOSITORY&quot;, *args, **kwargs) -&gt; None:
        super().__init__(prefix=prefix, *args, **kwargs)

    def _initialize(
        self,
    ) -&gt; None:
        &quot;&quot;&quot;Initialize the repository config&quot;&quot;&quot;
        if self.path is None:
            self.path = os.getcwd()

    @property
    def base_dir(self) -&gt; str:
        return os.path.dirname(self.path)

    @property
    def name(self) -&gt; str:
        return os.path.basename(self.path)

    @property
    def full_name(self) -&gt; str | None:
        if self.owner is not None:
            return f&quot;{self.owner}/{self.name}&quot;
        return None</file><file path="src/codegen/configs/models/secrets.py">from codegen.configs.models.base_config import BaseConfig


class SecretsConfig(BaseConfig):
    &quot;&quot;&quot;Configuration for various API secrets and tokens.

    Loads from environment variables.
    Falls back to .env file for missing values.
    &quot;&quot;&quot;

    def __init__(self, prefix: str = &quot;&quot;, *args, **kwargs) -&gt; None:
        super().__init__(prefix=prefix, *args, **kwargs)

    github_token: str | None = None
    openai_api_key: str | None = None
    linear_api_key: str | None = None</file><file path="src/codegen/configs/models/telemetry.py">&quot;&quot;&quot;Telemetry configuration for CLI usage analytics and debugging.&quot;&quot;&quot;

from codegen.configs.models.base_config import BaseConfig


class TelemetryConfig(BaseConfig):
    &quot;&quot;&quot;Configuration for CLI telemetry.

    Telemetry is opt-in by default and helps improve the CLI experience
    by collecting usage analytics, performance metrics, and error diagnostics.
    &quot;&quot;&quot;

    # Whether telemetry is enabled (opt-in by default)
    enabled: bool = False

    # Whether user has been prompted for telemetry consent
    consent_prompted: bool = False

    # Anonymous user ID for telemetry correlation
    anonymous_id: str | None = None

    # Telemetry endpoint (defaults to production collector)
    endpoint: str | None = None

    # Debug mode for verbose telemetry logging
    debug: bool = False

    def __init__(self, env_filepath=None, **kwargs):
        super().__init__(prefix=&quot;TELEMETRY&quot;, env_filepath=env_filepath, **kwargs)</file><file path="src/codegen/configs/models/utils.py">from pydantic_settings import SettingsConfigDict


def get_setting_config(prefix: str) -&gt; SettingsConfigDict:
    return SettingsConfigDict(
        env_prefix=f&quot;{prefix}_&quot;,
        case_sensitive=False,
        extra=&quot;ignore&quot;,
    )</file><file path="src/codegen/configs/constants.py">from pathlib import Path

CODEGEN_DIR_NAME = &quot;.codegen&quot;
ENV_FILENAME = &quot;.env&quot;

# ====[ Codegen internal config ]====
CODEGEN_REPO_ROOT = Path(__file__).parent.parent.parent.parent.parent
CODEGEN_DIR_PATH = CODEGEN_REPO_ROOT / CODEGEN_DIR_NAME

# ====[ User session config ]====
PROMPTS_DIR = Path(CODEGEN_DIR_NAME) / &quot;prompts&quot;
DOCS_DIR = Path(CODEGEN_DIR_NAME) / &quot;docs&quot;
EXAMPLES_DIR = Path(CODEGEN_DIR_NAME) / &quot;examples&quot;


# ====[ User global config paths ]====
GLOBAL_CONFIG_DIR = Path(&quot;~/.config/codegen-sh&quot;).expanduser()
AUTH_FILE = GLOBAL_CONFIG_DIR / &quot;auth.json&quot;
SESSION_FILE = GLOBAL_CONFIG_DIR / &quot;session.json&quot;
GLOBAL_ENV_FILE = GLOBAL_CONFIG_DIR / ENV_FILENAME</file><file path="src/codegen/configs/session_manager.py">&quot;&quot;&quot;Global config to manage different codegen sessions, as well as user auth.&quot;&quot;&quot;

import json
from pathlib import Path

from codegen.configs.constants import SESSION_FILE


class SessionManager:
    active_session_path: str | None
    sessions: list[str]

    def __init__(self, **kwargs) -&gt; None:
        if SESSION_FILE.exists():
            with open(SESSION_FILE) as f:
                json_config = json.load(f)
                self.sessions = json_config[&quot;sessions&quot;]
                self.active_session_path = json_config[&quot;active_session_path&quot;]
        else:
            self.sessions = []
            self.active_session_path = None
        super().__init__(**kwargs)

    def get_session(self, session_root_path: Path) -&gt; str | None:
        return next((s for s in self.sessions if s == str(session_root_path)), None)

    def get_active_session(self) -&gt; Path | None:
        if not self.active_session_path:
            return None

        return Path(self.active_session_path)

    def set_active_session(self, session_root_path: Path) -&gt; None:
        if not session_root_path.exists():
            msg = f&quot;Session path does not exist: {session_root_path}&quot;
            raise ValueError(msg)

        self.active_session_path = str(session_root_path)
        if self.active_session_path not in self.sessions:
            self.sessions.append(self.active_session_path)

        self.save()

    def save(self) -&gt; None:
        if not SESSION_FILE.parent.exists():
            SESSION_FILE.parent.mkdir(parents=True, exist_ok=True)

        with open(SESSION_FILE, &quot;w&quot;) as f:
            json.dump(self.__dict__(), f)

    def __dict__(self) -&gt; dict:
        return {
            &quot;active_session_path&quot;: self.active_session_path,
            &quot;sessions&quot;: self.sessions,
        }

    def __str__(self) -&gt; str:
        active = self.active_session_path or &quot;None&quot;
        sessions_str = &quot;\n    &quot;.join(self.sessions) if self.sessions else &quot;None&quot;

        return f&quot;GlobalConfig:\n  Active Session: {active}\n  Sessions:\n    {sessions_str}\n  Global Session:\n    {self.session_config}&quot;


session_manager = SessionManager()</file><file path="src/codegen/configs/user_config.py">import json
from pathlib import Path

from pydantic import Field

from codegen.configs.models.codebase import CodebaseConfig
from codegen.configs.models.repository import RepositoryConfig
from codegen.configs.models.secrets import SecretsConfig


class UserConfig:
    env_filepath: Path
    repository: RepositoryConfig = Field(default_factory=RepositoryConfig)
    codebase: CodebaseConfig = Field(default_factory=CodebaseConfig)
    secrets: SecretsConfig = Field(default_factory=SecretsConfig)

    def __init__(self, env_filepath: Path) -&gt; None:
        self.env_filepath = env_filepath
        self.secrets = SecretsConfig(env_filepath=env_filepath)
        self.repository = RepositoryConfig(env_filepath=env_filepath)
        self.codebase = CodebaseConfig(env_filepath=env_filepath)

    def save(self) -&gt; None:
        &quot;&quot;&quot;Save configuration to the config file.&quot;&quot;&quot;
        self.env_filepath.parent.mkdir(parents=True, exist_ok=True)
        self.repository.write_to_file(self.env_filepath)
        self.secrets.write_to_file(self.env_filepath)
        self.codebase.write_to_file(self.env_filepath)

    def to_dict(self) -&gt; dict:
        &quot;&quot;&quot;Return a dictionary representation of the config.&quot;&quot;&quot;
        config_dict = {}
        # Add repository configs with &apos;repository_&apos; prefix
        for key, value in self.repository.model_dump().items():
            config_dict[f&quot;{self.repository.env_prefix}{key}&quot;.upper()] = value

        # Add feature flags configs with &apos;feature_flags_&apos; prefix
        for key, value in self.codebase.model_dump().items():
            config_dict[f&quot;{self.codebase.env_prefix}{key}&quot;.upper()] = value

        # Add secrets configs
        for key, value in self.secrets.model_dump().items():
            config_dict[f&quot;{self.secrets.env_prefix}{key}&quot;.upper()] = value
        return config_dict

    def has_key(self, full_key: str) -&gt; bool:
        &quot;&quot;&quot;Check if a configuration key exists&quot;&quot;&quot;
        return full_key.upper() in self.to_dict()

    def get(self, full_key: str) -&gt; str | None:
        &quot;&quot;&quot;Get a configuration value&quot;&quot;&quot;
        return self.to_dict().get(full_key.upper(), None)

    def set(self, full_key: str, value: str) -&gt; None:
        &quot;&quot;&quot;Update a configuration value and save it to the .env file.&quot;&quot;&quot;
        key_segments = full_key.split(&quot;_&quot;)
        prefix = key_segments[0].upper()
        key = &quot;_&quot;.join(key_segments[1:])
        match f&quot;{prefix}_&quot;:
            case self.repository.env_prefix:
                self.repository.set(self.env_filepath, key, value)
            case self.codebase.env_prefix:
                self.codebase.set(self.env_filepath, key, value)
            case _:
                self.secrets.set(self.env_filepath, full_key, value)

    def __str__(self) -&gt; str:
        &quot;&quot;&quot;Return a pretty-printed string representation of the config.&quot;&quot;&quot;
        return json.dumps(self.to_dict(), indent=2)</file><file path="src/codegen/git/clients/git_repo_client.py">import time
from datetime import UTC, datetime

from github.Branch import Branch
from github.CheckRun import CheckRun
from github.CheckSuite import CheckSuite
from github.Commit import Commit
from github.GithubException import GithubException, UnknownObjectException
from github.GithubObject import NotSet, Opt
from github.Issue import Issue
from github.IssueComment import IssueComment
from github.Label import Label
from github.PullRequest import PullRequest
from github.Repository import Repository
from github.Tag import Tag
from github.Workflow import Workflow

from codegen.configs.models.secrets import SecretsConfig
from codegen.git.clients.github_client import GithubClient
from codegen.git.schemas.repo_config import RepoConfig
from codegen.git.utils.format import format_comparison
from codegen.shared.logging.get_logger import get_logger

logger = get_logger(__name__)


class GitRepoClient:
    &quot;&quot;&quot;Wrapper around PyGithub&apos;s Remote Repository.&quot;&quot;&quot;

    repo_config: RepoConfig
    gh_client: GithubClient
    _repo: Repository

    def __init__(self, repo_config: RepoConfig, access_token: str | None = None) -&gt; None:
        self.repo_config = repo_config
        self.gh_client = self._create_github_client(token=access_token or SecretsConfig().github_token)
        self._repo = self._create_client()

    def _create_github_client(self, token: str) -&gt; GithubClient:
        return GithubClient(token=token)

    def _create_client(self) -&gt; Repository:
        client = self.gh_client.get_repo_by_full_name(self.repo_config.full_name)
        if not client:
            msg = f&quot;Repo {self.repo_config.full_name} not found!&quot;
            raise ValueError(msg)
        return client

    @property
    def repo(self) -&gt; Repository:
        return self._repo

    ####################################################################################################################
    # PROPERTIES
    ####################################################################################################################

    @property
    def default_branch(self) -&gt; str:
        return self.repo.default_branch

    ####################################################################################################################
    # CONTENTS
    ####################################################################################################################

    def get_contents(self, file_path: str, ref: str | None = None) -&gt; str | None:
        &quot;&quot;&quot;Returns string file content on a given ref&quot;&quot;&quot;
        if not ref:
            ref = self.default_branch
        try:
            file = self.repo.get_contents(file_path, ref=ref)
            file_contents = file.decoded_content.decode(&quot;utf-8&quot;)  # type: ignore[union-attr]
            return file_contents
        except UnknownObjectException:
            logger.info(f&quot;File: {file_path} not found in ref: {ref}&quot;)
            return None
        except GithubException as e:
            if e.status == 404:
                logger.info(f&quot;File: {file_path} not found in ref: {ref}&quot;)
                return None
            raise

    def get_last_modified_date_of_path(self, path: str) -&gt; datetime:
        &quot;&quot;&quot;Uses the GitHub API to return the last modified date of a given directory or file.

        Args:
        ----
            path (str): The path to the directory within the repository.

        Returns:
        -------
            str: The last modified date of the directory in ISO format (YYYY-MM-DDTHH:MM:SSZ).

        &quot;&quot;&quot;
        commits = self.repo.get_commits(path=path)
        if commits.totalCount &gt; 0:
            # Get the date of the latest commit
            last_modified_date = commits[0].commit.committer.date
            return last_modified_date
        else:
            print(&quot;Directory has not been modified or does not exist.&quot;)
            return datetime.min.replace(tzinfo=UTC)

    ####################################################################################################################
    # COMMENTS
    ####################################################################################################################

    def create_review_comment(
        self,
        pull: PullRequest,
        body: str,
        commit: Commit,
        path: str,
        line: Opt[int] = NotSet,
        side: Opt[str] = NotSet,
        start_line: Opt[int] = NotSet,
    ) -&gt; None:
        # TODO: add protections (ex: can write to PR)
        writeable_pr = self.repo.get_pull(pull.number)
        writeable_pr.create_review_comment(
            body=body,
            commit=commit,
            path=path,
            line=line,
            side=side,
            start_line=start_line,
        )

    def create_issue_comment(
        self,
        pull: PullRequest,
        body: str,
    ) -&gt; IssueComment:
        # TODO: add protections (ex: can write to PR)
        writeable_pr = self.repo.get_pull(pull.number)
        return writeable_pr.create_issue_comment(body=body)

    ####################################################################################################################
    # PULL REQUESTS
    ####################################################################################################################

    def get_pull_by_branch_and_state(
        self,
        head_branch_name: str | None = None,
        base_branch_name: str | None = None,
        state: str = &quot;all&quot;,
    ) -&gt; PullRequest | None:
        &quot;&quot;&quot;Returns the first PR for the head/base/state filter&quot;&quot;&quot;
        if not head_branch_name:
            logger.info(&quot;No head branch name provided. Unable to find PR.&quot;)
            return None
        if not base_branch_name:
            base_branch_name = self.default_branch

        head_branch_name = f&quot;{self.repo_config.organization_name}:{head_branch_name}&quot;

        # retrieve all pulls ordered by created descending
        prs = self.repo.get_pulls(base=base_branch_name, head=head_branch_name, state=state, sort=&quot;created&quot;, direction=&quot;desc&quot;)
        if prs.totalCount &gt; 0:
            return prs[0]
        else:
            return None

    def get_pull_safe(self, number: int) -&gt; PullRequest | None:
        &quot;&quot;&quot;Returns a PR by its number
        TODO: catching UnknownObjectException is common enough to create a decorator
        &quot;&quot;&quot;
        try:
            pr = self.repo.get_pull(number)
            return pr
        except UnknownObjectException as e:
            return None
        except Exception as e:
            logger.warning(f&quot;Error getting PR by number: {number}\n\t{e}&quot;)
            return None

    def get_issue_safe(self, number: int) -&gt; Issue | None:
        &quot;&quot;&quot;Returns an issue by its number
        TODO: catching UnknownObjectException is common enough to create a decorator
        &quot;&quot;&quot;
        try:
            pr = self.repo.get_issue(number)
            return pr
        except UnknownObjectException as e:
            return None
        except Exception as e:
            logger.warning(f&quot;Error getting issue by number: {number}\n\t{e}&quot;)
            return None

    def get_or_create_pull(
        self,
        head_branch_name: str,
        base_branch_name: str | None = None,  # type: ignore[assignment]
        title: str | None = None,  # type: ignore[assignment]
        body: str | None = None,  # type: ignore[assignment]
    ) -&gt; PullRequest | None:
        pull = self.get_pull_by_branch_and_state(head_branch_name=head_branch_name, base_branch_name=base_branch_name)
        if pull:
            logger.info(f&quot;Pull request for head branch: {head_branch_name} already exists. Skip creation.&quot;)
        else:
            logger.info(f&quot;Creating pull request base: {base_branch_name} head: {head_branch_name} ...&quot;)
            pull = self.create_pull(head_branch_name=head_branch_name, base_branch_name=base_branch_name, title=title, body=body)
        return pull

    def create_pull(
        self,
        head_branch_name: str,
        base_branch_name: str | None = None,
        title: str | None = None,
        body: str | None = None,
        draft: bool = True,
    ) -&gt; PullRequest | None:
        if base_branch_name is None:
            base_branch_name = self.default_branch

        # draft PRs are not supported on all private repos
        # TODO: check repo plan features instead of this heuristic
        if self.repo.visibility == &quot;private&quot;:
            logger.info(f&quot;Repo {self.repo.name} is private. Disabling draft PRs.&quot;)
            draft = False

        try:
            pr = self.repo.create_pull(title=title or f&quot;Draft PR for {head_branch_name}&quot;, body=body or &quot;&quot;, head=head_branch_name, base=base_branch_name, draft=draft)
            logger.info(f&quot;Created pull request for head branch: {head_branch_name} at {pr.html_url}&quot;)
            # NOTE: return a read-only copy to prevent people from editing it
            return self.repo.get_pull(pr.number)
        except GithubException as ge:
            logger.warning(f&quot;Failed to create PR got GithubException\n\t{ge}&quot;)
        except Exception as e:
            logger.warning(f&quot;Failed to create PR:\n\t{e}&quot;)

        return None

    def squash_and_merge(self, base_branch_name: str, head_branch_name: str, squash_commit_msg: str | None = None, squash_commit_title: str | None = None) -&gt; None:
        # =====[ Step 1: Make a squash PR ]=====
        # We will do a squash merge via a pull request, since regular
        # merges in PyGithub do not support `squash`
        squash_pr = self.create_pull(
            base_branch_name=base_branch_name,
            head_branch_name=head_branch_name,
            draft=False,
            title=squash_commit_title,
            body=&quot;&quot;,
        )
        # TODO: handle PR not mergeable due to merge conflicts
        merge = squash_pr.merge(commit_message=squash_commit_msg, commit_title=squash_commit_title, merge_method=&quot;squash&quot;)  # type: ignore[arg-type]

    def edit_pull(self, pull: PullRequest, title: Opt[str] = NotSet, body: Opt[str] = NotSet, state: Opt[str] = NotSet) -&gt; None:
        writable_pr = self.repo.get_pull(pull.number)
        writable_pr.edit(title=title, body=body, state=state)

    def add_label_to_pull(self, pull: PullRequest, label: Label) -&gt; None:
        writeable_pr = self.repo.get_pull(pull.number)
        writeable_pr.add_to_labels(label)

    def remove_label_from_pull(self, pull: PullRequest, label: Label) -&gt; None:
        writeable_pr = self.repo.get_pull(pull.number)
        writeable_pr.remove_from_labels(label)

    ####################################################################################################################
    # BRANCHES
    ####################################################################################################################

    def get_or_create_branch(self, new_branch_name: str, base_branch_name: str | None = None) -&gt; Branch | None:
        try:
            existing_branch = self.get_branch_safe(new_branch_name)
            if existing_branch:
                return existing_branch
            new_branch = self.create_branch(new_branch_name, base_branch_name=base_branch_name)
            return new_branch
        except Exception as e:
            logger.exception(f&quot;Unexpected error creating branch: {new_branch_name}\n\t{e}&quot;)
            return None

    def get_branch_safe(self, branch_name: str, attempts: int = 1, wait_seconds: int = 1) -&gt; Branch | None:
        for i in range(attempts):
            try:
                return self.repo.get_branch(branch_name)
            except GithubException as e:
                if e.status == 404 and i &lt; attempts - 1:
                    time.sleep(wait_seconds)
            except Exception as e:
                logger.warning(f&quot;Unexpected error getting branch: {branch_name}\n\t{e}&quot;)
        return None

    def create_branch(self, new_branch_name: str, base_branch_name: str | None = None) -&gt; Branch | None:
        if base_branch_name is None:
            base_branch_name = self.default_branch

        base_branch = self.repo.get_branch(base_branch_name)
        # TODO: also wrap git ref. low pri b/c the only write operation on refs is creating one
        self.repo.create_git_ref(sha=base_branch.commit.sha, ref=f&quot;refs/heads/{new_branch_name}&quot;)
        branch = self.get_branch_safe(new_branch_name)
        return branch

    def create_branch_from_sha(self, new_branch_name: str, base_sha: str) -&gt; Branch | None:
        self.repo.create_git_ref(ref=f&quot;refs/heads/{new_branch_name}&quot;, sha=base_sha)
        branch = self.get_branch_safe(new_branch_name)
        return branch

    def delete_branch(self, branch_name: str) -&gt; None:
        if branch_name == self.default_branch:
            logger.warning(&quot;Deleting the default branch is not allowed! Skipping delete.&quot;)
            return
        # TODO: log event

        branch_to_delete = self.get_branch_safe(branch_name)
        if branch_to_delete:
            ref_to_delete = self.repo.get_git_ref(f&quot;heads/{branch_name}&quot;)
            ref_to_delete.delete()
            logger.info(f&quot;Branch: {branch_name} deleted successfully!&quot;)
        else:
            logger.info(f&quot;Branch: {branch_name} does not exist. Skipping delete.&quot;)

    ####################################################################################################################
    # COMMITS
    ####################################################################################################################

    def get_commit_safe(self, commit_sha: str) -&gt; Commit | None:
        try:
            return self.repo.get_commit(commit_sha)
        except UnknownObjectException as e:
            logger.warning(f&quot;Commit {commit_sha} not found:\n\t{e}&quot;)
            return None
        except Exception as e:
            logger.warning(f&quot;Error getting commit {commit_sha}:\n\t{e}&quot;)
            return None

    ####################################################################################################################
    # DIFFS
    ####################################################################################################################

    def get_commit_diff(self, commit: Commit, show_commits: bool = False) -&gt; str:
        &quot;&quot;&quot;Diff of a single commit&quot;&quot;&quot;
        return self.compare_commits(commit.parents[0], commit, show_commits=show_commits)

    def get_pr_diff(self, pr: PullRequest, show_commits: bool = False) -&gt; str:
        return self.compare(pr.base.sha, pr.head.sha, show_commits=show_commits)

    def compare_commits(self, base_commit: Commit, head_commit: Commit, show_commits: bool = False) -&gt; str:
        return self.compare(base_commit.sha, head_commit.sha, show_commits=show_commits)

    # TODO: make base_branch param optional
    def compare_branches(self, base_branch_name: str | None, head_branch_name: str, show_commits: bool = False) -&gt; str:
        &quot;&quot;&quot;Comparison between two branches&quot;&quot;&quot;
        if base_branch_name is None:
            base_branch_name = self.default_branch
        return self.compare(base_branch_name, head_branch_name, show_commits=show_commits)

    # NOTE: base utility that other compare functions should try to use
    def compare(self, base: str, head: str, show_commits: bool = False) -&gt; str:
        comparison = self.repo.compare(base, head)
        return format_comparison(comparison, show_commits=show_commits)

    ####################################################################################################################
    # LABELS
    ####################################################################################################################

    # TODO: also wrap labels in safe wrapper to allow making edits
    def get_label_safe(self, label_name: str) -&gt; Label | None:
        try:
            label_name = label_name.strip()
            label = self.repo.get_label(label_name)
            return label
        except UnknownObjectException as e:
            return None
        except Exception as e:
            logger.warning(f&quot;Error getting label by name: {label_name}\n\t{e}&quot;)
            return None

    def create_label(self, label_name: str, color: str) -&gt; Label:
        # TODO: also offer description field
        label_name = label_name.strip()
        self.repo.create_label(label_name, color)
        # TODO: is there a way to convert new_label to a read-only label without making another API call?
        # NOTE: return a read-only label to prevent people from editing it
        return self.repo.get_label(label_name)

    def get_or_create_label(self, label_name: str, color: str) -&gt; Label:
        existing_label = self.get_label_safe(label_name)
        if existing_label:
            return existing_label
        return self.create_label(label_name=label_name, color=color)

    ####################################################################################################################
    # CHECK SUITES
    ####################################################################################################################

    def get_check_suite_safe(self, check_suite_id: int) -&gt; CheckSuite | None:
        try:
            return self.repo.get_check_suite(check_suite_id)
        except UnknownObjectException as e:
            return None
        except Exception as e:
            logger.warning(f&quot;Error getting check suite by id: {check_suite_id}\n\t{e}&quot;)
            return None

    ####################################################################################################################
    # CHECK RUNS
    ####################################################################################################################

    def get_check_run_safe(self, check_run_id: int) -&gt; CheckRun | None:
        try:
            return self.repo.get_check_run(check_run_id)
        except UnknownObjectException as e:
            return None
        except Exception as e:
            logger.warning(f&quot;Error getting check run by id: {check_run_id}\n\t{e}&quot;)
            return None

    def create_check_run(
        self,
        name: str,
        head_sha: str,
        details_url: Opt[str] = NotSet,
        status: Opt[str] = NotSet,
        conclusion: Opt[str] = NotSet,
        output: Opt[dict[str, str | list[dict[str, str | int]]]] = NotSet,
    ) -&gt; CheckRun:
        new_check_run = self.repo.create_check_run(name=name, head_sha=head_sha, details_url=details_url, status=status, conclusion=conclusion, output=output)
        return self.repo.get_check_run(new_check_run.id)

    ####################################################################################################################
    # WORKFLOW
    ####################################################################################################################

    def get_workflow_safe(self, file_name: str) -&gt; Workflow | None:
        try:
            return self.repo.get_workflow(file_name)
        except UnknownObjectException as e:
            return None
        except Exception as e:
            logger.warning(f&quot;Error getting workflow by file name: {file_name}\n\t{e}&quot;)
            return None

    def create_workflow_dispatch(self, workflow: Workflow, ref: Branch | Tag | Commit | str, inputs: Opt[dict] = NotSet):
        writeable_workflow = self.repo.get_workflow(workflow.id)
        writeable_workflow.create_dispatch(ref=ref, inputs=inputs)

    ####################################################################################################################
    # FORKS
    ####################################################################################################################

    def merge_upstream(self, branch_name: str) -&gt; bool:
        &quot;&quot;&quot;:calls: `POST /repos/{owner}/{repo}/merge-upstream &lt;http://docs.github.com/en/rest/reference/repos#sync-a-fork-branch-with-the-upstream-repository&gt;`_
        :param branch: string
        :rtype: bool

        Copied from: https://github.com/PyGithub/PyGithub/pull/2066. Remove after this change is merged into PyGithub.
        &quot;&quot;&quot;
        assert isinstance(branch_name, str), branch_name
        post_parameters = {&quot;branch&quot;: branch_name}
        status, _, _ = self.repo._requester.requestJson(&quot;POST&quot;, f&quot;{self.repo.url}/merge-upstream&quot;, input=post_parameters)
        return status == 200

    ####################################################################################################################
    # SEARCH
    ####################################################################################################################

    def search_issues(self, query: str, **kwargs) -&gt; list[Issue]:
        return self.gh_client.client.search_issues(query, **kwargs)

    def search_prs(self, query: str, **kwargs) -&gt; list[PullRequest]:
        return self.gh_client.client.search_issues(query, **kwargs)</file><file path="src/codegen/git/clients/github_client.py">from github import Consts
from github.GithubException import UnknownObjectException
from github.MainClass import Github
from github.Organization import Organization
from github.Repository import Repository

from codegen.shared.logging.get_logger import get_logger

logger = get_logger(__name__)


class GithubClient:
    &quot;&quot;&quot;Manages interaction with GitHub&quot;&quot;&quot;

    base_url: str
    _client: Github

    def __init__(self, token: str | None = None, base_url: str = Consts.DEFAULT_BASE_URL):
        self.base_url = base_url
        self._client = Github(token, base_url=base_url)

    @property
    def client(self) -&gt; Github:
        return self._client

    ####################################################################################################################
    # CHECK RUNS
    ####################################################################################################################

    def get_repo_by_full_name(self, full_name: str) -&gt; Repository | None:
        try:
            return self._client.get_repo(full_name)
        except UnknownObjectException as e:
            return None
        except Exception as e:
            logger.warning(f&quot;Error getting repo {full_name}:\n\t{e}&quot;)
            return None

    def get_organization(self, org_name: str) -&gt; Organization | None:
        try:
            return self._client.get_organization(org_name)
        except UnknownObjectException as e:
            return None
        except Exception as e:
            logger.warning(f&quot;Error getting org {org_name}:\n\t{e}&quot;)
            return None</file><file path="src/codegen/git/configs/constants.py">&quot;&quot;&quot;Git related constants&quot;&quot;&quot;

CODEGEN_BOT_NAME = &quot;codegen-sh[bot]&quot;
CODEGEN_BOT_EMAIL = &quot;131295404+codegen-sh[bot]@users.noreply.github.com&quot;
CODEOWNERS_FILEPATHS = [&quot;.github/CODEOWNERS&quot;, &quot;CODEOWNERS&quot;, &quot;docs/CODEOWNERS&quot;]</file><file path="src/codegen/git/models/codemod_context.py">from importlib.metadata import version
from typing import Any

from pydantic import BaseModel
from pydantic.fields import Field

from codegen.git.models.pull_request_context import PullRequestContext
from codegen.shared.logging.get_logger import get_logger

logger = get_logger(__name__)


class CodemodContext(BaseModel):
    CODEGEN_VERSION: str = version(&quot;codegen&quot;)
    CODEMOD_ID: int | None = None
    CODEMOD_LINK: str | None = None
    CODEMOD_AUTHOR: str | None = None
    TEMPLATE_ARGS: dict[str, Any] = Field(default_factory=dict)

    # TODO: add fields for version
    # CODEMOD_VERSION_ID: int | None = None
    # CODEMOD_VERSION_AUTHOR: str | None = None

    PULL_REQUEST: PullRequestContext | None = None

    @classmethod
    def _render_template(cls, template_schema: dict[str, str], template_values: dict[str, Any]) -&gt; dict[str, Any]:
        template_data: dict[str, Any] = {}
        for var_name, var_value in template_values.items():
            var_type = template_schema.get(var_name)

            if var_type == &quot;list&quot;:
                template_data[var_name] = [str(v).strip() for v in var_value.split(&quot;,&quot;)]
            else:
                template_data[var_name] = str(var_value)
        return template_data</file><file path="src/codegen/git/models/github_named_user_context.py">from pydantic import BaseModel


class GithubNamedUserContext(BaseModel):
    &quot;&quot;&quot;Represents a GitHub user parsed from a webhook payload&quot;&quot;&quot;

    login: str
    email: str | None = None

    @classmethod
    def from_payload(cls, payload: dict) -&gt; &quot;GithubNamedUserContext&quot;:
        return cls(login=payload.get(&quot;login&quot;), email=payload.get(&quot;email&quot;))</file><file path="src/codegen/git/models/pr_options.py">from pydantic import BaseModel

from codegen.shared.decorators.docs import apidoc


@apidoc
class PROptions(BaseModel):
    &quot;&quot;&quot;Options for generating a PR.

    Attributes:
        title: The title of the pull request.
        body: The body content of the pull request.
        labels: A list of labels to be added to the pull request.
        force_push_head_branch: Whether to force push the head branch.
    &quot;&quot;&quot;

    title: str | None = None
    body: str | None = None
    labels: list[str] | None = None  # TODO: not used until we add labels to GithubPullRequestModel
    force_push_head_branch: bool | None = None</file><file path="src/codegen/git/models/pr_part_context.py">from pydantic import BaseModel


class PRPartContext(BaseModel):
    &quot;&quot;&quot;Represents a GitHub pull request part parsed from a webhook payload&quot;&quot;&quot;

    ref: str
    sha: str

    @classmethod
    def from_payload(cls, payload: dict) -&gt; &quot;PRPartContext&quot;:
        return cls(ref=payload.get(&quot;ref&quot;), sha=payload.get(&quot;sha&quot;))</file><file path="src/codegen/git/models/pull_request_context.py">from pydantic import BaseModel

from codegen.git.models.github_named_user_context import GithubNamedUserContext
from codegen.git.models.pr_part_context import PRPartContext


class PullRequestContext(BaseModel):
    &quot;&quot;&quot;Represents a GitHub pull request&quot;&quot;&quot;

    id: int
    url: str
    html_url: str
    number: int
    state: str
    title: str
    user: GithubNamedUserContext
    draft: bool
    head: PRPartContext
    base: PRPartContext
    body: str | None = None
    merged: bool | None = None
    merged_by: dict | None = None
    additions: int | None = None
    deletions: int | None = None
    changed_files: int | None = None
    webhook_data: dict | None = None

    @classmethod
    def from_payload(cls, webhook_payload: dict) -&gt; &quot;PullRequestContext&quot;:
        webhook_data = webhook_payload.get(&quot;pull_request&quot;, {})
        return cls(
            id=webhook_data.get(&quot;id&quot;),
            url=webhook_data.get(&quot;url&quot;),
            html_url=webhook_data.get(&quot;html_url&quot;),
            number=webhook_data.get(&quot;number&quot;),
            state=webhook_data.get(&quot;state&quot;),
            title=webhook_data.get(&quot;title&quot;),
            user=GithubNamedUserContext.from_payload(webhook_data.get(&quot;user&quot;, {})),
            body=webhook_data.get(&quot;body&quot;),
            draft=webhook_data.get(&quot;draft&quot;),
            head=PRPartContext.from_payload(webhook_data.get(&quot;head&quot;, {})),
            base=PRPartContext.from_payload(webhook_data.get(&quot;base&quot;, {})),
            merged=webhook_data.get(&quot;merged&quot;),
            merged_by=webhook_data.get(&quot;merged_by&quot;, {}),
            additions=webhook_data.get(&quot;additions&quot;),
            deletions=webhook_data.get(&quot;deletions&quot;),
            changed_files=webhook_data.get(&quot;changed_files&quot;),
            webhook_data=webhook_data,
        )</file><file path="src/codegen/git/repo_operator/local_git_repo.py">import os
from functools import cached_property
from pathlib import Path

import giturlparse
from git import Repo
from git.remote import Remote

from codegen.git.clients.git_repo_client import GitRepoClient
from codegen.git.schemas.repo_config import RepoConfig
from codegen.git.utils.language import determine_project_language


# TODO: merge this with RepoOperator
class LocalGitRepo:
    repo_path: Path

    def __init__(self, repo_path: Path):
        self.repo_path = repo_path

    @cached_property
    def git_cli(self) -&gt; Repo:
        return Repo(self.repo_path)

    @cached_property
    def name(self) -&gt; str:
        return os.path.basename(self.repo_path)

    @cached_property
    def owner(self) -&gt; str | None:
        if not self.origin_remote:
            return None

        parsed = giturlparse.parse(self.origin_remote.url)
        return parsed.owner

    @cached_property
    def full_name(self) -&gt; str | None:
        if not self.origin_remote:
            return None

        parsed = giturlparse.parse(self.origin_remote.url)
        return f&quot;{parsed.owner}/{parsed.name}&quot;

    @cached_property
    def origin_remote(self) -&gt; Remote | None:
        &quot;&quot;&quot;Returns the url of the first remote found on the repo, or None if no remotes are set&quot;&quot;&quot;
        if self.has_remote():
            return self.git_cli.remote(&quot;origin&quot;)
        return None

    @cached_property
    def base_url(self) -&gt; str | None:
        if self.origin_remote:
            return self.origin_remote.url
        return None

    @property
    def user_name(self) -&gt; str | None:
        with self.git_cli.config_reader() as reader:
            if reader.has_option(&quot;user&quot;, &quot;name&quot;):
                return reader.get(&quot;user&quot;, &quot;name&quot;)
        return None

    @property
    def user_email(self) -&gt; str | None:
        with self.git_cli.config_reader() as reader:
            if reader.has_option(&quot;user&quot;, &quot;email&quot;):
                return reader.get(&quot;user&quot;, &quot;email&quot;)
        return None

    def get_language(self, access_token: str | None = None) -&gt; str:
        &quot;&quot;&quot;Returns the majority language of the repository&quot;&quot;&quot;
        if access_token is not None:
            repo_config = RepoConfig.from_repo_path(repo_path=str(self.repo_path))
            repo_config.full_name = self.full_name
            remote_git = GitRepoClient(repo_config=repo_config, access_token=access_token)
            if (language := remote_git.repo.language) is not None:
                return language.upper()

        return str(determine_project_language(str(self.repo_path)))

    def has_remote(self) -&gt; bool:
        return bool(self.git_cli.remotes)</file><file path="src/codegen/git/repo_operator/repo_operator.py">import codecs
import fnmatch
import glob
import os
from collections.abc import Generator
from datetime import UTC, datetime
from functools import cached_property
from time import perf_counter
from typing import Self

from codeowners import CodeOwners as CodeOwnersParser
from git import Commit as GitCommit
from git import Diff, GitCommandError, InvalidGitRepositoryError, Remote
from git import Repo as GitCLI
from git.remote import PushInfoList
from github.IssueComment import IssueComment
from github.PullRequest import PullRequest

from codegen.configs.models.secrets import SecretsConfig
from codegen.git.clients.git_repo_client import GitRepoClient
from codegen.git.configs.constants import CODEGEN_BOT_EMAIL, CODEGEN_BOT_NAME
from codegen.git.repo_operator.local_git_repo import LocalGitRepo
from codegen.git.schemas.enums import CheckoutResult, FetchResult, RepoVisibility, SetupOption
from codegen.git.schemas.repo_config import RepoConfig
from codegen.git.utils.clone import clone_or_pull_repo, clone_repo, pull_repo
from codegen.git.utils.clone_url import add_access_token_to_url, get_authenticated_clone_url_for_repo_config, get_clone_url_for_repo_config, url_to_github
from codegen.git.utils.codeowner_utils import create_codeowners_parser_for_repo
from codegen.git.utils.file_utils import create_files
from codegen.git.utils.remote_progress import CustomRemoteProgress
from codegen.shared.logging.get_logger import get_logger
from codegen.shared.performance.stopwatch_utils import stopwatch
from codegen.shared.performance.time_utils import humanize_duration

logger = get_logger(__name__)


class RepoOperator:
    &quot;&quot;&quot;A wrapper around GitPython to make it easier to interact with a repo.&quot;&quot;&quot;

    repo_config: RepoConfig
    base_dir: str
    bot_commit: bool = True
    access_token: str | None = None

    # lazy attributes
    _codeowners_parser: CodeOwnersParser | None = None
    _default_branch: str | None = None
    _remote_git_repo: GitRepoClient | None = None
    _local_git_repo: LocalGitRepo | None = None

    def __init__(
        self,
        repo_config: RepoConfig,
        access_token: str | None = None,
        bot_commit: bool = False,
        setup_option: SetupOption | None = None,
        shallow: bool | None = None,
    ) -&gt; None:
        assert repo_config is not None
        self.repo_config = repo_config
        self.access_token = access_token or SecretsConfig().github_token
        self.base_dir = repo_config.base_dir
        self.bot_commit = bot_commit

        if setup_option:
            if shallow is not None:
                self.setup_repo_dir(setup_option=setup_option, shallow=shallow)
            else:
                self.setup_repo_dir(setup_option=setup_option)

        else:
            os.makedirs(self.repo_path, exist_ok=True)
            GitCLI.init(self.repo_path)
            self._local_git_repo = LocalGitRepo(repo_path=repo_config.repo_path)
            if self.repo_config.full_name is None:
                self.repo_config.full_name = self._local_git_repo.full_name

    ####################################################################################################################
    # PROPERTIES
    ####################################################################################################################

    @property
    def repo_name(self) -&gt; str:
        return self.repo_config.name

    @property
    def repo_path(self) -&gt; str:
        return os.path.join(self.base_dir, self.repo_name)

    @property
    def remote_git_repo(self) -&gt; GitRepoClient:
        if not self.access_token and self.repo_config.visibility != RepoVisibility.PUBLIC:
            msg = &quot;Must initialize with access_token to get remote&quot;
            raise ValueError(msg)

        if not self._remote_git_repo:
            self._remote_git_repo = GitRepoClient(self.repo_config, access_token=self.access_token)
        return self._remote_git_repo

    @property
    def clone_url(self) -&gt; str:
        if self.access_token:
            return get_authenticated_clone_url_for_repo_config(repo=self.repo_config, token=self.access_token)
        return f&quot;https://github.com/{self.repo_config.full_name}.git&quot;

    @property
    def viz_path(self) -&gt; str:
        return os.path.join(self.base_dir, &quot;codegen-graphviz&quot;)

    @property
    def viz_file_path(self) -&gt; str:
        return os.path.join(self.viz_path, &quot;graph.json&quot;)

    def _set_bot_email(self, git_cli: GitCLI) -&gt; None:
        with git_cli.config_writer(&quot;repository&quot;) as writer:
            if not writer.has_section(&quot;user&quot;):
                writer.add_section(&quot;user&quot;)
            writer.set(&quot;user&quot;, &quot;email&quot;, CODEGEN_BOT_EMAIL)

    def _set_bot_username(self, git_cli: GitCLI) -&gt; None:
        with git_cli.config_writer(&quot;repository&quot;) as writer:
            if not writer.has_section(&quot;user&quot;):
                writer.add_section(&quot;user&quot;)
            writer.set(&quot;user&quot;, &quot;name&quot;, CODEGEN_BOT_NAME)

    def _unset_bot_email(self, git_cli: GitCLI) -&gt; None:
        with git_cli.config_writer(&quot;repository&quot;) as writer:
            if writer.has_option(&quot;user&quot;, &quot;email&quot;):
                writer.remove_option(&quot;user&quot;, &quot;email&quot;)

    def _unset_bot_username(self, git_cli: GitCLI) -&gt; None:
        with git_cli.config_writer(&quot;repository&quot;) as writer:
            if writer.has_option(&quot;user&quot;, &quot;name&quot;):
                writer.remove_option(&quot;user&quot;, &quot;name&quot;)

    @cached_property
    def git_cli(self) -&gt; GitCLI:
        git_cli = GitCLI(self.repo_path)
        username = None
        user_level = None
        email = None
        email_level = None
        levels = [&quot;system&quot;, &quot;global&quot;, &quot;user&quot;, &quot;repository&quot;]
        for level in levels:
            with git_cli.config_reader(level) as reader:
                if reader.has_option(&quot;user&quot;, &quot;name&quot;) and not username:
                    username = username or reader.get(&quot;user&quot;, &quot;name&quot;)
                    user_level = user_level or level
                if reader.has_option(&quot;user&quot;, &quot;email&quot;) and not email:
                    email = email or reader.get(&quot;user&quot;, &quot;email&quot;)
                    email_level = email_level or level

        # We need a username and email to commit, so if they&apos;re not set, set them to the bot&apos;s
        if not username or self.bot_commit:
            self._set_bot_username(git_cli)
        if not email or self.bot_commit:
            self._set_bot_email(git_cli)

        # If user config is set at a level above the repo level: unset it
        if not self.bot_commit:
            if username and username != CODEGEN_BOT_NAME and user_level != &quot;repository&quot;:
                self._unset_bot_username(git_cli)
            if email and email != CODEGEN_BOT_EMAIL and email_level != &quot;repository&quot;:
                self._unset_bot_email(git_cli)

        return git_cli

    @property
    def head_commit(self) -&gt; GitCommit | None:
        try:
            return self.git_cli.head.commit
        except ValueError as e:
            if (f&quot;Reference at {self.git_cli.head.ref.path!r} does not exist&quot;) in str(e):
                logger.info(f&quot;Ref: {self.git_cli.head.ref.name} has no commits&quot;)
                return None
            raise

    @property
    def git_diff(self) -&gt; str:
        &quot;&quot;&quot;Get the diff of the repo. Useful for checking if there are any changes.&quot;&quot;&quot;
        return self.git_cli.git.diff()

    @property
    def default_branch(self) -&gt; str:
        # Priority 1: If default branch has been set
        if self._default_branch:
            if self._default_branch is None:
                self._default_branch = self.remote_git_repo.default_branch
                return self._default_branch
            return self._default_branch

        # Priority 2: If origin/HEAD ref exists
        origin_prefix = &quot;origin&quot;
        if f&quot;{origin_prefix}/HEAD&quot; in self.git_cli.refs:
            return self.git_cli.refs[f&quot;{origin_prefix}/HEAD&quot;].reference.name.removeprefix(f&quot;{origin_prefix}/&quot;)

        # Priority 3: Fallback to the active branch
        return self.git_cli.active_branch.name

    @property
    def codeowners_parser(self) -&gt; CodeOwnersParser | None:
        if not self._codeowners_parser:
            if not self._remote_git_repo:
                return None
            self._codeowners_parser = create_codeowners_parser_for_repo(self.remote_git_repo)
        return self._codeowners_parser

    ####################################################################################################################
    # SET UP
    ####################################################################################################################
    def setup_repo_dir(self, setup_option: SetupOption = SetupOption.PULL_OR_CLONE, shallow: bool = True) -&gt; None:
        os.makedirs(self.base_dir, exist_ok=True)
        os.chdir(self.base_dir)
        if setup_option is SetupOption.CLONE:
            # if repo exists delete, then clone, else clone
            clone_repo(shallow=shallow, repo_path=self.repo_path, clone_url=self.clone_url)
        elif setup_option is SetupOption.PULL_OR_CLONE:
            # if repo exists, pull changes, else clone
            self.clone_or_pull_repo(shallow=shallow)
        elif setup_option is SetupOption.SKIP:
            if not self.repo_exists():
                logger.warning(f&quot;Valid git repo does not exist at {self.repo_path}. Cannot skip setup with SetupOption.SKIP.&quot;)
        os.chdir(self.repo_path)

    def repo_exists(self) -&gt; bool:
        if not os.path.exists(self.repo_path):
            return False
        try:
            _ = GitCLI(self.repo_path)
            return True
        except InvalidGitRepositoryError as e:
            return False

    def clean_repo(self) -&gt; None:
        &quot;&quot;&quot;Cleans the repo by:
        1. Discards any changes (tracked/untracked)
        2. Checks out the default branch (+ makes sure it&apos;s up to date with the remote)
        3. Deletes all branches except the default branch
        4. Deletes all remotes except origin

        Used in SetupOption.PULL_OR_CLONE to allow people to re-use existing repos and start from a clean state.
        &quot;&quot;&quot;
        logger.info(f&quot;Cleaning repo at {self.repo_path} ...&quot;)
        self.discard_changes()
        self.checkout_branch(self.default_branch, remote=True)
        self.clean_branches()
        self.clean_remotes()

    @stopwatch
    def discard_changes(self) -&gt; None:
        &quot;&quot;&quot;Cleans repo dir by discarding any changes in staging/working directory and removes untracked files/dirs. Use with .is_dirty().&quot;&quot;&quot;
        ts1 = perf_counter()
        self.git_cli.head.reset(index=True, working_tree=True)  # discard staged (aka index) + unstaged (aka working tree) changes in tracked files
        ts2 = perf_counter()
        self.git_cli.git.clean(&quot;-fdxq&quot;)  # removes untracked changes and ignored files
        ts3 = perf_counter()
        self.git_cli.git.gc(&quot;--auto&quot;)  # garbage collect
        ts4 = perf_counter()
        logger.info(f&quot;discard_changes took {humanize_duration(ts2 - ts1)} to reset, {humanize_duration(ts3 - ts2)} to clean, {humanize_duration(ts4 - ts3)} to gc&quot;)

    @stopwatch
    def clean_remotes(self) -&gt; None:
        for remote in self.git_cli.remotes:
            if remote.name == &quot;origin&quot;:
                continue
            logger.info(f&quot;Deleting remote {remote.name} ...&quot;)
            self.git_cli.delete_remote(remote)

    @stopwatch
    def clean_branches(self) -&gt; None:
        for branch in self.git_cli.branches:
            if self.is_branch_checked_out(branch.name):
                continue
            logger.info(f&quot;Deleting branch {branch.name} ...&quot;)
            self.git_cli.delete_head(branch.name, force=True)

    def pull_repo(self) -&gt; None:
        &quot;&quot;&quot;Pull the latest commit down to an existing local repo&quot;&quot;&quot;
        pull_repo(repo_path=self.repo_path, clone_url=self.clone_url)

    def clone_repo(self, shallow: bool = True) -&gt; None:
        clone_repo(repo_path=self.repo_path, clone_url=self.clone_url, shallow=shallow)

    def clone_or_pull_repo(self, shallow: bool = True) -&gt; None:
        &quot;&quot;&quot;If repo exists, pulls changes. otherwise, clones the repo.&quot;&quot;&quot;
        # TODO(CG-7804): if repo is not valid we should delete it and re-clone. maybe we can create a pull_repo util + use the existing clone_repo util
        if self.repo_exists():
            self.clean_repo()
        clone_or_pull_repo(repo_path=self.repo_path, clone_url=self.clone_url, shallow=shallow)

    ####################################################################################################################
    # CHECKOUT, BRANCHES &amp; COMMITS
    ####################################################################################################################
    @stopwatch
    def checkout_remote_branch(self, branch_name: str | None = None, remote_name: str = &quot;origin&quot;) -&gt; CheckoutResult:
        &quot;&quot;&quot;Checks out a branch from a Remote + tracks the Remote.
        If the branch_name is already checked out, does nothing
        &quot;&quot;&quot;
        return self.checkout_branch(branch_name, remote_name=remote_name, remote=True, create_if_missing=False)

    def safe_get_commit(self, commit: str) -&gt; GitCommit | None:
        &quot;&quot;&quot;Gets commit if it exists, else returns None&quot;&quot;&quot;
        try:
            return self.git_cli.commit(commit)
        except Exception as e:
            logger.warning(f&quot;Failed to get commit {commit}:\n\t{e}&quot;)
            return None

    def fetch_remote(self, remote_name: str = &quot;origin&quot;, refspec: str | None = None, force: bool = True) -&gt; FetchResult:
        &quot;&quot;&quot;Fetches and updates a ref from a remote repository.

        Args:
            remote_name (str): Name of the remote to fetch from. Defaults to &quot;origin&quot;.
            refspec (str | None): The refspec to fetch. If None, fetches all refs. Defaults to None.
            force (bool): If True, forces the fetch operation. Defaults to True.

        Returns:
            FetchResult: An enum indicating the result of the fetch operation.
                - SUCCESS: Fetch was successful.
                - REFSPEC_NOT_FOUND: The specified refspec doesn&apos;t exist in the remote.

        Raises:
            GitCommandError: If the fetch operation fails for reasons other than a missing refspec.

        Note:
            This force fetches by default b/c by default we prefer the remote branch over our local branch.
        &quot;&quot;&quot;
        logger.info(f&quot;Fetching {remote_name} with refspec {refspec}&quot;)
        progress = CustomRemoteProgress()

        try:
            self.git_cli.remotes[remote_name].fetch(refspec=refspec, force=force, progress=progress, no_tags=True)
            return FetchResult.SUCCESS
        except GitCommandError as e:
            if progress.fetch_result == FetchResult.REFSPEC_NOT_FOUND:
                return FetchResult.REFSPEC_NOT_FOUND
            else:
                raise e

    def delete_remote(self, remote_name: str) -&gt; None:
        remote = self.git_cli.remote(remote_name)
        if remote:
            self.git_cli.delete_remote(remote)

    def create_remote(self, remote_name: str, remote_url: str) -&gt; None:
        &quot;&quot;&quot;Creates a remote. Skips if the remote already exists.&quot;&quot;&quot;
        if remote_name in self.git_cli.remotes:
            logger.warning(f&quot;Remote with name {remote_name} already exists. Skipping create_remote.&quot;)
            return
        self.git_cli.create_remote(remote_name, url=remote_url)

    @stopwatch
    def checkout_commit(self, commit_hash: str | GitCommit, remote_name: str = &quot;origin&quot;) -&gt; CheckoutResult:
        &quot;&quot;&quot;Checks out the relevant commit
        TODO: handle the environment being dirty
        &quot;&quot;&quot;
        logger.info(f&quot;Checking out commit: {commit_hash}&quot;)
        if not self.git_cli.is_valid_object(commit_hash, &quot;commit&quot;):
            self.fetch_remote(remote_name=remote_name, refspec=commit_hash)
            if not self.git_cli.is_valid_object(commit_hash, &quot;commit&quot;):
                return CheckoutResult.NOT_FOUND

        if self.git_cli.is_dirty():
            logger.info(f&quot;Environment is dirty, discarding changes before checking out commit: {commit_hash}&quot;)
            self.discard_changes()

        self.git_cli.git.checkout(commit_hash)
        return CheckoutResult.SUCCESS

    def get_active_branch_or_commit(self) -&gt; str:
        &quot;&quot;&quot;Returns the current active branch, or commit hexsha if head is detached&quot;&quot;&quot;
        if self.git_cli.head.is_detached:
            return self.git_cli.head.commit.hexsha
        return self.git_cli.active_branch.name

    def is_branch_checked_out(self, branch_name: str) -&gt; bool:
        if self.git_cli.head.is_detached:
            return False
        return self.git_cli.active_branch.name == branch_name

    def checkout_branch(self, branch_name: str | None, *, remote: bool = False, remote_name: str = &quot;origin&quot;, create_if_missing: bool = True) -&gt; CheckoutResult:
        &quot;&quot;&quot;Attempts to check out the branch in the following order:
        - Check out the local branch by name
        - Check out the remote branch if it&apos;s been fetched
        - Creates a new branch from the current commit (with create=True)

        NOTE: if branch is already checked out this does nothing.
        TIP: Use remote=True if you want to always try to checkout the branch from a remote

        Args:
        ----
            branch_name (str): Name of the branch to checkout.
            create_if_missing: If the branch doesn&apos;t exist, create one
            remote: Checks out a branch from a Remote + tracks the Remote
            force (bool): If True, force checkout by resetting the current branch to HEAD.
                          If False, raise an error if the branch is dirty.

        Raises:
        ------
            GitCommandError: If there&apos;s an error with Git operations.
            RuntimeError: If the branch is dirty and force is not set.
        &quot;&quot;&quot;
        if branch_name is None:
            branch_name = self.default_branch

        try:
            if self.is_branch_checked_out(branch_name):
                if remote:
                    # If the branch is already checked out and we want to fetch it from the remote, reset --hard to the remote branch
                    logger.info(f&quot;Branch {branch_name} is already checked out locally. Resetting to remote branch: {remote_name}/{branch_name}&quot;)
                    # TODO: would have to fetch the the remote branch first to retrieve latest changes
                    self.git_cli.git.reset(&quot;--hard&quot;, f&quot;{remote_name}/{branch_name}&quot;)
                    return CheckoutResult.SUCCESS
                else:
                    logger.info(f&quot;Branch {branch_name} is already checked out! Skipping checkout_branch.&quot;)
                    return CheckoutResult.SUCCESS

            if self.git_cli.is_dirty():
                logger.info(f&quot;Environment is dirty, discarding changes before checking out branch: {branch_name}.&quot;)
                self.discard_changes()

            # If remote=True, create a local branch tracking the remote branch and checkout onto it
            if remote:
                res = self.fetch_remote(remote_name, refspec=f&quot;{branch_name}:{branch_name}&quot;)
                if res is FetchResult.SUCCESS:
                    self.git_cli.git.checkout(branch_name)
                    return CheckoutResult.SUCCESS
                if res is FetchResult.REFSPEC_NOT_FOUND:
                    logger.warning(f&quot;Branch {branch_name} not found in remote {remote_name}. Unable to checkout remote branch.&quot;)
                    return CheckoutResult.NOT_FOUND

            # If the branch already exists, checkout onto it
            if branch_name in self.git_cli.heads:
                self.git_cli.heads[branch_name].checkout()
                return CheckoutResult.SUCCESS

            # If the branch does not exist and create_if_missing=True, create and checkout a new branch from the current commit
            elif create_if_missing:
                logger.info(f&quot;Creating new branch {branch_name} from current commit: {self.git_cli.head.commit.hexsha}&quot;)
                new_branch = self.git_cli.create_head(branch_name)
                new_branch.checkout()
                return CheckoutResult.SUCCESS
            else:
                return CheckoutResult.NOT_FOUND

        except GitCommandError as e:
            if &quot;fatal: ambiguous argument&quot; in e.stderr:
                logger.warning(f&quot;Branch {branch_name} was not found in remote {remote_name}. Unable to checkout.&quot;)
                return CheckoutResult.NOT_FOUND
            else:
                logger.exception(f&quot;Error with Git operations: {e}&quot;)
                raise

    def get_modified_files(self, ref: str | GitCommit) -&gt; list[str]:
        &quot;&quot;&quot;Returns a list of modified files in the repo&quot;&quot;&quot;
        self.git_cli.git.add(A=True)
        diff = self.git_cli.git.diff(ref, &quot;--name-only&quot;)
        return diff.splitlines()

    def get_diffs(self, ref: str | GitCommit, reverse: bool = True) -&gt; list[Diff]:
        &quot;&quot;&quot;Gets all staged diffs&quot;&quot;&quot;
        self.git_cli.git.add(A=True)
        return [diff for diff in self.git_cli.index.diff(ref, R=reverse)]

    @stopwatch
    def stage_and_commit_all_changes(self, message: str, verify: bool = False, exclude_paths: list[str] | None = None) -&gt; bool:
        &quot;&quot;&quot;TODO: rename to stage_and_commit_changes
        Stage all changes and commit them with the given message.
        Returns True if a commit was made and False otherwise.
        &quot;&quot;&quot;
        self.git_cli.git.add(A=True)
        # Unstage the excluded paths
        for path in exclude_paths or []:
            try:
                self.git_cli.git.reset(&quot;HEAD&quot;, &quot;--&quot;, path)
            except GitCommandError as e:
                logger.warning(f&quot;Failed to exclude path {path}: {e}&quot;)
        return self.commit_changes(message, verify)

    def _get_username_email(self) -&gt; tuple[str, str] | None:
        for level in [&quot;user&quot;, &quot;global&quot;, &quot;system&quot;]:
            with self.git_cli.config_reader(level) as reader:
                if reader.has_section(&quot;user&quot;):
                    user, email = reader.get_value(&quot;user&quot;, &quot;name&quot;), reader.get_value(&quot;user&quot;, &quot;email&quot;)
                    if isinstance(user, str) and isinstance(email, str) and user != CODEGEN_BOT_NAME and email != CODEGEN_BOT_EMAIL:
                        return user, email
        return None

    def commit_changes(self, message: str, verify: bool = False) -&gt; bool:
        &quot;&quot;&quot;Returns True if a commit was made and False otherwise.&quot;&quot;&quot;
        staged_changes = self.git_cli.git.diff(&quot;--staged&quot;)
        if staged_changes:
            if self.bot_commit and (info := self._get_username_email()):
                user, email = info
                message += f&quot;\n\n Co-authored-by: {user} &lt;{email}&gt;&quot;
            commit_args = [&quot;-m&quot;, message]
            if self.bot_commit:
                commit_args.append(f&quot;--author=&apos;{CODEGEN_BOT_NAME} &lt;{CODEGEN_BOT_EMAIL}&gt;&apos;&quot;)
            if not verify:
                commit_args.append(&quot;--no-verify&quot;)
            self.git_cli.git.commit(*commit_args)
            return True
        else:
            logger.info(&quot;No changes to commit. Do nothing.&quot;)
            return False

    @stopwatch
    def push_changes(self, remote: Remote | None = None, refspec: str | None = None, force: bool = False) -&gt; PushInfoList:
        &quot;&quot;&quot;Push the changes to the given refspec of the remote.

        Args:
            refspec (str | None): refspec to push. If None, the current active branch is used.
            remote (Remote | None): Remote to push too. Defaults to &apos;origin&apos;.
            force (bool): If True, force push the changes. Defaults to False.
        &quot;&quot;&quot;
        # Use default remote if not provided
        if not remote:
            remote = self.git_cli.remote(name=&quot;origin&quot;)

        # Use the current active branch if no branch is specified
        if not refspec:
            # TODO: doesn&apos;t work with detached HEAD state
            refspec = self.git_cli.active_branch.name

        res = remote.push(refspec=refspec, force=force, progress=CustomRemoteProgress())
        for push_info in res:
            if push_info.flags &amp; push_info.ERROR:
                # Handle the error case
                logger.warning(f&quot;Error pushing {refspec}: {push_info.summary}&quot;)
            elif push_info.flags &amp; push_info.FAST_FORWARD:
                # Successful fast-forward push
                logger.info(f&quot;{refspec} pushed successfully (fast-forward).&quot;)
            elif push_info.flags &amp; push_info.NEW_HEAD:
                # Successful push of a new branch
                logger.info(f&quot;{refspec} pushed successfully as a new branch.&quot;)
            elif push_info.flags &amp; push_info.NEW_TAG:
                # Successful push of a new tag (if relevant)
                logger.info(&quot;New tag pushed successfully.&quot;)
            else:
                # Successful push, general case
                logger.info(f&quot;{refspec} pushed successfully.&quot;)
        return res

    def relpath(self, abspath) -&gt; str:
        # TODO: check if the path is an abspath (i.e. contains self.repo_path)
        return os.path.relpath(abspath, self.repo_path)

    def abspath(self, relpath) -&gt; str:
        return os.path.join(self.repo_path, relpath)

    # TODO: should rename to path exists so this can be used for dirs as well
    def file_exists(self, path: str) -&gt; bool:
        return os.path.exists(self.abspath(path))

    def folder_exists(self, path: str) -&gt; bool:
        return os.path.exists(self.abspath(path)) and os.path.isdir(self.abspath(path))

    def mkdir(self, path: str) -&gt; None:
        os.makedirs(self.abspath(path), exist_ok=True)

    def emptydir(self, path: str) -&gt; None:
        &quot;&quot;&quot;Removes all files within the specified directory.&quot;&quot;&quot;
        if self.folder_exists(self.abspath(path)):
            for filename in os.listdir(self.abspath(path)):
                file_path = os.path.join(self.abspath(path), filename)
                if os.path.isfile(file_path):
                    os.remove(file_path)

    def get_file(self, path: str) -&gt; str:
        &quot;&quot;&quot;Returns the contents of a file&quot;&quot;&quot;
        file_path = self.abspath(path)
        try:
            with open(file_path, encoding=&quot;utf-8-sig&quot;) as file:
                content = file.read()
                return content
        except UnicodeDecodeError:
            try:
                with open(file_path, encoding=&quot;latin1&quot;) as file:
                    content = file.read()
                    return content
            except UnicodeDecodeError:
                print(f&quot;Warning: Unable to decode file {file_path}. Skipping.&quot;)
                return None

    def write_file(self, relpath: str, content: str) -&gt; None:
        &quot;&quot;&quot;Writes file content to disk&quot;&quot;&quot;
        with open(self.abspath(relpath), &quot;w&quot;) as f:
            f.write(content)

    def delete_file(self, path: str) -&gt; None:
        &quot;&quot;&quot;Deletes a file from the repo&quot;&quot;&quot;
        os.remove(self.abspath(path))
        if os.listdir(self.abspath(os.path.dirname(path))) == []:
            os.rmdir(self.abspath(os.path.dirname(path)))

    def get_filepaths_for_repo(self, ignore_list):
        # Get list of files to iterate over based on gitignore setting
        if self.repo_config.respect_gitignore:
            # ls-file flags:
            # -c: show cached files
            # -o: show other / untracked files
            # --exclude-standard: exclude standard gitignore rules
            filepaths = self.git_cli.git.ls_files(&quot;-co&quot;, &quot;--exclude-standard&quot;).split(&quot;\n&quot;)
        else:
            filepaths = glob.glob(&quot;**&quot;, root_dir=self.repo_path, recursive=True, include_hidden=True)
            # Filter filepaths by ignore list.
        if ignore_list:
            filepaths = [f for f in filepaths if not any(fnmatch.fnmatch(f, pattern) or f.startswith(pattern) for pattern in ignore_list)]

        # Fix bug where unicode characters are not handled correctly
        for i, filepath in enumerate(filepaths):
            # Check if it is one of the broken cases
            if filepath.startswith(&apos;&quot;&apos;):
                # Step 1: Strip the quotes
                filepath = filepath.strip(&apos;&quot;&apos;).strip(&quot;&apos;&quot;)

                # Step 2: Convert the Python string to raw ASCII bytes (so \\ stays as two 0x5C).
                raw_filepath = filepath.encode(&quot;ascii&quot;)

                # Step 3: Use escape_decode to process backslash escapes like \346 -&gt; 0xE6
                decoded_filepath, _ = codecs.escape_decode(raw_filepath)

                # Step 4: Decode those bytes as UTF-8 to get the actual Unicode text
                filepath = decoded_filepath.decode(&quot;utf-8&quot;)

                # Step 5: Replace the original filepath with the decoded filepath
                filepaths[i] = filepath

        return filepaths

    # TODO: unify param naming i.e. subdirectories vs subdirs probably use subdirectories since that&apos;s in the DB
    def iter_files(
        self,
        subdirs: list[str] | None = None,
        extensions: list[str] | None = None,
        ignore_list: list[str] | None = None,
        skip_content: bool = False,
    ) -&gt; Generator[tuple[str, str]]:
        &quot;&quot;&quot;Iterates over all files in the codebase, yielding the filepath and its content.

        Args:
        ----
            subdirs (list[str], optional): List of subdirectories to include. Defaults to None. Can include full filenames.
            codeowners (list[str], optional): List of codeowners to iter files for. Defaults to None. Ex: if codeowners=[&quot;@group&quot;], only files owned by @group will be included.
            extensions (list[str], optional): List of file extensions to include. Defaults to None.

        Yields:
        ------
            tuple: A tuple containing the relative filepath and the content of the file.

        &quot;&quot;&quot;
        filepaths = self.get_filepaths_for_repo(ignore_list)
        # Iterate through files and yield contents
        for rel_filepath in filepaths:
            rel_filepath: str
            filepath = os.path.join(self.repo_path, rel_filepath)

            # Filter by subdirectory (includes full filenames)
            if subdirs and not any(rel_filepath.startswith(subdir) for subdir in subdirs):
                continue

            if extensions is None or any(filepath.endswith(e) for e in extensions):
                try:
                    if os.path.isfile(filepath):
                        if not skip_content:
                            content = self.get_file(filepath)
                            yield rel_filepath, content
                        else:
                            yield rel_filepath, &quot;&quot;
                    else:
                        logger.warning(f&quot;Skipping {filepath} because it does not exist or is not a valid file.&quot;)
                except Exception as e:
                    logger.warning(f&quot;Error reading file {filepath}: {e}&quot;)

    def list_files(self, subdirs: list[str] | None = None, extensions: list[str] | None = None) -&gt; list[str]:
        &quot;&quot;&quot;List files matching subdirs + extensions in a repo.

        Args:
        ----
            subdirs (list[str], optional): List of subdirectories to include. Defaults to None.
            codeowners (list[str], optional): List of codeowners to iter files for. Defaults to None. Ex: if codeowners=[&quot;@group&quot;], only files owned by @group will be included.
            extensions (list[str], optional): List of file extensions to include. Defaults to None.

        Yields:
        ------
            str: filepath

        &quot;&quot;&quot;
        list_files = []

        for rel_filepath in self.git_cli.git.ls_files().split(&quot;\n&quot;):
            rel_filepath: str
            if subdirs and not any(d in rel_filepath for d in subdirs):
                continue
            if extensions is None or any(rel_filepath.endswith(e) for e in extensions):
                list_files.append(rel_filepath)
        return list_files

    def get_commits_in_last_n_days(self, days: int = 1) -&gt; list[str]:
        &quot;&quot;&quot;Returns a list of commits in the last n days&quot;&quot;&quot;
        repo = self.git_cli
        ret = []
        default_branch = self.default_branch
        for commit in repo.iter_commits(default_branch, all=True, reverse=False):
            current_dt = datetime.now(tz=UTC)
            current_dt = current_dt.replace(tzinfo=None)
            commit_dt = commit.committed_datetime
            commit_dt = commit_dt.replace(tzinfo=None)
            if int((current_dt - commit_dt).total_seconds()) &gt; 60 * 60 * 24 * days:
                break
            ret.append(commit.hexsha)
        return ret

    def get_modified_files_in_last_n_days(self, days: int = 1) -&gt; tuple[list[str], list[str]]:
        &quot;&quot;&quot;Returns a list of files modified and deleted in the last n days&quot;&quot;&quot;
        modified_files = []
        deleted_files = []
        allowed_extensions = [&quot;.py&quot;]

        repo = self.git_cli
        commits = self.get_commits_in_last_n_days(days)

        for commit_sha in commits:
            commit = repo.commit(commit_sha)
            files_changed = commit.stats.files
            for file, stats in files_changed.items():
                if stats[&quot;deletions&quot;] == stats[&quot;lines&quot;]:
                    deleted_files.append(file)
                    if file in modified_files:
                        modified_files.remove(file)
                else:
                    if file not in modified_files and file[-3:] in allowed_extensions:
                        modified_files.append(file)
        return modified_files, deleted_files

    @cached_property
    def base_url(self) -&gt; str | None:
        repo_config = self.repo_config
        clone_url = get_clone_url_for_repo_config(repo_config)
        branch = self.get_active_branch_or_commit()
        return url_to_github(clone_url, branch)

    def stash_push(self) -&gt; None:
        self.git_cli.git.stash(&quot;push&quot;)

    def stash_pop(self) -&gt; None:
        self.git_cli.git.stash(&quot;pop&quot;)

    ####################################################################################################################
    # PR UTILITIES
    ####################################################################################################################

    def get_pr_data(self, pr_number: int) -&gt; dict:
        &quot;&quot;&quot;Returns the data associated with a PR&quot;&quot;&quot;
        return self.remote_git_repo.get_pr_data(pr_number)

    def create_pr_comment(self, pr_number: int, body: str) -&gt; IssueComment:
        &quot;&quot;&quot;Create a general comment on a pull request.

        Args:
            pr_number (int): The PR number to comment on
            body (str): The comment text
        &quot;&quot;&quot;
        pr = self.remote_git_repo.get_pull_safe(pr_number)
        if pr:
            comment = self.remote_git_repo.create_issue_comment(pr, body)
            return comment

    def create_pr_review_comment(
        self,
        pr_number: int,
        body: str,
        commit_sha: str,
        path: str,
        line: int | None = None,
        side: str = &quot;RIGHT&quot;,
        start_line: int | None = None,
    ) -&gt; None:
        &quot;&quot;&quot;Create an inline review comment on a specific line in a pull request.

        Args:
            pr_number (int): The PR number to comment on
            body (str): The comment text
            commit_sha (str): The commit SHA to attach the comment to
            path (str): The file path to comment on
            line (int | None, optional): The line number to comment on. Defaults to None.
            side (str | None, optional): Which version of the file to comment on (&apos;LEFT&apos; or &apos;RIGHT&apos;). Defaults to None.
            start_line (int | None, optional): For multi-line comments, the starting line. Defaults to None.
        &quot;&quot;&quot;
        pr = self.remote_git_repo.get_pull_safe(pr_number)
        if pr:
            commit = self.remote_git_repo.get_commit_safe(commit_sha)
            if commit:
                self.remote_git_repo.create_review_comment(
                    pull=pr,
                    body=body,
                    commit=commit,
                    path=path,
                    line=line,
                    side=side,
                )

    def get_pull_request(self, pr_number: int) -&gt; PullRequest | None:
        &quot;&quot;&quot;Get a GitHub Pull Request object for the given PR number.

        Args:
            pr_number (int): The PR number to fetch

        Returns:
            PullRequest | None: The PyGitHub PullRequest object if found, None otherwise

        Note:
            This requires a GitHub API key to be set when creating the RepoOperator
        &quot;&quot;&quot;
        try:
            # Create GitHub client and get the PR
            repo = self.remote_git_repo
            if repo is None:
                logger.warning(&quot;GitHub API key is required to fetch pull requests&quot;)
                return None
            return repo.get_pull_safe(pr_number)
        except Exception as e:
            logger.warning(f&quot;Failed to get PR {pr_number}: {e!s}&quot;)
            return None

    ####################################################################################################################
    # CLASS METHODS
    ####################################################################################################################
    @classmethod
    def create_from_files(cls, repo_path: str, files: dict[str, str], bot_commit: bool = True) -&gt; Self:
        &quot;&quot;&quot;Used when you want to create a directory from a set of files and then create a RepoOperator that points to that directory.
        Use cases:
        - Unit testing
        - Playground
        - Codebase eval

        Args:
            repo_path (str): The path to the directory to create.
            files (dict[str, str]): A dictionary of file names and contents to create in the directory.
        &quot;&quot;&quot;
        # Step 1: Create dir (if not exists) + files
        os.makedirs(repo_path, exist_ok=True)
        create_files(base_dir=repo_path, files=files)

        # Step 2: Init git repo
        op = cls(repo_config=RepoConfig.from_repo_path(repo_path), bot_commit=bot_commit)
        if op.stage_and_commit_all_changes(&quot;[Codegen] initial commit&quot;):
            op.checkout_branch(None, create_if_missing=True)
        return op

    @classmethod
    def create_from_commit(cls, repo_path: str, commit: str, url: str, access_token: str | None = None, full_name: str | None = None) -&gt; Self:
        &quot;&quot;&quot;Do a shallow checkout of a particular commit to get a repository from a given remote URL.

        Args:
            repo_path (str): Path where the repo should be cloned
            commit (str): The commit hash to checkout
            url (str): Git URL of the repository
            access_token (str | None): Optional GitHub API key for operations that need GitHub access
        &quot;&quot;&quot;
        op = cls(repo_config=RepoConfig.from_repo_path(repo_path, full_name=full_name), bot_commit=False, access_token=access_token)

        op.discard_changes()
        if op.get_active_branch_or_commit() != commit:
            op.create_remote(&quot;origin&quot;, url)
            op.git_cli.remotes[&quot;origin&quot;].fetch(commit, depth=1)
            op.checkout_commit(commit)
        return op

    @classmethod
    def create_from_repo(cls, repo_path: str, url: str, access_token: str | None = None, full_history: bool = False) -&gt; Self | None:
        &quot;&quot;&quot;Create a fresh clone of a repository or use existing one if up to date.

        Args:
            repo_path (str): Path where the repo should be cloned
            url (str): Git URL of the repository
            access_token (str | None): Optional GitHub API key for operations that need GitHub access
            full_history (bool): If True, clones the complete repository history. If False, performs a shallow clone. Defaults to False.
        &quot;&quot;&quot;
        access_token = access_token or SecretsConfig().github_token
        if access_token:
            url = add_access_token_to_url(url=url, token=access_token)

        # Check if repo already exists
        if os.path.exists(repo_path):
            try:
                # Try to initialize git repo from existing path
                git_cli = GitCLI(repo_path)
                # Check if it has our remote URL
                if any(remote.url == url for remote in git_cli.remotes):
                    # Fetch to check for updates
                    git_cli.remotes.origin.fetch()
                    # Get current and remote HEADs
                    local_head = git_cli.head.commit
                    remote_head = git_cli.remotes.origin.refs[git_cli.active_branch.name].commit
                    # If up to date, use existing repo
                    if local_head.hexsha == remote_head.hexsha:
                        return cls(repo_config=RepoConfig.from_repo_path(repo_path), bot_commit=False, access_token=access_token)
            except Exception:
                logger.exception(&quot;Failed to initialize Git repository. Falling back to fresh clone.&quot;)

            # If we get here, repo exists but is not up to date or valid
            # Remove the existing directory to do a fresh clone
            import shutil

            shutil.rmtree(repo_path)

        try:
            # Clone the repository with or without full history
            if full_history:
                GitCLI.clone_from(url=url, to_path=repo_path)
            else:
                GitCLI.clone_from(url=url, to_path=repo_path, depth=1)

            # Initialize with the cloned repo
            git_cli = GitCLI(repo_path)
        except (GitCommandError, ValueError) as e:
            logger.exception(&quot;Failed to initialize Git repository&quot;)
            return None
        return cls(repo_config=RepoConfig.from_repo_path(repo_path), bot_commit=False, access_token=access_token)</file><file path="src/codegen/git/schemas/enums.py">from enum import StrEnum, auto


class SetupOption(StrEnum):
    # always do a fresh clone (if the repo already exists it will delete the dir first)
    CLONE = auto()
    # if the repo already exists, pull latest, else clone
    PULL_OR_CLONE = auto()
    # do nothing (useful if you want to use an existing repo in it&apos;s current state)
    SKIP = auto()
    # only initialize the repo
    INIT = auto()


class FetchResult(StrEnum):
    SUCCESS = &quot;SUCCESS&quot;
    REFSPEC_NOT_FOUND = &quot;REFSPEC_NOT_FOUND&quot;


class CheckoutResult(StrEnum):
    SUCCESS = &quot;SUCCESS&quot;
    NOT_FOUND = &quot;BRANCH_NOT_FOUND&quot;


class DiffChangeType(StrEnum):
    ADDED = &quot;A&quot;
    DELETED = &quot;D&quot;
    RENAMED = &quot;R&quot;
    MODIFIED = &quot;M&quot;


class RepoVisibility(StrEnum):
    PRIVATE = auto()
    PUBLIC = auto()
    INTERNAL = auto()</file><file path="src/codegen/git/schemas/repo_config.py">import os.path
from pathlib import Path

from pydantic import BaseModel

from codegen.configs.models.repository import RepositoryConfig
from codegen.git.schemas.enums import RepoVisibility
from codegen.shared.enums.programming_language import ProgrammingLanguage
from codegen.shared.logging.get_logger import get_logger

logger = get_logger(__name__)


class RepoConfig(BaseModel):
    &quot;&quot;&quot;All the information about the repo needed to build a codebase&quot;&quot;&quot;

    name: str
    full_name: str | None = None
    visibility: RepoVisibility | None = None

    # Codebase fields
    base_dir: str = &quot;/tmp&quot;  # parent directory of the git repo
    language: ProgrammingLanguage = ProgrammingLanguage.PYTHON
    respect_gitignore: bool = True
    base_path: str | None = None  # root directory of the codebase within the repo
    subdirectories: list[str] | None = None

    # Additional sandbox settings
    setup_commands: list[str] | None = None

    @classmethod
    def from_envs(cls) -&gt; &quot;RepoConfig&quot;:
        default_repo_config = RepositoryConfig()
        return RepoConfig(
            name=default_repo_config.name,
            full_name=default_repo_config.full_name,
            base_dir=os.path.dirname(default_repo_config.path),
            language=ProgrammingLanguage(default_repo_config.language.upper()),
        )

    @classmethod
    def from_repo_path(cls, repo_path: str, full_name: str | None = None) -&gt; &quot;RepoConfig&quot;:
        name = os.path.basename(repo_path)
        base_dir = os.path.dirname(repo_path)
        return cls(name=name, base_dir=base_dir, full_name=full_name)

    @property
    def repo_path(self) -&gt; Path:
        return Path(f&quot;{self.base_dir}/{self.name}&quot;)

    @property
    def organization_name(self) -&gt; str | None:
        if self.full_name is not None:
            return self.full_name.split(&quot;/&quot;)[0]

        return None</file><file path="src/codegen/git/utils/clone_url.py">from urllib.parse import urlparse

from codegen.git.schemas.repo_config import RepoConfig


# TODO: move out doesn&apos;t belong here
def url_to_github(url: str, branch: str) -&gt; str:
    clone_url = url.removesuffix(&quot;.git&quot;).replace(&quot;git@github.com:&quot;, &quot;github.com/&quot;)
    return f&quot;{clone_url}/blob/{branch}&quot;


def get_clone_url_for_repo_config(repo_config: RepoConfig) -&gt; str:
    return f&quot;https://github.com/{repo_config.full_name}.git&quot;


def get_authenticated_clone_url_for_repo_config(repo: RepoConfig, token: str) -&gt; str:
    git_url = get_clone_url_for_repo_config(repo)
    return add_access_token_to_url(git_url, token)


def add_access_token_to_url(url: str, token: str | None) -&gt; str:
    parsed_url = urlparse(url)
    scheme = parsed_url.scheme or &quot;https&quot;
    token_prefix = f&quot;x-access-token:{token}@&quot; if token else &quot;&quot;
    return f&quot;{scheme}://{token_prefix}{parsed_url.netloc}{parsed_url.path}&quot;</file><file path="src/codegen/git/utils/clone.py">import os
import subprocess

from git import Repo as GitRepo

from codegen.git.utils.remote_progress import CustomRemoteProgress
from codegen.shared.logging.get_logger import get_logger
from codegen.shared.performance.stopwatch_utils import subprocess_with_stopwatch

logger = get_logger(__name__)


# TODO: move into RepoOperator
def clone_repo(
    repo_path: str,
    clone_url: str,
    shallow: bool = True,
):
    &quot;&quot;&quot;TODO: re-use this code in clone_or_pull_repo. create separate pull_repo util&quot;&quot;&quot;
    if os.path.exists(repo_path) and os.listdir(repo_path):
        # NOTE: if someone calls the current working directory is the repo directory then we need to move up one level
        if os.getcwd() == os.path.realpath(repo_path):
            repo_parent_dir = os.path.dirname(repo_path)
            os.chdir(repo_parent_dir)
        delete_command = f&quot;rm -rf {repo_path}&quot;
        logger.info(f&quot;Deleting existing clone with command: {delete_command}&quot;)
        subprocess.run(delete_command, shell=True, capture_output=True)
    GitRepo.clone_from(url=clone_url, to_path=repo_path, depth=1 if shallow else None, progress=CustomRemoteProgress())
    return repo_path


# TODO: update to use GitPython instead + move into RepoOperator
def clone_or_pull_repo(
    repo_path: str,
    clone_url: str,
    shallow: bool = True,
):
    if os.path.exists(repo_path) and os.listdir(repo_path):
        logger.info(f&quot;{repo_path} directory already exists. Pulling instead of cloning ...&quot;)
        pull_repo(clone_url=clone_url, repo_path=repo_path)
    else:
        logger.info(f&quot;{repo_path} directory does not exist running git clone ...&quot;)
        clone_repo(repo_path=repo_path, clone_url=clone_url, shallow=shallow)
    return repo_path


# TODO: update to use GitPython instead + move into RepoOperator
def pull_repo(
    repo_path: str,
    clone_url: str,
) -&gt; None:
    if not os.path.exists(repo_path):
        logger.info(f&quot;{repo_path} directory does not exist. Unable to git pull.&quot;)
        return

    logger.info(f&quot;Refreshing token for repo at {repo_path} ...&quot;)
    subprocess.run(f&quot;git -C {repo_path} remote set-url origin {clone_url}&quot;, shell=True, capture_output=True)

    pull_command = f&quot;git -C {repo_path} pull {clone_url}&quot;
    logger.info(f&quot;Pulling with command: {pull_command} ...&quot;)
    subprocess_with_stopwatch(command=pull_command, command_desc=f&quot;pull {repo_path}&quot;, shell=True, capture_output=True)</file><file path="src/codegen/git/utils/codeowner_utils.py">from codeowners import CodeOwners
from github.PullRequest import PullRequest

from codegen.git.clients.git_repo_client import GitRepoClient
from codegen.git.configs.constants import CODEOWNERS_FILEPATHS
from codegen.shared.logging.get_logger import get_logger

logger = get_logger(__name__)


def get_filepath_owners(codeowners: CodeOwners, filepath: str) -&gt; set[str]:
    filename_owners = codeowners.of(filepath)
    return {owner[1] for owner in filename_owners}


def is_path_owned_by_codeowner(codeowners: CodeOwners, path: str, codeowner: str) -&gt; bool:
    filename_owners = codeowners.of(path)
    for owner in filename_owners:
        if owner[1] == codeowner:
            return True
    return False


def create_codeowners_parser_for_repo(py_github_repo: GitRepoClient) -&gt; CodeOwners | None:
    for codeowners_filepath in CODEOWNERS_FILEPATHS:
        try:
            codeowner_file_contents = py_github_repo.get_contents(codeowners_filepath)
            if codeowner_file_contents:
                codeowners = CodeOwners(codeowner_file_contents)
                return codeowners
        except Exception as e:
            continue
    logger.info(f&quot;Failed to create CODEOWNERS parser for repo: {py_github_repo.repo_config.name}. Returning None.&quot;)
    return None


def get_codeowners_for_pull(repo: GitRepoClient, pull: PullRequest) -&gt; list[str]:
    codeowners_parser = create_codeowners_parser_for_repo(repo)
    if not codeowners_parser:
        logger.warning(f&quot;Failed to create codeowners parser for repo: {repo.repo_config.name}. Returning empty list.&quot;)
        return []
    codeowners_for_pull_set = set()
    pull_files = pull.get_files()
    for file in pull_files:
        codeowners_for_file = codeowners_parser.of(file.filename)
        for codeowner_for_file in codeowners_for_file:
            codeowners_for_pull_set.add(codeowner_for_file[1])
    codeowners_for_pull_list = list(codeowners_for_pull_set)
    logger.info(f&quot;Pull: {pull.html_url} ({pull.title}) has codeowners: {codeowners_for_pull_list}&quot;)
    return codeowners_for_pull_list</file><file path="src/codegen/git/utils/file_utils.py">import os
from pathlib import Path


def create_file(file_path: str, content: str | bytes) -&gt; str:
    # Define the file path, name, and content
    filepath = os.path.dirname(file_path)
    filename = os.path.basename(file_path)
    content = content

    # Call the create_file function
    os.makedirs(filepath, exist_ok=True)

    # Create the full file path by joining the directory and filename
    file_path = os.path.join(filepath, filename)

    # Write the content to the file
    if isinstance(content, str):
        with open(file_path, &quot;w&quot;) as file:
            file.write(content)
    elif isinstance(content, bytes):
        with open(file_path, &quot;wb&quot;) as file:
            file.write(content)
    else:
        msg = f&quot;Invalid content type: {type(content)}&quot;
        raise ValueError(msg)

    # Check if the file was created
    file_path = os.path.join(filepath, filename)
    if not os.path.exists(file_path):
        msg = f&quot;Failed to create file {format(file_path)}&quot;
        raise FileNotFoundError(msg)
    return file_path


def create_files(base_dir: str, files: dict[str, str]) -&gt; None:
    for filename, content in files.items():
        create_file(os.path.join(base_dir, filename), content)


def split_git_path(filepath: str) -&gt; tuple[str, str | None]:
    &quot;&quot;&quot;Split a filepath into (git_root, base_path) tuple by finding .git directory.

    Args:
        filepath (str): The full path to split

    Returns:
        tuple: (git_root_path, relative_path)

    Raises:
        ValueError: If the path is not in a git repository
    &quot;&quot;&quot;
    # Convert to absolute path and resolve any symlinks
    path = Path(filepath).resolve()

    # Start from the given path and traverse up until we find .git
    current = path
    while current != current.parent:
        if (current / &quot;.git&quot;).exists():
            # Found the git root
            git_root = str(current)
            rel_path = str(path.relative_to(current))

            # Handle the case where filepath is the git root itself
            if rel_path == &quot;.&quot;:
                rel_path = None

            return (git_root, rel_path)
        current = current.parent

    # If we get here, we didn&apos;t find a .git directory
    msg = f&quot;Path &apos;{filepath}&apos; is not in a git repository!&quot;
    raise ValueError(msg)</file><file path="src/codegen/git/utils/format.py">from github.Comparison import Comparison


def format_comparison(comparison: Comparison, show_commits: bool = True) -&gt; str:
    diff_str_list = []

    for file in comparison.files:
        # Header for each file
        diff_str_list.append(f&quot;File: {file.filename}, Status: {file.status}&quot;)
        diff_str_list.append(f&quot;+++ {file.filename if file.status != &apos;removed&apos; else &apos;/dev/null&apos;}&quot;)
        diff_str_list.append(f&quot;--- {file.filename if file.status != &apos;added&apos; else &apos;/dev/null&apos;}&quot;)

        # Parsing the patch for each file
        if file.patch:
            for line in file.patch.split(&quot;\n&quot;):
                if line.startswith(&quot;+&quot;) or line.startswith(&quot;-&quot;):
                    diff_str_list.append(line)

    if show_commits:
        for commit in comparison.commits:
            # Commit information
            diff_str_list.append(f&quot;Commit: {commit.sha}, Author: {commit.commit.author.name}, Message: {commit.commit.message}&quot;)

    return &quot;\n&quot;.join(diff_str_list)</file><file path="src/codegen/git/utils/language.py">from collections import Counter
from pathlib import Path
from typing import Literal

from codegen.git.utils.file_utils import split_git_path
from codegen.shared.enums.programming_language import ProgrammingLanguage
from codegen.shared.logging.get_logger import get_logger

logger = get_logger(__name__)

# Minimum ratio of files that must match the dominant language
MIN_LANGUAGE_RATIO = 0.1


def determine_project_language(folder_path: str, strategy: Literal[&quot;most_common&quot;, &quot;git_most_common&quot;, &quot;package_json&quot;] = &quot;git_most_common&quot;) -&gt; ProgrammingLanguage:
    &quot;&quot;&quot;Determines the primary programming language of a project.

    Args:
        folder_path (str): Path to the folder to analyze
        strategy (Literal[&quot;most_common&quot;, &quot;git_most_common&quot;, &quot;package_json&quot;]): Strategy to use for determining language.
            &quot;most_common&quot; analyzes file extensions, &quot;git_most_common&quot; analyzes files in the git repo, &quot;package_json&quot; checks for package.json presence.

    Returns:
        ProgrammingLanguage: The determined programming language
    &quot;&quot;&quot;
    # TODO: Create a new strategy that follows gitignore
    if strategy == &quot;most_common&quot;:
        return _determine_language_by_file_count(folder_path)
    elif strategy == &quot;git_most_common&quot;:
        return _determine_language_by_git_file_count(folder_path)
    elif strategy == &quot;package_json&quot;:
        return _determine_language_by_package_json(folder_path)
    else:
        msg = f&quot;Invalid strategy: {strategy}&quot;
        raise ValueError(msg)


def _determine_language_by_file_count(folder_path: str) -&gt; ProgrammingLanguage:
    &quot;&quot;&quot;Analyzes a folder to determine the primary programming language based on file extensions.
    Returns the language with the most matching files.

    Args:
        folder_path (str): Path to the folder to analyze

    Returns:
        ProgrammingLanguage: The dominant programming language, or OTHER if no matching files found
        or if less than MIN_LANGUAGE_RATIO of files match the dominant language
    &quot;&quot;&quot;
    from codegen.sdk.python import PyFile
    from codegen.sdk.typescript.file import TSFile

    EXTENSIONS = {
        ProgrammingLanguage.PYTHON: PyFile.get_extensions(),
        ProgrammingLanguage.TYPESCRIPT: TSFile.get_extensions(),
    }

    folder = Path(folder_path)
    if not folder.exists() or not folder.is_dir():
        msg = f&quot;Invalid folder path: {folder_path}&quot;
        raise ValueError(msg)

    # Initialize counters for each language
    language_counts = Counter()
    total_files = 0

    # Walk through the directory
    for file_path in folder.rglob(&quot;*&quot;):
        # Skip directories and hidden files
        if file_path.is_dir() or file_path.name.startswith(&quot;.&quot;):
            continue

        # Skip common directories to ignore
        if any(ignore in str(file_path) for ignore in [&quot;.git&quot;, &quot;node_modules&quot;, &quot;__pycache__&quot;, &quot;venv&quot;, &quot;.env&quot;]):
            continue

        total_files += 1

        # Count files for each language based on extensions
        for language, exts in EXTENSIONS.items():
            if file_path.suffix in exts:
                language_counts[language] += 1

    # If no files found, return None
    if not language_counts:
        return ProgrammingLanguage.OTHER

    # Get the most common language and its count
    most_common_language, count = language_counts.most_common(1)[0]

    logger.debug(f&quot;Most common language: {most_common_language}, count: {count}, total files: {total_files}&quot;)

    # Check if the most common language makes up at least MIN_LANGUAGE_RATIO of all files
    if total_files &gt; 0 and (count / total_files) &lt; MIN_LANGUAGE_RATIO:
        return ProgrammingLanguage.OTHER

    return most_common_language


def _determine_language_by_git_file_count(folder_path: str) -&gt; ProgrammingLanguage:
    &quot;&quot;&quot;Analyzes a git repo to determine the primary programming language based on file extensions.
    Returns the language with the most matching files.

    Args:
        folder_path (str): Path to the git repo to analyze

    Returns:
        ProgrammingLanguage: The dominant programming language, or OTHER if no matching files found
        or if less than MIN_LANGUAGE_RATIO of files match the dominant language
    &quot;&quot;&quot;
    from codegen.git.repo_operator.repo_operator import RepoOperator
    from codegen.git.schemas.repo_config import RepoConfig
    from codegen.sdk.codebase.codebase_context import GLOBAL_FILE_IGNORE_LIST
    from codegen.sdk.python import PyFile
    from codegen.sdk.typescript.file import TSFile

    EXTENSIONS = {
        ProgrammingLanguage.PYTHON: PyFile.get_extensions(),
        ProgrammingLanguage.TYPESCRIPT: TSFile.get_extensions(),
    }

    folder = Path(folder_path)
    if not folder.exists() or not folder.is_dir():
        msg = f&quot;Invalid folder path: {folder_path}&quot;
        raise ValueError(msg)

    # Initialize counters for each language
    language_counts = Counter()
    total_files = 0

    # Initiate RepoOperator
    git_root, base_path = split_git_path(folder_path)
    repo_config = RepoConfig.from_repo_path(repo_path=git_root)
    repo_operator = RepoOperator(repo_config=repo_config)

    # Walk through the directory
    for rel_path, _ in repo_operator.iter_files(subdirs=[base_path] if base_path else None, ignore_list=GLOBAL_FILE_IGNORE_LIST):
        # Convert to Path object
        file_path = Path(git_root) / Path(rel_path)

        # Skip directories and hidden files
        if file_path.is_dir() or file_path.name.startswith(&quot;.&quot;):
            continue

        total_files += 1

        # Count files for each language based on extensions
        for language, exts in EXTENSIONS.items():
            if file_path.suffix in exts:
                language_counts[language] += 1

    # If no files found, return None
    if not language_counts:
        return ProgrammingLanguage.OTHER

    # Get the most common language and its count
    most_common_language, count = language_counts.most_common(1)[0]

    logger.debug(f&quot;Most common language: {most_common_language}, count: {count}, total files: {total_files}&quot;)

    # Check if the most common language makes up at least MIN_LANGUAGE_RATIO of all files
    if total_files &gt; 0 and (count / total_files) &lt; MIN_LANGUAGE_RATIO:
        return ProgrammingLanguage.OTHER

    return most_common_language


def _determine_language_by_package_json(folder_path: str) -&gt; ProgrammingLanguage:
    &quot;&quot;&quot;Determines project language by checking for presence of package.json.
    Faster but less accurate than file count strategy.

    Args:
        folder_path (str): Path to the folder to analyze

    Returns:
        ProgrammingLanguage: TYPESCRIPT if package.json exists, otherwise PYTHON
    &quot;&quot;&quot;
    package_json_path = Path(folder_path) / &quot;package.json&quot;
    if package_json_path.exists():
        logger.debug(f&quot;Found package.json at {package_json_path}&quot;)
        return ProgrammingLanguage.TYPESCRIPT
    else:
        logger.debug(f&quot;No package.json found at {package_json_path}&quot;)
        return ProgrammingLanguage.PYTHON</file><file path="src/codegen/git/utils/pr_review.py">from typing import TYPE_CHECKING

from github import Repository
from github.PullRequest import PullRequest
from unidiff import PatchSet

from codegen.git.models.pull_request_context import PullRequestContext
from codegen.git.repo_operator.repo_operator import RepoOperator

if TYPE_CHECKING:
    from codegen.sdk.core.codebase import Codebase, Editable, File


def get_merge_base(git_repo_client: Repository, pull: PullRequest | PullRequestContext) -&gt; str:
    &quot;&quot;&quot;Gets the merge base of a pull request using a remote GitHub API client.

    Args:
        git_repo_client (GitRepoClient): The GitHub repository client.
        pull (PullRequest): The pull request object.

    Returns:
        str: The SHA of the merge base commit.
    &quot;&quot;&quot;
    comparison = git_repo_client.compare(pull.base.sha, pull.head.sha)
    return comparison.merge_base_commit.sha


def get_file_to_changed_ranges(pull_patch_set: PatchSet) -&gt; dict[str, list]:
    file_to_changed_ranges = {}
    for patched_file in pull_patch_set:
        # TODO: skip is deleted
        if patched_file.is_removed_file:
            continue
        changed_ranges = []  # list of changed lines for the file
        for hunk in patched_file:
            changed_ranges.append(range(hunk.target_start, hunk.target_start + hunk.target_length))
        file_to_changed_ranges[patched_file.path] = changed_ranges
    return file_to_changed_ranges


def to_1_indexed(zero_indexed_range: range) -&gt; range:
    &quot;&quot;&quot;Converts a n-indexed range to n+1-indexed.
    Primarily to convert 0-indexed ranges to 1 indexed
    &quot;&quot;&quot;
    return range(zero_indexed_range.start + 1, zero_indexed_range.stop + 1)


def overlaps(range1: range, range2: range) -&gt; bool:
    &quot;&quot;&quot;Returns True if the two ranges overlap, False otherwise.&quot;&quot;&quot;
    return max(range1.start, range2.start) &lt; min(range1.stop, range2.stop)


def get_file_to_commit_sha(op: RepoOperator, pull: PullRequest) -&gt; dict[str, str]:
    &quot;&quot;&quot;Gets a mapping of file paths to their latest commit SHA in the PR.

    Args:
        op (RepoOperator): The repository operator
        pull (PullRequest): The pull request object

    Returns:
        dict[str, str]: A dictionary mapping file paths to their latest commit SHA
    &quot;&quot;&quot;
    if not op.remote_git_repo:
        msg = &quot;GitHub API client is required to get PR commit information&quot;
        raise ValueError(msg)

    file_to_commit = {}

    # Get all commits in the PR
    commits = list(pull.get_commits())

    # Get all modified files
    files = pull.get_files()

    # For each file, find its latest commit
    for file in files:
        # Look through commits in reverse order to find the latest one that modified this file
        for commit in reversed(commits):
            # Get the files modified in this commit
            files_in_commit = commit.files
            if any(f.filename == file.filename for f in files_in_commit):
                file_to_commit[file.filename] = commit.sha
                break

        # If we didn&apos;t find a commit (shouldn&apos;t happen), use the head SHA
        if file.filename not in file_to_commit:
            file_to_commit[file.filename] = pull.head.sha

    return file_to_commit


class CodegenPR:
    &quot;&quot;&quot;Wrapper around PRs - enables codemods to interact with them&quot;&quot;&quot;

    _gh_pr: PullRequest
    _codebase: &quot;Codebase&quot;
    _op: RepoOperator

    # =====[ Computed ]=====
    _modified_file_ranges: dict[str, list[tuple[int, int]]] = None

    def __init__(self, op: RepoOperator, codebase: &quot;Codebase&quot;, pr: PullRequest):
        self._op = op
        self._gh_pr = pr
        self._codebase = codebase

    @property
    def modified_file_ranges(self) -&gt; dict[str, list[tuple[int, int]]]:
        &quot;&quot;&quot;Files and the ranges within that are modified&quot;&quot;&quot;
        if not self._modified_file_ranges:
            pull_patch_set = self.get_pull_patch_set()
            self._modified_file_ranges = get_file_to_changed_ranges(pull_patch_set)
        return self._modified_file_ranges

    @property
    def modified_files(self) -&gt; list[&quot;File&quot;]:
        filenames = self.modified_file_ranges.keys()
        return [self._codebase.get_file(f, optional=True) for f in filenames]

    def is_modified(self, editable: &quot;Editable&quot;) -&gt; bool:
        &quot;&quot;&quot;Returns True if the Editable&apos;s range contains any modified lines&quot;&quot;&quot;
        filepath = editable.filepath
        changed_ranges = self._modified_file_ranges.get(filepath, [])
        symbol_range = to_1_indexed(editable.line_range)
        if any(overlaps(symbol_range, changed_range) for changed_range in changed_ranges):
            return True
        return False

    @property
    def modified_symbols(self) -&gt; list[str]:
        # Import SourceFile locally to avoid circular dependencies
        from codegen.sdk.core.file import SourceFile

        all_modified = []
        for file in self.modified_files:
            if file is None:
                print(&quot;Warning: File is None&quot;)
                continue
            if not isinstance(file, SourceFile):
                continue
            for symbol in file.symbols:
                if self.is_modified(symbol):
                    all_modified.append(symbol.name)

        return all_modified

    def get_pr_diff(self) -&gt; str:
        &quot;&quot;&quot;Get the full diff of the PR&quot;&quot;&quot;
        if not self._op.remote_git_repo:
            msg = &quot;GitHub API client is required to get PR diffs&quot;
            raise ValueError(msg)

        # Get the diff directly from the PR
        status, _, res = self._op.remote_git_repo.repo._requester.requestJson(&quot;GET&quot;, self._gh_pr.url, headers={&quot;Accept&quot;: &quot;application/vnd.github.v3.diff&quot;})
        if status != 200:
            msg = f&quot;Failed to get PR diff: {res}&quot;
            raise Exception(msg)
        return res

    def get_pull_patch_set(self) -&gt; PatchSet:
        diff = self.get_pr_diff()
        pull_patch_set = PatchSet(diff)
        return pull_patch_set

    def get_commit_sha(self) -&gt; str:
        &quot;&quot;&quot;Get the commit SHA of the PR&quot;&quot;&quot;
        return self._gh_pr.head.sha

    def get_file_commit_shas(self) -&gt; dict[str, str]:
        &quot;&quot;&quot;Get a mapping of file paths to their latest commit SHA in the PR&quot;&quot;&quot;
        return get_file_to_commit_sha(op=self._op, pull=self._gh_pr)</file><file path="src/codegen/git/utils/remote_progress.py">import time

from git import RemoteProgress

from codegen.git.schemas.enums import FetchResult
from codegen.shared.logging.get_logger import get_logger

logger = get_logger(__name__)


class CustomRemoteProgress(RemoteProgress):
    fetch_result: FetchResult | None = None
    last_line_time: float | None = None

    def _parse_progress_line(self, line) -&gt; None:
        self.line_dropped(line)
        if &quot;fatal: couldn&apos;t find remote ref&quot; in line:
            self.fetch_result = FetchResult.REFSPEC_NOT_FOUND

    def line_dropped(self, line) -&gt; None:
        if self.last_line_time is None or time.time() - self.last_line_time &gt; 1:
            logger.info(line)
            self.last_line_time = time.time()

    def update(
        self,
        op_code: int,
        cur_count: str | float,
        max_count: str | float | None = None,
        message: str = &quot;&quot;,
    ) -&gt; None:
        logger.info(f&quot;message: {message} op_code: {op_code} cur_count: {cur_count} max_count: {max_count}&quot;)</file><file path="src/codegen/git/README.md"># Codegen Git

A codegen module to supports git operations on codebase.

### Dependencies

- [codegen.sdk](https://github.com/codegen-sh/codegen-sdk/tree/develop/src/codegen/sdk)
- [codegen.shared](https://github.com/codegen-sh/codegen-sdk/tree/develop/src/codegen/shared)</file><file path="src/codegen/shared/compilation/codeblock_validation.py">import re

from codegen.shared.exceptions.compilation import DangerousUserCodeException


def check_for_dangerous_operations(user_code: str) -&gt; None:
    &quot;&quot;&quot;If codeblock has dangerous operations (ex: exec, os.environ, etc) then raise an error and prevent the user from executing it.&quot;&quot;&quot;
    dangerous_operation_patterns = [
        r&quot;\b(os\.environ|locals|globals)\b&quot;,  # Environment variables and scope access
    ]
    pattern = &quot;|&quot;.join(dangerous_operation_patterns)
    if re.search(pattern, user_code, re.IGNORECASE):
        msg = &quot;The codeblock contains potentially dangerous operations that are not allowed.&quot;
        raise DangerousUserCodeException(msg)</file><file path="src/codegen/shared/compilation/exception_utils.py">from types import FrameType, TracebackType

from codegen.shared.logging.get_logger import get_logger

logger = get_logger(__name__)


def get_offset_traceback(tb_lines: list[str], line_offset: int = 0, filenameFilter: str = &quot;&lt;string&gt;&quot;) -&gt; str:
    &quot;&quot;&quot;Generate a traceback string with offset line numbers.

    :param tb_lines: lines output for the traceback
    :param line_offset: Number of lines to offset the traceback
    :return: A string containing the offset traceback
    &quot;&quot;&quot;
    # Process each line of the traceback
    offset_tb_lines = []
    for line in tb_lines:
        if line.lstrip().startswith(&quot;File&quot;):
            if line.lstrip().startswith(f&apos;File &quot;{filenameFilter}&quot;&apos;) and &quot;execute&quot; not in line:
                # This line contains file and line number information
                parts = line.split(&quot;, line &quot;)
                if len(parts) &gt; 1:
                    # Offset the line number
                    line_num = int(parts[1].split(&quot;,&quot;)[0])
                    new_line_num = line_num - line_offset
                    line = f&quot;{parts[0]}, line {new_line_num}{&apos;,&apos;.join(parts[1].split(&apos;,&apos;)[1:])}&quot;
                offset_tb_lines.append(line)
        else:
            offset_tb_lines.append(line)

    # Join the processed lines back into a single string
    return &quot;&quot;.join(offset_tb_lines)


def get_local_frame(exc_type: type[BaseException], exc_value: BaseException, exc_traceback: TracebackType) -&gt; FrameType | None:
    LOCAL_FILENAME = &quot;&lt;string&gt;&quot;
    LOCAL_MODULE_DIR = &quot;codegen-backend/app/&quot;
    tb = exc_traceback
    while tb and ((tb.tb_next and tb.tb_frame.f_code.co_filename != LOCAL_FILENAME) or LOCAL_MODULE_DIR in tb.tb_frame.f_code.co_filename):
        tb = tb.tb_next

    frame = tb.tb_frame if tb else None
    return frame


def get_local_frame_context(frame: FrameType):
    local_vars = {k: v for k, v in frame.f_locals.items() if not k.startswith(&quot;__&quot;)}
    local_vars.pop(&quot;print&quot;, None)
    local_vars.pop(&quot;codebase&quot;, None)
    local_vars.pop(&quot;pr_options&quot;, None)
    return local_vars</file><file path="src/codegen/shared/compilation/function_compilation.py">import linecache
import sys
import traceback
from collections.abc import Callable

from codegen.shared.exceptions.compilation import InvalidUserCodeException
from codegen.shared.logging.get_logger import get_logger

logger = get_logger(__name__)


def get_compilation_error_context(filename: str, line_number: int, window_size: int = 2):
    &quot;&quot;&quot;Get lines of context around SyntaxError + Exceptions that occur when compiling functions.&quot;&quot;&quot;
    start = max(1, line_number - window_size)
    end = line_number + window_size + 1
    lines = []
    for i in range(start, end):
        line = linecache.getline(filename, i).rstrip()
        if line:
            lines.append((i, line))
    return lines


def safe_compile_function_string(custom_scope: dict, func_name: str, func_str: str) -&gt; Callable:
    # =====[ Add function string to linecache ]=====
    # (This is necessary for the traceback to work correctly)
    linecache.cache[&quot;&lt;string&gt;&quot;] = (len(func_str), None, func_str.splitlines(True), &quot;&lt;string&gt;&quot;)

    # =====[ Compile &amp; exec the code ]=====
    # This will throw errors if there is invalid syntax
    try:
        # First, try to compile the code to catch syntax errors
        logger.info(f&quot;Compiling function: {func_name} ...&quot;)
        compiled_code = compile(func_str, &quot;&lt;string&gt;&quot;, &quot;exec&quot;)
        # If compilation succeeds, try to execute the code
        logger.info(f&quot;Compilation succeeded. exec-ing function: {func_name} ...&quot;)
        exec(compiled_code, custom_scope, custom_scope)

    # =====[ Catch SyntaxErrors ]=====
    except SyntaxError as e:
        error_class = e.__class__.__name__
        detail = e.args[0]
        line_number = e.lineno
        context_lines = get_compilation_error_context(&quot;&lt;string&gt;&quot;, line_number)
        context_str = &quot;\n&quot;.join(f&quot;{&apos;&gt;&apos; if i == line_number else &apos; &apos;} {i}: {line}&quot; for i, line in context_lines)
        error_line = linecache.getline(&quot;&lt;string&gt;&quot;, line_number).strip()
        caret_line = &quot; &quot; * (e.offset - 1) + &quot;^&quot; * (len(error_line) - e.offset + 1)
        error_message = f&quot;{error_class} at line {line_number}: {detail}\n    {error_line}\n    {caret_line}\n{context_str}&quot;
        raise InvalidUserCodeException(error_message) from e

    # =====[ All other Exceptions ]=====
    except Exception as e:
        error_class = e.__class__.__name__
        detail = str(e)
        _, _, tb = sys.exc_info()
        line_number = traceback.extract_tb(tb)[-1].lineno
        context_lines = get_compilation_error_context(&quot;&lt;string&gt;&quot;, line_number)
        context_str = &quot;\n&quot;.join(f&quot;{&apos;&gt;&apos; if i == line_number else &apos; &apos;} {i}: {line}&quot; for i, line in context_lines)
        error_line = linecache.getline(&quot;&lt;string&gt;&quot;, line_number).strip()
        error_message = f&quot;{error_class} at line {line_number}: {detail}\n    {error_line}\n{context_str}&quot;
        raise InvalidUserCodeException(error_message) from e

    finally:
        # Clear the cache to free up memory
        linecache.clearcache()

    return custom_scope.get(func_name)</file><file path="src/codegen/shared/compilation/function_construction.py">import re

from codegen.shared.compilation.function_imports import get_generated_imports
from codegen.shared.logging.get_logger import get_logger

logger = get_logger(__name__)


def create_function_str_from_codeblock(codeblock: str, func_name: str) -&gt; str:
    &quot;&quot;&quot;Creates a function string from a codeblock.&quot;&quot;&quot;
    # =====[ Make an `execute` function string w/ imports ]=====
    func_str = wrap_codeblock_in_function(codeblock, func_name)

    # =====[ Add imports to the top ]=====
    func_str = get_imports_string().format(func_str=func_str)
    return func_str


def wrap_codeblock_in_function(codeblock: str, func_name: str) -&gt; str:
    &quot;&quot;&quot;Wrap a codeblock in a function with the specified name.

    Args:
        codeblock (str): The code to be wrapped in a function.
        func_name (str): The name to give the wrapping function.

    Note:
        Skip wrapping if a function with the specified name already exists in the codeblock.
    &quot;&quot;&quot;
    if re.search(rf&quot;\bdef\s+{func_name}\s*\(&quot;, codeblock):
        logger.info(f&quot;Codeblock already has a function named {func_name}. Skipping wrap.&quot;)
        return codeblock

    # If not function func_name does not already exist, create a new function with the codeblock inside
    user_code = indent_user_code(codeblock)
    codeblock = f&quot;&quot;&quot;
def {func_name}(codebase: Codebase, pr_options: PROptions | None = None, pr = None, **kwargs):
    print = codebase.log
{user_code}
    &quot;&quot;&quot;
    return codeblock


def indent_user_code(codeblock: str) -&gt; str:
    return &quot;\n&quot;.join(f&quot;    {line}&quot; for line in codeblock.strip().split(&quot;\n&quot;))


def get_imports_string():
    &quot;&quot;&quot;Gets imports marked with apidoc decorators. This list is autogenerated by generate_runner_imports&quot;&quot;&quot;
    imports_str = get_generated_imports()

    func_str_template = &quot;&quot;&quot;

{func_str}
&quot;&quot;&quot;
    return imports_str + func_str_template</file><file path="src/codegen/shared/compilation/function_imports.py"># This file is auto-generated, do not modify manually. Edit this in src/codegen/gscli/generate/runner_imports.py.
def get_generated_imports():
    return &quot;&quot;&quot;
# External imports
import os
import re
from pathlib import Path
import networkx as nx
import plotly

# GraphSitter imports (private)

from codegen.git.models.codemod_context import CodemodContext
from codegen.git.models.github_named_user_context import GithubNamedUserContext
from codegen.git.models.pr_options import PROptions
from codegen.git.models.pr_part_context import PRPartContext
from codegen.git.models.pull_request_context import PullRequestContext

from codegen.shared.exceptions.control_flow import StopCodemodException

# GraphSitter imports (public)
from codegen.sdk.codebase.flagging.enums import FlagKwargs
from codegen.sdk.codebase.flagging.enums import MessageType
from codegen.sdk.codebase.span import Span
from codegen.sdk.core.assignment import Assignment
from codegen.sdk.core.class_definition import Class
from codegen.sdk.core.codebase import Codebase
from codegen.sdk.core.codebase import CodebaseType
from codegen.sdk.core.codebase import PyCodebaseType
from codegen.sdk.core.codebase import TSCodebaseType
from codegen.sdk.core.codeowner import CodeOwner
from codegen.sdk.core.dataclasses.usage import Usage
from codegen.sdk.core.dataclasses.usage import UsageKind
from codegen.sdk.core.dataclasses.usage import UsageType
from codegen.sdk.core.detached_symbols.argument import Argument
from codegen.sdk.core.detached_symbols.code_block import CodeBlock
from codegen.sdk.core.detached_symbols.decorator import Decorator
from codegen.sdk.core.detached_symbols.function_call import FunctionCall
from codegen.sdk.core.detached_symbols.parameter import Parameter
from codegen.sdk.core.directory import Directory
from codegen.sdk.core.export import Export
from codegen.sdk.core.expressions.await_expression import AwaitExpression
from codegen.sdk.core.expressions.binary_expression import BinaryExpression
from codegen.sdk.core.expressions.boolean import Boolean
from codegen.sdk.core.expressions.chained_attribute import ChainedAttribute
from codegen.sdk.core.expressions.comparison_expression import ComparisonExpression
from codegen.sdk.core.expressions.expression import Expression
from codegen.sdk.core.expressions.generic_type import GenericType
from codegen.sdk.core.expressions.multi_expression import MultiExpression
from codegen.sdk.core.expressions.name import Name
from codegen.sdk.core.expressions.named_type import NamedType
from codegen.sdk.core.expressions.none_type import NoneType
from codegen.sdk.core.expressions.number import Number
from codegen.sdk.core.expressions.parenthesized_expression import ParenthesizedExpression
from codegen.sdk.core.expressions.placeholder_type import PlaceholderType
from codegen.sdk.core.expressions.string import String
from codegen.sdk.core.expressions.subscript_expression import SubscriptExpression
from codegen.sdk.core.expressions.ternary_expression import TernaryExpression
from codegen.sdk.core.expressions.tuple_type import TupleType
from codegen.sdk.core.expressions.type import Type
from codegen.sdk.core.expressions.unary_expression import UnaryExpression
from codegen.sdk.core.expressions.union_type import UnionType
from codegen.sdk.core.expressions.unpack import Unpack
from codegen.sdk.core.expressions.value import Value
from codegen.sdk.core.external_module import ExternalModule
from codegen.sdk.core.file import File
from codegen.sdk.core.file import SourceFile
from codegen.sdk.core.function import Function
from codegen.sdk.core.import_resolution import Import
from codegen.sdk.core.interface import Interface
from codegen.sdk.core.interfaces.callable import Callable
from codegen.sdk.core.interfaces.editable import Editable
from codegen.sdk.core.interfaces.exportable import Exportable
from codegen.sdk.core.interfaces.has_block import HasBlock
from codegen.sdk.core.interfaces.has_name import HasName
from codegen.sdk.core.interfaces.has_value import HasValue
from codegen.sdk.core.interfaces.importable import Importable
from codegen.sdk.core.interfaces.typeable import Typeable
from codegen.sdk.core.interfaces.unwrappable import Unwrappable
from codegen.sdk.core.interfaces.usable import Usable
from codegen.sdk.core.placeholder.placeholder import Placeholder
from codegen.sdk.core.placeholder.placeholder_stub import StubPlaceholder
from codegen.sdk.core.placeholder.placeholder_type import TypePlaceholder
from codegen.sdk.core.statements.assignment_statement import AssignmentStatement
from codegen.sdk.core.statements.attribute import Attribute
from codegen.sdk.core.statements.block_statement import BlockStatement
from codegen.sdk.core.statements.catch_statement import CatchStatement
from codegen.sdk.core.statements.comment import Comment
from codegen.sdk.core.statements.export_statement import ExportStatement
from codegen.sdk.core.statements.expression_statement import ExpressionStatement
from codegen.sdk.core.statements.for_loop_statement import ForLoopStatement
from codegen.sdk.core.statements.if_block_statement import IfBlockStatement
from codegen.sdk.core.statements.import_statement import ImportStatement
from codegen.sdk.core.statements.raise_statement import RaiseStatement
from codegen.sdk.core.statements.return_statement import ReturnStatement
from codegen.sdk.core.statements.statement import Statement
from codegen.sdk.core.statements.statement import StatementType
from codegen.sdk.core.statements.switch_case import SwitchCase
from codegen.sdk.core.statements.switch_statement import SwitchStatement
from codegen.sdk.core.statements.symbol_statement import SymbolStatement
from codegen.sdk.core.statements.try_catch_statement import TryCatchStatement
from codegen.sdk.core.statements.while_statement import WhileStatement
from codegen.sdk.core.symbol import Symbol
from codegen.sdk.core.symbol_group import SymbolGroup
from codegen.sdk.core.symbol_groups.comment_group import CommentGroup
from codegen.sdk.core.symbol_groups.dict import Dict
from codegen.sdk.core.symbol_groups.dict import Pair
from codegen.sdk.core.symbol_groups.expression_group import ExpressionGroup
from codegen.sdk.core.symbol_groups.list import List
from codegen.sdk.core.symbol_groups.multi_line_collection import MultiLineCollection
from codegen.sdk.core.symbol_groups.tuple import Tuple
from codegen.sdk.core.type_alias import TypeAlias
from codegen.sdk.enums import ImportType
from codegen.sdk.python.assignment import PyAssignment
from codegen.sdk.python.class_definition import PyClass
from codegen.sdk.python.detached_symbols.code_block import PyCodeBlock
from codegen.sdk.python.detached_symbols.decorator import PyDecorator
from codegen.sdk.python.detached_symbols.parameter import PyParameter
from codegen.sdk.python.expressions.chained_attribute import PyChainedAttribute
from codegen.sdk.python.expressions.conditional_expression import PyConditionalExpression
from codegen.sdk.python.expressions.generic_type import PyGenericType
from codegen.sdk.python.expressions.named_type import PyNamedType
from codegen.sdk.python.expressions.string import PyString
from codegen.sdk.python.expressions.union_type import PyUnionType
from codegen.sdk.python.file import PyFile
from codegen.sdk.python.function import PyFunction
from codegen.sdk.python.import_resolution import PyImport
from codegen.sdk.python.interfaces.has_block import PyHasBlock
from codegen.sdk.python.placeholder.placeholder_return_type import PyReturnTypePlaceholder
from codegen.sdk.python.statements.assignment_statement import PyAssignmentStatement
from codegen.sdk.python.statements.attribute import PyAttribute
from codegen.sdk.python.statements.block_statement import PyBlockStatement
from codegen.sdk.python.statements.break_statement import PyBreakStatement
from codegen.sdk.python.statements.catch_statement import PyCatchStatement
from codegen.sdk.python.statements.comment import PyComment
from codegen.sdk.python.statements.comment import PyCommentType
from codegen.sdk.python.statements.for_loop_statement import PyForLoopStatement
from codegen.sdk.python.statements.if_block_statement import PyIfBlockStatement
from codegen.sdk.python.statements.import_statement import PyImportStatement
from codegen.sdk.python.statements.match_case import PyMatchCase
from codegen.sdk.python.statements.match_statement import PyMatchStatement
from codegen.sdk.python.statements.pass_statement import PyPassStatement
from codegen.sdk.python.statements.try_catch_statement import PyTryCatchStatement
from codegen.sdk.python.statements.while_statement import PyWhileStatement
from codegen.sdk.python.statements.with_statement import WithStatement
from codegen.sdk.python.symbol import PySymbol
from codegen.sdk.python.symbol_groups.comment_group import PyCommentGroup
from codegen.sdk.typescript.assignment import TSAssignment
from codegen.sdk.typescript.class_definition import TSClass
from codegen.sdk.typescript.detached_symbols.code_block import TSCodeBlock
from codegen.sdk.typescript.detached_symbols.decorator import TSDecorator
from codegen.sdk.typescript.detached_symbols.jsx.element import JSXElement
from codegen.sdk.typescript.detached_symbols.jsx.expression import JSXExpression
from codegen.sdk.typescript.detached_symbols.jsx.prop import JSXProp
from codegen.sdk.typescript.detached_symbols.parameter import TSParameter
from codegen.sdk.typescript.enum_definition import TSEnum
from codegen.sdk.typescript.export import TSExport
from codegen.sdk.typescript.expressions.array_type import TSArrayType
from codegen.sdk.typescript.expressions.chained_attribute import TSChainedAttribute
from codegen.sdk.typescript.expressions.conditional_type import TSConditionalType
from codegen.sdk.typescript.expressions.expression_type import TSExpressionType
from codegen.sdk.typescript.expressions.function_type import TSFunctionType
from codegen.sdk.typescript.expressions.generic_type import TSGenericType
from codegen.sdk.typescript.expressions.lookup_type import TSLookupType
from codegen.sdk.typescript.expressions.named_type import TSNamedType
from codegen.sdk.typescript.expressions.object_type import TSObjectType
from codegen.sdk.typescript.expressions.query_type import TSQueryType
from codegen.sdk.typescript.expressions.readonly_type import TSReadonlyType
from codegen.sdk.typescript.expressions.string import TSString
from codegen.sdk.typescript.expressions.ternary_expression import TSTernaryExpression
from codegen.sdk.typescript.expressions.undefined_type import TSUndefinedType
from codegen.sdk.typescript.expressions.union_type import TSUnionType
from codegen.sdk.typescript.file import TSFile
from codegen.sdk.typescript.function import TSFunction
from codegen.sdk.typescript.import_resolution import TSImport
from codegen.sdk.typescript.interface import TSInterface
from codegen.sdk.typescript.interfaces.has_block import TSHasBlock
from codegen.sdk.typescript.namespace import TSNamespace
from codegen.sdk.typescript.placeholder.placeholder_return_type import TSReturnTypePlaceholder
from codegen.sdk.typescript.statements.assignment_statement import TSAssignmentStatement
from codegen.sdk.typescript.statements.attribute import TSAttribute
from codegen.sdk.typescript.statements.block_statement import TSBlockStatement
from codegen.sdk.typescript.statements.catch_statement import TSCatchStatement
from codegen.sdk.typescript.statements.comment import TSComment
from codegen.sdk.typescript.statements.comment import TSCommentType
from codegen.sdk.typescript.statements.for_loop_statement import TSForLoopStatement
from codegen.sdk.typescript.statements.if_block_statement import TSIfBlockStatement
from codegen.sdk.typescript.statements.import_statement import TSImportStatement
from codegen.sdk.typescript.statements.labeled_statement import TSLabeledStatement
from codegen.sdk.typescript.statements.switch_case import TSSwitchCase
from codegen.sdk.typescript.statements.switch_statement import TSSwitchStatement
from codegen.sdk.typescript.statements.try_catch_statement import TSTryCatchStatement
from codegen.sdk.typescript.statements.while_statement import TSWhileStatement
from codegen.sdk.typescript.symbol import TSSymbol
from codegen.sdk.typescript.symbol_groups.comment_group import TSCommentGroup
from codegen.sdk.typescript.symbol_groups.dict import TSDict
from codegen.sdk.typescript.symbol_groups.dict import TSPair
from codegen.sdk.typescript.ts_config import TSConfig
from codegen.sdk.typescript.type_alias import TSTypeAlias
&quot;&quot;&quot;</file><file path="src/codegen/shared/compilation/README.md">Utils around compiling a user&apos;s codeblock into a function.

This includes:

- Raising on any dangerous operations in the codeblock
- Catching and logging any compilation errors
- Monkey patching built-ins like print
- etc</file><file path="src/codegen/shared/compilation/string_to_code.py">import linecache
import sys
import traceback
from collections.abc import Callable
from typing import Any

from codegen.shared.compilation.codeblock_validation import check_for_dangerous_operations
from codegen.shared.compilation.exception_utils import get_local_frame, get_offset_traceback
from codegen.shared.compilation.function_compilation import safe_compile_function_string
from codegen.shared.compilation.function_construction import create_function_str_from_codeblock, get_imports_string
from codegen.shared.exceptions.control_flow import StopCodemodException
from codegen.shared.logging.get_logger import get_logger

logger = get_logger(__name__)


def create_execute_function_from_codeblock(codeblock: str, custom_scope: dict | None = None, func_name: str = &quot;execute&quot;) -&gt; Callable:
    &quot;&quot;&quot;Convert a user code string into a Callable that takes in a Codebase.

    Steps:
    1. Check for any dangerous operations in the codeblock. Will raise DangerousUserCodeException if any dangerous operations are found.
    2. Create a function string from the codeblock. Ex: &quot;def execute(codebase: Codebase): ...&quot;
    3. Compile the function string into a Callable that takes in a Codebase. Will raise InvalidUserCodeException if there are any code errors (ex: IndentationErrors)
    4. Wrap the function in another function (that also takes in a Codebase) that handles calling the function and safely handling any exceptions occur during execution.

    Args:
        codeblock (str): The user code to construct the Callable with (usually CodemodVersionModel.source)
        custom_scope (dict | None, optional): Custom scope to be used during compilation. Defaults to None.
        func_name (str, optional): Name of the function to be created. Defaults to &quot;execute&quot;.

    Returns:
        Callable: def &lt;func_name&gt;(codebase: Codebase) -&gt; any | dict

    Raises:
        UnsafeUserCodeException: If the user&apos;s code contains dangerous operations.
        InvalidUserCodeException: If there are syntax errors in the provided code.
    &quot;&quot;&quot;
    # =====[ Set up custom scope ]=====
    custom_scope = custom_scope or {}
    logger.info(f&quot;create_execute_function custom_scope: {custom_scope.keys()}&quot;)

    # =====[ Check for dangerous operations in the codeblock ]=====
    check_for_dangerous_operations(codeblock)
    # =====[ Create function string from codeblock ]=====
    func_str = create_function_str_from_codeblock(codeblock, func_name)
    # =====[ Compile the function string into a function  ]=====
    func = safe_compile_function_string(custom_scope=custom_scope, func_name=func_name, func_str=func_str)

    # =====[ Compute line offset of func_str  ]=====
    # This is to generate the a traceback with the correct line window
    len_imports = len(get_imports_string().split(&quot;\n&quot;))
    len_func_str = 1
    line_offset = len_imports + len_func_str

    # =====[ Create closure function to enclose outer scope variables]=====
    def closure_func() -&gt; Callable[[Any], None]:
        &quot;&quot;&quot;Wrap user code in a closure to capture the outer scope variables and format errors.&quot;&quot;&quot;
        _func_str = func_str
        _line_offset = line_offset

        # Wrap the func for better tracing
        def wrapped_func(*args, **kwargs):
            &quot;&quot;&quot;Wraps the user code to capture and format exceptions + grab locals&quot;&quot;&quot;
            try:
                linecache.cache[&quot;&lt;string&gt;&quot;] = (len(_func_str), None, _func_str.splitlines(True), &quot;&lt;string&gt;&quot;)
                func(*args, **kwargs)

            # =====[ Grab locals during `StopCodemodException` ]=====
            except StopCodemodException as e:
                logger.info(f&quot;Stopping codemod due to {e.__class__.__name__}: {e}&quot;)
                raise e

            except Exception as e:
                # =====[ Get offset, filtered traceback message ]=====
                tb_lines = traceback.format_exception(type(e), e, e.__traceback__)
                error_message = get_offset_traceback(tb_lines, _line_offset, filenameFilter=&quot;&lt;string&gt;&quot;)

                # =====[ Find frame in user&apos;s code ]=====
                exc_type, exc_value, exc_traceback = sys.exc_info()
                frame = get_local_frame(exc_type, exc_value, exc_traceback)
                # TODO: handle frame is None
                line_num = frame.f_lineno

                # =====[ Get context lines ]=====
                context_start = max(0, line_num - 3)
                context_end = min(len(func_str.split(&quot;\n&quot;)), line_num + 2)
                context_lines = func_str.split(&quot;\n&quot;)[context_start:context_end]

                # =====[ Format error message with context ]=====
                error_lines = []
                for i, line in enumerate(context_lines, start=context_start + 1):
                    marker = &quot;&gt;&quot; if i == line_num else &quot; &quot;
                    error_lines.append(f&quot;{marker} {i - _line_offset}: {line.rstrip()}&quot;)
                error_context = &quot;\n&quot;.join(error_lines)

                # =====[ Format error message ]=====
                error_message = (
                    error_message
                    + f&quot;&quot;&quot;

Code context:
{error_context}
&quot;&quot;&quot;
                )
                raise RuntimeError(error_message) from e

        return wrapped_func

    return closure_func()</file><file path="src/codegen/shared/decorators/docs.py">import bisect
import inspect
from collections.abc import Callable
from dataclasses import dataclass
from typing import TypeVar


@dataclass
class DocumentedObject:
    name: str
    module: str
    object: any

    def __lt__(self, other):
        return self.module &lt; other.module

    def signature(self) -&gt; str:
        return f&quot;{self.name}&quot;


apidoc_objects: list[DocumentedObject] = []


def apidoc(obj):
    &quot;&quot;&quot;Decorator for objects that will be used as API documentation for AI-agent prompts.&quot;&quot;&quot;
    obj._apidoc = True
    obj._api_doc_lang = &quot;core&quot;
    if doc_obj := get_documented_object(obj):
        bisect.insort(apidoc_objects, doc_obj)
    return obj


py_apidoc_objects: list[DocumentedObject] = []


def py_apidoc(obj):
    &quot;&quot;&quot;Decorator for objects that will be used as Python API documentation for AI-agent prompts.&quot;&quot;&quot;
    obj._py_apidoc = True
    obj._api_doc_lang = &quot;python&quot;
    if doc_obj := get_documented_object(obj):
        bisect.insort(py_apidoc_objects, doc_obj)
    return obj


ts_apidoc_objects: list[DocumentedObject] = []


def ts_apidoc(obj):
    &quot;&quot;&quot;Decorator for objects that will be used as Typescript API documentation for AI-agent prompts.&quot;&quot;&quot;
    obj._ts_apidoc = True
    obj._api_doc_lang = &quot;typescript&quot;
    if doc_obj := get_documented_object(obj):
        bisect.insort(ts_apidoc_objects, doc_obj)
    return obj


no_apidoc_objects: list[DocumentedObject] = []
no_apidoc_signatures: set[str] = set()

T = TypeVar(&quot;T&quot;, bound=Callable)


def noapidoc(obj: T) -&gt; T:
    &quot;&quot;&quot;Decorator for things that are hidden from the API documentation for AI-agent prompts.&quot;&quot;&quot;
    obj._apidoc = False
    obj._api_doc_lang = None
    if doc_obj := get_documented_object(obj):
        bisect.insort(no_apidoc_objects, doc_obj)
        no_apidoc_signatures.add(doc_obj.signature())
    return obj


py_no_apidoc_objects: list[DocumentedObject] = []
py_no_apidoc_signatures: set[str] = set()


def py_noapidoc(obj: T) -&gt; T:
    &quot;&quot;&quot;Decorator for things that are hidden from the Python API documentation for AI-agent prompts.&quot;&quot;&quot;
    obj._py_apidoc = False
    obj._api_doc_lang = &quot;python&quot;
    if doc_obj := get_documented_object(obj):
        bisect.insort(py_no_apidoc_objects, doc_obj)
        py_no_apidoc_signatures.add(doc_obj.signature())
    return obj


def get_documented_object(obj) -&gt; DocumentedObject | None:
    module = inspect.getmodule(obj)
    module_name = module.__name__ if module else &quot;&quot;
    if module_name:
        return DocumentedObject(name=obj.__name__, module=module_name, object=obj)</file><file path="src/codegen/shared/enums/programming_language.py">from enum import StrEnum


class ProgrammingLanguage(StrEnum):
    TYPESCRIPT = &quot;TYPESCRIPT&quot;
    PYTHON = &quot;PYTHON&quot;
    OTHER = &quot;OTHER&quot;
    UNSUPPORTED = &quot;UNSUPPORTED&quot;</file><file path="src/codegen/shared/exceptions/api.py">class APINotApplicableForLanguageError(Exception):
    pass</file><file path="src/codegen/shared/exceptions/compilation.py">class UserCodeException(Exception):
    &quot;&quot;&quot;Custom exception for any issues in user code.&quot;&quot;&quot;


class DangerousUserCodeException(UserCodeException):
    &quot;&quot;&quot;Custom exception user code that has dangerous / not permitted operations.&quot;&quot;&quot;


class InvalidUserCodeException(UserCodeException):
    &quot;&quot;&quot;Custom exception for user code that can be compiled/executed. Ex: syntax errors, indentation errors, name errors etc.&quot;&quot;&quot;</file><file path="src/codegen/shared/exceptions/control_flow.py">class StopCodemodException(Exception):
    &quot;&quot;&quot;Raises when the codemod execution should stop early.
    This gets caught upstream and causes an early exit so that we can surface a subset of the results to the user for faster iteration.
    &quot;&quot;&quot;

    threshold: int | None = None

    def __init__(self, message: str | None = None, threshold: int | None = None):
        super().__init__(message)
        self.threshold = threshold


class MaxTransactionsExceeded(StopCodemodException):
    &quot;&quot;&quot;Raised when the number of transactions exceeds the max_transactions limit.
    This gets caught upstream and causes an early exit so that we can surface a subset of the results to the user for faster iteration.
    &quot;&quot;&quot;


class MaxPreviewTimeExceeded(StopCodemodException):
    &quot;&quot;&quot;Raised when more than the allotted time has passed for previewing transactions. Enables us to keep it at like ~5s in the frontend during debugging&quot;&quot;&quot;


class MaxAIRequestsError(StopCodemodException):
    &quot;&quot;&quot;Raised when the number of AI requests exceeds the max_ai_requests limit.

    This gets caught upstream and causes an early exit so that we can surface a subset of the
    results to the user for faster iteration.
    &quot;&quot;&quot;</file><file path="src/codegen/shared/logging/get_logger.py">import logging
import sys

import colorlog

formatter = colorlog.ColoredFormatter(
    &quot;%(white)s%(asctime)s - %(name)s - %(log_color)s%(levelname)s%(reset)s%(white)s - %(message_log_color)s%(message)s&quot;,
    log_colors={
        &quot;DEBUG&quot;: &quot;white&quot;,
        &quot;INFO&quot;: &quot;green&quot;,
        &quot;WARNING&quot;: &quot;yellow&quot;,
        &quot;ERROR&quot;: &quot;red&quot;,
        &quot;CRITICAL&quot;: &quot;red,bg_white&quot;,
    },
    secondary_log_colors={
        &quot;message&quot;: {
            &quot;DEBUG&quot;: &quot;cyan&quot;,
            &quot;INFO&quot;: &quot;white&quot;,
            &quot;WARNING&quot;: &quot;yellow&quot;,
            &quot;ERROR&quot;: &quot;red&quot;,
            &quot;CRITICAL&quot;: &quot;red,bg_white&quot;,
        }
    },
)


class StdOutFilter(logging.Filter):
    def filter(self, record):
        return record.levelno &lt; logging.ERROR


class StdErrFilter(logging.Filter):
    def filter(self, record):
        return record.levelno &gt;= logging.ERROR


# Create handlers
stdout_handler = logging.StreamHandler(sys.stdout)  # Logs to stdout
stdout_handler.setFormatter(formatter)
stdout_handler.addFilter(StdOutFilter())

stderr_handler = logging.StreamHandler(sys.stderr)  # Logs to stderr
stderr_handler.setFormatter(formatter)
stderr_handler.addFilter(StdErrFilter())

# Global OpenTelemetry handler (lazy-loaded)
_otel_handler = None
_otel_handler_checked = False

# Global telemetry config cache
_telemetry_config = None
_telemetry_config_checked = False


def _get_telemetry_config():
    &quot;&quot;&quot;Get telemetry configuration for debug mode checking.&quot;&quot;&quot;
    global _telemetry_config, _telemetry_config_checked

    if _telemetry_config_checked:
        return _telemetry_config

    _telemetry_config_checked = True

    try:
        # Use non-prompting config loader to avoid consent prompts during logging setup
        from codegen.configs.models.telemetry import TelemetryConfig
        from codegen.configs.constants import GLOBAL_ENV_FILE

        _telemetry_config = TelemetryConfig(env_filepath=GLOBAL_ENV_FILE)
    except ImportError:
        # Telemetry dependencies not available
        _telemetry_config = None
    except Exception:
        # Other setup errors - fallback to console logging
        _telemetry_config = None

    return _telemetry_config


def _get_otel_handler():
    &quot;&quot;&quot;Get OpenTelemetry handler if available and enabled.&quot;&quot;&quot;
    global _otel_handler, _otel_handler_checked

    if _otel_handler_checked:
        return _otel_handler

    _otel_handler_checked = True

    try:
        from codegen.cli.telemetry.otel_setup import get_otel_logging_handler

        _otel_handler = get_otel_logging_handler()
    except ImportError:
        # OTel dependencies not available
        _otel_handler = None
    except Exception:
        # Other setup errors
        _otel_handler = None

    return _otel_handler


def get_logger(name: str, level: int = logging.INFO) -&gt; logging.Logger:
    logger = _setup_logger(name, level)
    # Note: Global exception handling is managed by cli/telemetry/exception_logger.py
    return logger


def refresh_telemetry_config():
    &quot;&quot;&quot;Refresh the cached telemetry configuration.

    This should be called when telemetry settings change to ensure
    logging behavior updates accordingly.
    &quot;&quot;&quot;
    global _telemetry_config_checked, _telemetry_config
    _telemetry_config_checked = False
    _telemetry_config = None


def _setup_logger(name: str, level: int = logging.INFO) -&gt; logging.Logger:
    # Force configure the root logger with a NullHandler to prevent duplicate logs
    logging.basicConfig(handlers=[logging.NullHandler()], force=True)
    logger = logging.getLogger(name)
    if logger.hasHandlers():
        for h in logger.handlers:
            logger.removeHandler(h)

    # Check telemetry configuration to determine console logging behavior
    telemetry_config = _get_telemetry_config()

    # Only add console handlers if:
    # 1. Telemetry is not configured (default behavior)
    # 2. Telemetry debug mode is enabled
    # 3. Telemetry is disabled (fallback to console logging)
    should_log_to_console = (
        telemetry_config is None  # Telemetry not configured
        or telemetry_config.debug  # Debug mode enabled
        or not telemetry_config.enabled  # Telemetry disabled
    )

    if should_log_to_console:
        logger.addHandler(stdout_handler)
        logger.addHandler(stderr_handler)

    # Always add OpenTelemetry handler if telemetry is enabled (regardless of debug mode)
    otel_handler = _get_otel_handler()
    if otel_handler is not None:
        logger.addHandler(otel_handler)

    # Ensure the logger propagates to the root logger
    logger.propagate = True
    # Set the level on the logger itself
    logger.setLevel(level)
    return logger


# Note: Exception logging is handled by cli/telemetry/exception_logger.py</file><file path="src/codegen/shared/network/port.py">import socket
from contextlib import closing


def get_free_port() -&gt; int:
    &quot;&quot;&quot;Find and return a free port on localhost&quot;&quot;&quot;
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
        s.bind((&quot;&quot;, 0))
        s.listen(1)
        port = s.getsockname()[1]
        return int(port)


def is_port_free(port: int, host: str = &quot;localhost&quot;) -&gt; bool:
    &quot;&quot;&quot;Check if a port is free on localhost&quot;&quot;&quot;
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
        return s.connect_ex((host, port)) != 0</file><file path="src/codegen/shared/performance/memory_utils.py">import os
from dataclasses import dataclass

import psutil


@dataclass
class MemoryStats:
    memory_rss_gb: float
    memory_vms_gb: float


def get_memory_stats() -&gt; MemoryStats:
    process = psutil.Process(os.getpid())
    memory_info = process.memory_info()

    return MemoryStats(
        memory_rss_gb=memory_info.rss / 1024 / 1024 / 1024,
        memory_vms_gb=memory_info.vms / 1024 / 1024 / 1024,
    )</file><file path="src/codegen/shared/performance/stopwatch_utils.py">import subprocess
import time
from functools import wraps
from typing import cast

import sentry_sdk

from codegen.shared.logging.get_logger import get_logger
from codegen.shared.performance.time_utils import humanize_duration

logger = get_logger(__name__)


def stopwatch(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        execution_time = end_time - start_time
        logger.info(f&quot;Function &apos;{func.__name__}&apos; took {humanize_duration(execution_time)} to execute.&quot;)
        return result

    return wrapper


def stopwatch_with_sentry(name: str):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            with sentry_sdk.start_transaction(name=name):
                start_time = time.perf_counter()
                res = func(*args, **kwargs)
                end_time = time.perf_counter()
                execution_time = end_time - start_time
                logger.info(f&quot;Function &apos;{func.__name__}&apos; took {humanize_duration(execution_time)} to execute.&quot;)
                return res

        return wrapper

    return decorator


def subprocess_with_stopwatch(command, command_desc: str | None = None, *args, **kwargs) -&gt; subprocess.CompletedProcess[str]:
    start_time = time.time()
    # Ensure text=True to get string output instead of bytes
    kwargs.setdefault(&quot;text&quot;, True)
    result = subprocess.run(command, *args, **kwargs)
    end_time = time.time()
    logger.info(f&quot;Command &apos;{command_desc or command}&apos; took {end_time - start_time} seconds to execute.&quot;)
    # Cast to the correct type since we set text=True
    return cast(&quot;subprocess.CompletedProcess[str]&quot;, result)</file><file path="src/codegen/shared/performance/time_utils.py">import datetime as dt

import humanize


def humanize_duration(seconds: float) -&gt; str:
    &quot;&quot;&quot;Converts a duration in seconds to a human-readable string.
    Example: humanize_duration(60) -&gt; &quot;1 minute&quot;
    &quot;&quot;&quot;
    delta = dt.timedelta(seconds=seconds)
    return humanize.precisedelta(delta, minimum_unit=&quot;milliseconds&quot;)</file><file path="src/codegen/shared/string/csv_utils.py">def list_to_comma_separated(items: list[str]) -&gt; str:
    &quot;&quot;&quot;Given a list of items, returns a comma separated string of the items&quot;&quot;&quot;
    return &quot;,&quot;.join(items)


def comma_separated_to_list(comma_separated: str) -&gt; list[str]:
    &quot;&quot;&quot;Given a comma separated string, returns a list of the comma separated items.
    Strips whitespace from each item, drops any items that are whitespace only
    &quot;&quot;&quot;
    items = comma_separated.split(&quot;,&quot;) if comma_separated else []
    non_empty_items = [item.strip() for item in items if item.strip()]
    return non_empty_items


def comma_separated_to_set(comma_separated: str) -&gt; set[str]:
    &quot;&quot;&quot;Given a comma separated string, returns a set of the comma separated items.
    Strips whitespace from each item, drops any items that are whitespace only
    &quot;&quot;&quot;
    items = comma_separated.split(&quot;,&quot;) if comma_separated else []
    non_empty_items = {item.strip() for item in items if item.strip()}
    return non_empty_items</file><file path="src/codegen/shared/path.py">import os
import subprocess
from pathlib import Path


def get_git_root_path(path: Path | None = None) -&gt; Path | None:
    &quot;&quot;&quot;Get the closest root of the git repository containing the given path&quot;&quot;&quot;
    try:
        path = path or Path.cwd()
        path = path.resolve()
        os.chdir(path)
        output = subprocess.run([&quot;git&quot;, &quot;rev-parse&quot;, &quot;--show-toplevel&quot;], capture_output=True, check=True, text=True)
        return Path(output.stdout.strip())
    except (subprocess.CalledProcessError, FileNotFoundError):
        return None</file><file path="src/codegen/shared/README.md"># Codegen Shared

A codegen module to contain a miscellaneous set of shared utilities.

### Dependencies

This module should NOT contain any high level dependencies on other codegen modules.
It should only depend on standard libraries and other shared utilities.</file><file path="src/codegen/__init__.py">from codegen.agents import Agent

# Import version information from the auto-generated _version.py
try:
    from ._version import __version__, __version_tuple__, version, version_tuple
except ImportError:
    # Fallback for development/editable installs where _version.py might not exist
    __version__ = version = &quot;0.0.0+unknown&quot;
    __version_tuple__ = version_tuple = (0, 0, 0, &quot;unknown&quot;)

__all__ = [&quot;__version__&quot;, &quot;__version_tuple__&quot;, &quot;version&quot;, &quot;version_tuple&quot;, &quot;Agent&quot;]</file><file path="src/codegen/exports.py">&quot;&quot;&quot;Public API exports for the codegen package.

This file provides convenient imports for commonly used classes.
Since __init__.py is auto-generated by setuptools-scm, we use this
separate file for manual exports.
&quot;&quot;&quot;

from codegen.agents.agent import Agent
from codegen.sdk.core.codebase import Codebase  # type: ignore[import-untyped]
from codegen.sdk.core.function import Function  # type: ignore[import-untyped]
from codegen.shared.enums.programming_language import ProgrammingLanguage

__all__ = [
    &quot;Agent&quot;,
    &quot;Codebase&quot;,
    &quot;Function&quot;,
    &quot;ProgrammingLanguage&quot;,
]</file><file path="src/HIRING.md"># Hiring

Are you excited about static analysis and codebase transformation? We&apos;re hiring!

For current openings and to apply, visit [codegen.com/careers](https://codegen.com/careers).</file><file path="tests/cli/mcp/test_basic_integration.py">&quot;&quot;&quot;Basic integration tests for the MCP functionality.&quot;&quot;&quot;

import os
import subprocess
from pathlib import Path


class TestMCPBasicIntegration:
    &quot;&quot;&quot;Basic integration tests that don&apos;t require full server startup.&quot;&quot;&quot;

    def test_mcp_command_help(self):
        &quot;&quot;&quot;Test that the MCP command help works.&quot;&quot;&quot;
        codegen_path = Path(__file__).parent.parent.parent.parent / &quot;src&quot;
        venv_python = Path(__file__).parent.parent.parent.parent / &quot;.venv&quot; / &quot;bin&quot; / &quot;python&quot;

        env = os.environ.copy()
        env[&quot;PYTHONPATH&quot;] = str(codegen_path)

        process = subprocess.Popen([str(venv_python), &quot;-c&quot;, &quot;from codegen.cli.cli import main; main([&apos;mcp&apos;, &apos;--help&apos;])&quot;], env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        stdout, stderr = process.communicate(timeout=10)

        assert process.returncode == 0
        assert &quot;Start the Codegen MCP server&quot; in stdout
        assert &quot;--transport&quot; in stdout
        assert &quot;--host&quot; in stdout
        assert &quot;--port&quot; in stdout

    def test_api_client_package_available(self):
        &quot;&quot;&quot;Test that the API client package is available.&quot;&quot;&quot;
        codegen_path = Path(__file__).parent.parent.parent.parent / &quot;src&quot;
        venv_python = Path(__file__).parent.parent.parent.parent / &quot;.venv&quot; / &quot;bin&quot; / &quot;python&quot;

        env = os.environ.copy()
        env[&quot;PYTHONPATH&quot;] = str(codegen_path)

        process = subprocess.Popen(
            [str(venv_python), &quot;-c&quot;, &quot;import codegen_api_client; print(&apos;API client package imported successfully&apos;)&quot;], env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )

        stdout, stderr = process.communicate(timeout=10)

        assert process.returncode == 0
        assert &quot;API client package imported successfully&quot; in stdout</file><file path="tests/cli/mcp/test_server_startup.py">&quot;&quot;&quot;Server startup tests for MCP functionality.&quot;&quot;&quot;

import os
import subprocess
import time
from pathlib import Path


class TestMCPServerStartup:
    &quot;&quot;&quot;Tests that actually start the MCP server briefly.&quot;&quot;&quot;

    def test_server_startup_stdio(self):
        &quot;&quot;&quot;Test that the server can start with stdio transport.&quot;&quot;&quot;
        codegen_path = Path(__file__).parent.parent.parent.parent / &quot;src&quot;
        venv_python = Path(__file__).parent.parent.parent.parent / &quot;.venv&quot; / &quot;bin&quot; / &quot;python&quot;

        env = os.environ.copy()
        env[&quot;PYTHONPATH&quot;] = str(codegen_path)

        # Start the server process
        process = subprocess.Popen(
            [str(venv_python), &quot;-c&quot;, &quot;from codegen.cli.cli import main; main([&apos;mcp&apos;, &apos;--transport&apos;, &apos;stdio&apos;])&quot;],
            env=env,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        try:
            # Give it a moment to start
            time.sleep(2)

            # Check if process is still running (not crashed)
            assert process.poll() is None, &quot;Server process should still be running&quot;

            # Send a simple message to test stdio communication
            # This is a basic MCP initialization message
            init_message = (
                &apos;{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;initialize&quot;, &quot;params&quot;: {&quot;protocolVersion&quot;: &quot;2024-11-05&quot;, &quot;capabilities&quot;: {}, &quot;clientInfo&quot;: {&quot;name&quot;: &quot;test-client&quot;, &quot;version&quot;: &quot;1.0.0&quot;}}}\n&apos;
            )

            if process.stdin:
                process.stdin.write(init_message)
                process.stdin.flush()

            # Give it a moment to process
            time.sleep(1)

            # Process should still be running
            assert process.poll() is None, &quot;Server should handle initialization without crashing&quot;

        finally:
            # Clean up: terminate the process
            if process.poll() is None:
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    process.kill()
                    process.wait()

    def test_server_startup_invalid_transport(self):
        &quot;&quot;&quot;Test that the server fails gracefully with invalid transport.&quot;&quot;&quot;
        codegen_path = Path(__file__).parent.parent.parent.parent / &quot;src&quot;
        venv_python = Path(__file__).parent.parent.parent.parent / &quot;.venv&quot; / &quot;bin&quot; / &quot;python&quot;

        env = os.environ.copy()
        env[&quot;PYTHONPATH&quot;] = str(codegen_path)

        process = subprocess.Popen(
            [str(venv_python), &quot;-c&quot;, &quot;from codegen.cli.cli import main; main([&apos;mcp&apos;, &apos;--transport&apos;, &apos;invalid&apos;])&quot;], env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )

        stdout, stderr = process.communicate(timeout=10)

        # Should exit with error code
        assert process.returncode != 0

        # Should contain error message about invalid transport
        error_output = stdout + stderr
        assert &quot;invalid&quot; in error_output.lower() or &quot;transport&quot; in error_output.lower()

    def test_server_help_contains_expected_info(self):
        &quot;&quot;&quot;Test that server help contains expected information.&quot;&quot;&quot;
        codegen_path = Path(__file__).parent.parent.parent.parent / &quot;src&quot;
        venv_python = Path(__file__).parent.parent.parent.parent / &quot;.venv&quot; / &quot;bin&quot; / &quot;python&quot;

        env = os.environ.copy()
        env[&quot;PYTHONPATH&quot;] = str(codegen_path)

        process = subprocess.Popen([str(venv_python), &quot;-c&quot;, &quot;from codegen.cli.cli import main; main([&apos;mcp&apos;, &apos;--help&apos;])&quot;], env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        stdout, stderr = process.communicate(timeout=10)

        assert process.returncode == 0

        # Check that help contains expected information
        help_text = stdout.lower()
        assert &quot;mcp server&quot; in help_text
        assert &quot;codegen&quot; in help_text
        assert &quot;--host&quot; in help_text
        assert &quot;--port&quot; in help_text
        assert &quot;--transport&quot; in help_text
        assert &quot;stdio&quot; in help_text
        assert &quot;http&quot; in help_text</file><file path="tests/cli/mcp/test_simple_integration.py">&quot;&quot;&quot;Simple integration tests for MCP functionality without FastMCP dependencies.&quot;&quot;&quot;

from unittest.mock import patch


class TestMCPSimpleIntegration:
    &quot;&quot;&quot;Simple integration tests that avoid FastMCP import issues.&quot;&quot;&quot;

    def test_api_client_imports_available(self):
        &quot;&quot;&quot;Test that API client imports are available.&quot;&quot;&quot;
        # Test that we can import the API client components
        try:
            from codegen_api_client import AgentsApi, ApiClient, Configuration, OrganizationsApi, UsersApi

            # Should not raise any exceptions
            assert Configuration is not None
            assert ApiClient is not None
            assert AgentsApi is not None
            assert OrganizationsApi is not None
            assert UsersApi is not None

        except ImportError as e:
            msg = f&quot;API client imports not available: {e}&quot;
            raise AssertionError(msg) from e

    def test_mcp_command_registration(self):
        &quot;&quot;&quot;Test that the MCP command is registered in the CLI.&quot;&quot;&quot;
        from codegen.cli.cli import main

        # Check that the mcp command is registered in typer
        # For typer, we can check if the command exists by looking at registered commands
        # This is a basic test to ensure the command is importable and the CLI structure is correct
        assert hasattr(main, &quot;registered_commands&quot;) or hasattr(main, &quot;commands&quot;) or callable(main)

    def test_mcp_command_function_exists(self):
        &quot;&quot;&quot;Test that the MCP command function exists.&quot;&quot;&quot;
        from codegen.cli.commands.mcp.main import mcp

        assert callable(mcp)

        # Check the function signature (typer function)
        import inspect

        sig = inspect.signature(mcp)
        param_names = list(sig.parameters.keys())

        # Should have the expected parameters
        assert &quot;host&quot; in param_names
        assert &quot;port&quot; in param_names
        assert &quot;transport&quot; in param_names

    def test_server_configuration_basic(self):
        &quot;&quot;&quot;Test basic server configuration without importing server module.&quot;&quot;&quot;
        # Just test that the command module exists and is importable
        try:
            from codegen.cli.commands.mcp.main import mcp

            assert callable(mcp)
        except ImportError as e:
            msg = f&quot;MCP command module not importable: {e}&quot;
            raise AssertionError(msg) from e

    def test_environment_variable_handling_basic(self):
        &quot;&quot;&quot;Test basic environment variable handling.&quot;&quot;&quot;
        import os

        # Test with custom environment variables
        with patch.dict(os.environ, {&quot;CODEGEN_API_BASE_URL&quot;: &quot;https://custom.api.com&quot;, &quot;CODEGEN_API_KEY&quot;: &quot;test-key-123&quot;}):
            # Just test that environment variables are set
            assert os.environ.get(&quot;CODEGEN_API_BASE_URL&quot;) == &quot;https://custom.api.com&quot;
            assert os.environ.get(&quot;CODEGEN_API_KEY&quot;) == &quot;test-key-123&quot;

    def test_transport_validation(self):
        &quot;&quot;&quot;Test transport validation logic.&quot;&quot;&quot;
        # Test valid transports
        valid_transports = [&quot;stdio&quot;, &quot;http&quot;]

        for transport in valid_transports:
            # Should not raise an exception for valid transports
            # We can&apos;t actually run the server due to FastMCP import issues
            # but we can test the validation logic
            assert transport in [&quot;stdio&quot;, &quot;http&quot;]

        # Test invalid transport
        invalid_transport = &quot;invalid&quot;
        assert invalid_transport not in [&quot;stdio&quot;, &quot;http&quot;]</file><file path="tests/integration/codegen/test_placeholder.py">&quot;&quot;&quot;Placeholder integration test to make the workflow pass.&quot;&quot;&quot;


def test_placeholder():
    &quot;&quot;&quot;Placeholder test that always passes.

    This test exists to ensure the integration test workflow completes successfully
    when there are no actual integration tests to run.
    &quot;&quot;&quot;
    assert True, &quot;Placeholder test should always pass&quot;</file><file path="tests/shared/utils/normalize.py">import re


def normalize_string(git_diff_string):
    # Replace sequences of hexadecimal digits with a consistent placeholder
    pattern = r&quot;^index\s+[0-9a-f]+\.+[0-9a-f]*\s*.*$&quot;
    normalized_diff = re.sub(pattern, &quot;&lt;hex&gt;&quot;, git_diff_string, flags=re.MULTILINE)
    return normalized_diff


def normalize_imports(content: str) -&gt; str:
    &quot;&quot;&quot;Alphabetically sorts lines which start with &quot;import&quot; so we can compare
    Two source code strings without caring if their imports are in the same order
    &quot;&quot;&quot;
    # Split the content into lines
    lines = content.strip().split(&quot;\n&quot;)

    # Separate import lines and other lines
    import_lines = [line for line in lines if re.match(r&quot;^\s*import\s&quot;, line)]
    other_lines = [line for line in lines if not re.match(r&quot;^\s*import\s&quot;, line)]

    # Sort the import lines
    sorted_imports = sorted(import_lines)

    # Combine the sorted imports with the other lines
    normalized_content = &quot;\n&quot;.join(sorted_imports + other_lines)

    return normalized_content</file><file path="tests/shared/utils/recursion.py">import logging
import resource
import sys

logger = logging.getLogger(__name__)


def set_recursion_limit():
    sys.setrecursionlimit(10**9)
    if sys.platform == &quot;linux&quot;:
        logger.info(f&quot;Setting stack limit to {resource.RLIM_INFINITY}&quot;)
        resource.setrlimit(resource.RLIMIT_STACK, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))</file><file path="tests/shared/README.md"># Tests/shared

### What kind of things should go in here?

Testing utilities like mocks, fixtures, test data that are used across multiple tests.</file><file path="tests/unit/codegen/agents/test_agent.py">&quot;&quot;&quot;Unit tests for the Agent class.&quot;&quot;&quot;

import os
from unittest.mock import MagicMock, patch

import pytest

from codegen.agents.agent import Agent, AgentTask


class TestAgentImport:
    &quot;&quot;&quot;Test that we can properly import the Agent class.&quot;&quot;&quot;

    def test_can_import_agent(self):
        &quot;&quot;&quot;Test that we can import Agent from codegen.agents.agent.&quot;&quot;&quot;
        from codegen.agents.agent import Agent

        assert Agent is not None

    def test_can_import_agent_task(self):
        &quot;&quot;&quot;Test that we can import AgentTask from codegen.agents.agent.&quot;&quot;&quot;
        from codegen.agents.agent import AgentTask

        assert AgentTask is not None


class TestAgentInitialization:
    &quot;&quot;&quot;Test Agent initialization and configuration.&quot;&quot;&quot;

    def test_agent_init_with_token_and_org_id(self):
        &quot;&quot;&quot;Test Agent initialization with token and org_id.&quot;&quot;&quot;
        agent = Agent(token=&quot;test_token&quot;, org_id=123)

        assert agent.token == &quot;test_token&quot;
        assert agent.org_id == 123
        assert agent.current_job is None
        assert agent.api_client is not None
        assert agent.agents_api is not None

    def test_agent_init_with_token_only(self):
        &quot;&quot;&quot;Test Agent initialization with token only (should use default org_id).&quot;&quot;&quot;
        with patch.dict(os.environ, {&quot;CODEGEN_ORG_ID&quot;: &quot;456&quot;}, clear=False):
            agent = Agent(token=&quot;test_token&quot;)

            assert agent.token == &quot;test_token&quot;
            assert agent.org_id == 456  # From environment
            assert agent.current_job is None

    def test_agent_init_with_token_no_env_org_id(self):
        &quot;&quot;&quot;Test Agent initialization with token only and no env org_id (should use default).&quot;&quot;&quot;
        with patch.dict(os.environ, {}, clear=True):
            agent = Agent(token=&quot;test_token&quot;)

            assert agent.token == &quot;test_token&quot;
            assert agent.org_id == 1  # Default fallback
            assert agent.current_job is None

    def test_agent_init_with_custom_base_url(self):
        &quot;&quot;&quot;Test Agent initialization with custom base_url.&quot;&quot;&quot;
        custom_url = &quot;https://custom.api.url&quot;
        agent = Agent(token=&quot;test_token&quot;, org_id=123, base_url=custom_url)

        assert agent.token == &quot;test_token&quot;
        assert agent.org_id == 123
        # The API client should be configured with the custom URL
        assert agent.api_client.configuration.host == custom_url


class TestAgentErrorHandling:
    &quot;&quot;&quot;Test error handling in Agent class.&quot;&quot;&quot;

    def test_agent_init_requires_token(self):
        &quot;&quot;&quot;Test that Agent initialization requires a token parameter.&quot;&quot;&quot;
        # This should raise a TypeError because token is a required parameter
        with pytest.raises(TypeError, match=&quot;missing 1 required positional argument: &apos;token&apos;&quot;):
            Agent()  # Missing required token parameter

    def test_agent_init_with_none_token(self):
        &quot;&quot;&quot;Test Agent initialization with None token.&quot;&quot;&quot;
        # The Agent class should accept None but the API calls would fail
        agent = Agent(token=None, org_id=123)
        assert agent.token is None
        assert agent.org_id == 123

    def test_agent_init_with_empty_token(self):
        &quot;&quot;&quot;Test Agent initialization with empty string token.&quot;&quot;&quot;
        agent = Agent(token=&quot;&quot;, org_id=123)
        assert agent.token == &quot;&quot;
        assert agent.org_id == 123


class TestAgentTaskCreation:
    &quot;&quot;&quot;Test AgentTask creation and functionality.&quot;&quot;&quot;

    def test_agent_task_init(self):
        &quot;&quot;&quot;Test AgentTask initialization.&quot;&quot;&quot;
        # Mock the AgentRunResponse
        mock_response = MagicMock()
        mock_response.id = &quot;task_123&quot;
        mock_response.status = &quot;pending&quot;
        mock_response.result = None
        mock_response.web_url = &quot;https://example.com/task/123&quot;

        # Mock API client
        mock_api_client = MagicMock()

        # Create AgentTask
        task = AgentTask(mock_response, mock_api_client, org_id=123)

        assert task.id == &quot;task_123&quot;
        assert task.org_id == 123
        assert task.status == &quot;pending&quot;
        assert task.result is None
        assert task.web_url == &quot;https://example.com/task/123&quot;
        assert task._api_client == mock_api_client


class TestAgentUsageExample:
    &quot;&quot;&quot;Test the example usage pattern from the user&apos;s requirements.&quot;&quot;&quot;

    @patch(&quot;codegen.agents.agent.AgentsApi&quot;)
    @patch(&quot;codegen.agents.agent.ApiClient&quot;)
    @patch(&quot;codegen.agents.agent.Configuration&quot;)
    def test_basic_usage_pattern(self, mock_config, mock_api_client, mock_agents_api):
        &quot;&quot;&quot;Test the basic usage pattern that should work.&quot;&quot;&quot;
        # Setup mocks
        mock_config_instance = MagicMock()
        mock_config.return_value = mock_config_instance

        mock_api_client_instance = MagicMock()
        mock_api_client.return_value = mock_api_client_instance

        mock_agents_api_instance = MagicMock()
        mock_agents_api.return_value = mock_agents_api_instance

        # Mock the API response
        mock_response = MagicMock()
        mock_response.id = &quot;task_456&quot;
        mock_response.status = &quot;pending&quot;
        mock_response.result = None
        mock_response.web_url = &quot;https://example.com/task/456&quot;

        mock_agents_api_instance.create_agent_run_v1_organizations_org_id_agent_run_post.return_value = mock_response

        # Test the usage pattern
        from codegen.agents.agent import Agent

        # Initialize the Agent
        agent = Agent(
            org_id=123,  # Pass as int
            token=&quot;test_api_token&quot;,
        )

        assert agent is not None
        assert agent.token == &quot;test_api_token&quot;
        assert agent.org_id == 123

        # Run an agent with a prompt
        task = agent.run(prompt=&quot;Implement a new feature to sort users by last login.&quot;)

        assert task is not None
        assert task.id == &quot;task_456&quot;
        assert task.status == &quot;pending&quot;

        # Verify the API was called correctly
        mock_agents_api_instance.create_agent_run_v1_organizations_org_id_agent_run_post.assert_called_once()
        call_args = mock_agents_api_instance.create_agent_run_v1_organizations_org_id_agent_run_post.call_args
        assert call_args[1][&quot;org_id&quot;] == 123
        assert call_args[1][&quot;authorization&quot;] == &quot;Bearer test_api_token&quot;


class TestAgentStatusCheck:
    &quot;&quot;&quot;Test agent status checking functionality.&quot;&quot;&quot;

    def test_get_status_no_current_job(self):
        &quot;&quot;&quot;Test get_status when no job has been run.&quot;&quot;&quot;
        agent = Agent(token=&quot;test_token&quot;, org_id=123)
        status = agent.get_status()
        assert status is None

    @patch(&quot;codegen.agents.agent.AgentsApi&quot;)
    @patch(&quot;codegen.agents.agent.ApiClient&quot;)
    @patch(&quot;codegen.agents.agent.Configuration&quot;)
    def test_get_status_with_current_job(self, mock_config, mock_api_client, mock_agents_api):
        &quot;&quot;&quot;Test get_status when there is a current job.&quot;&quot;&quot;
        # Setup mocks
        mock_config_instance = MagicMock()
        mock_config.return_value = mock_config_instance

        mock_api_client_instance = MagicMock()
        mock_api_client.return_value = mock_api_client_instance

        mock_agents_api_instance = MagicMock()
        mock_agents_api.return_value = mock_agents_api_instance

        # Create agent
        agent = Agent(token=&quot;test_token&quot;, org_id=123)

        # Mock the task
        mock_task = MagicMock()
        mock_task.id = &quot;task_789&quot;
        mock_task.status = &quot;completed&quot;
        mock_task.result = &quot;Task completed successfully&quot;
        mock_task.web_url = &quot;https://example.com/task/789&quot;

        agent.current_job = mock_task

        # Test get_status
        status = agent.get_status()

        assert status is not None
        assert status[&quot;id&quot;] == &quot;task_789&quot;
        assert status[&quot;status&quot;] == &quot;completed&quot;
        assert status[&quot;result&quot;] == &quot;Task completed successfully&quot;
        assert status[&quot;web_url&quot;] == &quot;https://example.com/task/789&quot;

        # Verify refresh was called
        mock_task.refresh.assert_called_once()</file><file path="tests/unit/codegen/agents/test_usage_demo.py">&quot;&quot;&quot;Demo test showing the exact usage pattern from the user&apos;s requirements.&quot;&quot;&quot;

from unittest.mock import patch

import pytest

# This test demonstrates the exact usage pattern the user wanted to work


def test_usage_pattern_demo():
    &quot;&quot;&quot;Test the exact usage pattern from the user&apos;s requirements.&quot;&quot;&quot;
    with patch(&quot;codegen.agents.agent.AgentsApi&quot;), patch(&quot;codegen.agents.agent.ApiClient&quot;), patch(&quot;codegen.agents.agent.Configuration&quot;):
        # Import works
        from codegen.agents.agent import Agent

        # Initialize the Agent with your organization ID and API token
        agent = Agent(
            org_id=123,  # Find this at codegen.com/developer
            token=&quot;YOUR_API_TOKEN&quot;,  # Get this from codegen.com/developer
            # base_url=&quot;https://codegen-sh-rest-api.modal.run&quot;,  # Optional - defaults to production
        )

        # Verify the agent was created successfully
        assert agent is not None
        assert agent.token == &quot;YOUR_API_TOKEN&quot;
        assert agent.org_id == 123

        # The API client should be initialized
        assert agent.api_client is not None
        assert agent.agents_api is not None

        # Current job should be None initially
        assert agent.current_job is None


def test_error_handling_no_token():
    &quot;&quot;&quot;Test that proper errors are thrown when token is missing.&quot;&quot;&quot;
    # Should raise TypeError when token is missing
    with pytest.raises(TypeError, match=&quot;missing 1 required positional argument: &apos;token&apos;&quot;):
        from codegen.agents.agent import Agent

        Agent()  # No token provided


def test_basic_initialization_variations():
    &quot;&quot;&quot;Test different ways to initialize the Agent.&quot;&quot;&quot;
    from codegen.agents.agent import Agent

    # With both token and org_id
    agent1 = Agent(token=&quot;test_token&quot;, org_id=123)
    assert agent1.token == &quot;test_token&quot;
    assert agent1.org_id == 123

    # With just token (will use default org_id)
    agent2 = Agent(token=&quot;test_token&quot;)
    assert agent2.token == &quot;test_token&quot;
    assert agent2.org_id == 1  # Default fallback

    # With custom base_url
    agent3 = Agent(token=&quot;test_token&quot;, org_id=123, base_url=&quot;https://custom.api.url&quot;)
    assert agent3.token == &quot;test_token&quot;
    assert agent3.org_id == 123
    assert agent3.api_client.configuration.host == &quot;https://custom.api.url&quot;


def test_import_statements():
    &quot;&quot;&quot;Test that all the imports work as expected.&quot;&quot;&quot;
    # Basic import
    from codegen.agents.agent import Agent

    assert Agent is not None

    # Import AgentTask too
    from codegen.agents.agent import Agent, AgentTask

    assert Agent is not None
    assert AgentTask is not None

    # Alternative import style
    import codegen.agents.agent

    assert hasattr(codegen.agents.agent, &quot;Agent&quot;)
    assert hasattr(codegen.agents.agent, &quot;AgentTask&quot;)</file><file path="tests/unit/codegen/test_cli_basic.py">&quot;&quot;&quot;Basic CLI tests to verify core functionality.&quot;&quot;&quot;

import subprocess
import sys
from pathlib import Path


def test_cli_help_works():
    &quot;&quot;&quot;Test that the CLI can show help without credentials.&quot;&quot;&quot;
    # Run the CLI help command
    result = subprocess.run(
        [sys.executable, &quot;-m&quot;, &quot;codegen.cli.cli&quot;, &quot;--help&quot;],
        capture_output=True,
        text=True,
        cwd=Path(__file__).parent.parent.parent.parent,  # Go to project root
    )

    # Should exit with code 0 (success)
    assert result.returncode == 0

    # Should contain basic help text
    assert &quot;Commands&quot; in result.stdout
    assert &quot;init&quot; in result.stdout
    assert &quot;login&quot; in result.stdout
    assert &quot;profile&quot; in result.stdout


def test_cli_version_works():
    &quot;&quot;&quot;Test that the CLI can show version without credentials.&quot;&quot;&quot;
    result = subprocess.run(
        [sys.executable, &quot;-m&quot;, &quot;codegen.cli.cli&quot;, &quot;--version&quot;],
        capture_output=True,
        text=True,
        cwd=Path(__file__).parent.parent.parent.parent,  # Go to project root
    )

    # Should exit with code 0 (success)
    assert result.returncode == 0

    # Should show some version information
    assert len(result.stdout.strip()) &gt; 0


def test_cli_command_help():
    &quot;&quot;&quot;Test that individual commands can show help.&quot;&quot;&quot;
    commands = [&quot;init&quot;, &quot;login&quot;, &quot;logout&quot;, &quot;profile&quot;, &quot;config&quot;, &quot;update&quot;]

    for command in commands:
        result = subprocess.run(
            [sys.executable, &quot;-m&quot;, &quot;codegen.cli.cli&quot;, command, &quot;--help&quot;],
            capture_output=True,
            text=True,
            cwd=Path(__file__).parent.parent.parent.parent,  # Go to project root
        )

        # Should exit with code 0 (success) for help
        assert result.returncode == 0, f&quot;Command &apos;{command} --help&apos; failed with code {result.returncode}&quot;

        # Should contain usage information
        assert &quot;Usage:&quot; in result.stdout, f&quot;Command &apos;{command} --help&apos; doesn&apos;t show usage&quot;


def test_cli_imports_work():
    &quot;&quot;&quot;Test that we can import the CLI module without errors.&quot;&quot;&quot;
    # This test verifies that all imports in the CLI work
    try:
        from codegen.cli.cli import main

        assert main is not None

        # Test Agent import still works
        from codegen.agents.agent import Agent

        assert Agent is not None

    except ImportError as e:
        assert False, f&quot;Failed to import CLI modules: {e}&quot;</file><file path="tests/unit/codegen/test_top_level_imports.py">&quot;&quot;&quot;Test top-level imports from the codegen package.&quot;&quot;&quot;

import pytest


class TestTopLevelImports:
    &quot;&quot;&quot;Test that key classes can be imported at the top level of the codegen package.&quot;&quot;&quot;

    def test_can_import_agent_from_top_level(self):
        &quot;&quot;&quot;Test that Agent class can be imported from the top level.&quot;&quot;&quot;
        # This should work: from codegen import Agent
        from codegen import Agent
        
        # Verify Agent class is available
        assert Agent is not None
        assert callable(Agent)
        
        # Verify it&apos;s the same class as importing from the submodule
        from codegen.agents.agent import Agent as DirectAgent
        assert Agent is DirectAgent

    def test_agent_in_all_exports(self):
        &quot;&quot;&quot;Test that Agent is listed in __all__ exports.&quot;&quot;&quot;
        import codegen
        
        # Agent should be in the __all__ list
        assert hasattr(codegen, &apos;__all__&apos;)
        assert &apos;Agent&apos; in codegen.__all__
        
        # Agent should be accessible as an attribute
        assert hasattr(codegen, &apos;Agent&apos;)
        assert codegen.Agent is not None

    def test_agent_functionality_works_from_top_level(self):
        &quot;&quot;&quot;Test that Agent imported from top level is fully functional.&quot;&quot;&quot;
        from codegen import Agent
        
        # Test that the class has expected methods
        assert hasattr(Agent, &apos;run&apos;)
        assert hasattr(Agent, &apos;get_status&apos;)
        assert callable(getattr(Agent, &apos;run&apos;))
        assert callable(getattr(Agent, &apos;get_status&apos;))
        
        # Test that we can create an Agent instance with None token (it should work)
        agent = Agent(token=None)
        assert agent is not None
        assert hasattr(agent, &apos;token&apos;)
        assert agent.token is None

    def test_version_still_available(self):
        &quot;&quot;&quot;Test that version information is still available alongside Agent.&quot;&quot;&quot;
        import codegen
        
        # Version attributes should still be available
        assert hasattr(codegen, &apos;__version__&apos;)
        assert hasattr(codegen, &apos;version&apos;)
        assert hasattr(codegen, &apos;__version_tuple__&apos;)
        assert hasattr(codegen, &apos;version_tuple&apos;)
        
        # They should be in __all__
        assert &apos;__version__&apos; in codegen.__all__
        assert &apos;version&apos; in codegen.__all__
        assert &apos;__version_tuple__&apos; in codegen.__all__
        assert &apos;version_tuple&apos; in codegen.__all__</file><file path="tests/conftest.py">import os

import pytest


def find_dirs_to_ignore(start_dir, prefix):
    dirs_to_ignore = []
    for root, dirs, files in os.walk(start_dir):
        for dir in dirs:
            full_path = os.path.relpath(os.path.join(root, dir), start_dir)
            if any(dd.startswith(&quot;original_input&quot;) or dd.startswith(&quot;output&quot;) or dd.startswith(&quot;input&quot;) or dd.startswith(&quot;expected&quot;) for dd in dir.split(&quot;/&quot;)):
                dirs_to_ignore.append(full_path)
    return dirs_to_ignore


def pytest_addoption(parser) -&gt; None:
    parser.addoption(
        &quot;--profile&quot;,
        action=&quot;store&quot;,
        type=bool,
        default=False,
        help=&quot;Whether to profile the test&quot;,
    )
    parser.addoption(
        &quot;--sync-graph&quot;,
        action=&quot;store&quot;,
        type=str,
        dest=&quot;sync-graph&quot;,
        default=&quot;false&quot;,
        help=&quot;Whether to sync the graph between tests&quot;,
    )
    parser.addoption(
        &quot;--log-parse&quot;,
        action=&quot;store&quot;,
        type=str,
        dest=&quot;log-parse&quot;,
        default=&quot;false&quot;,
        help=&quot;Whether to log parsing errors for parse tests&quot;,
    )
    parser.addoption(
        &quot;--extra-repos&quot;,
        type=bool,
        action=&quot;store&quot;,
        default=False,
        help=&quot;Whether to test on extra repos&quot;,
    )
    parser.addoption(&quot;--token&quot;, action=&quot;store&quot;, default=None, help=&quot;Read-only GHA token to access extra repos&quot;)

    parser.addoption(&quot;--codemod-id&quot;, action=&quot;store&quot;, type=int, default=None, help=&quot;Runs db skills test for a specific codemod&quot;)

    parser.addoption(&quot;--repo-id&quot;, action=&quot;store&quot;, type=int, default=None, help=&quot;Runs db skills test for a specific repo&quot;)

    parser.addoption(&quot;--base-commit&quot;, action=&quot;store&quot;, type=str, default=None, help=&quot;Runs db skills test for a specific commit. Argument can be the shortest unique substring.&quot;)

    parser.addoption(&quot;--cli-api-key&quot;, action=&quot;store&quot;, type=str, default=None, help=&quot;Token necessary to access skills.&quot;)


@pytest.hookimpl(hookwrapper=True)
def pytest_runtest_makereport(item, call):
    outcome = yield
    report = outcome.get_result()

    if report.when == &quot;call&quot; and report.failed:
        if &quot;NodeJS or npm is not installed&quot; in str(report.longrepr):
            msg = &quot;This test requires NodeJS and npm to be installed. Please install them before running the tests.&quot;
            raise RuntimeError(msg)</file><file path=".gitignore">codegen-frontend/.cache/*
codegen-frontend/build/*
**/node_modules
codegen-frontend/api/index.js
codegen-frontend/api/index.js.map
codegen-frontend/api/*.json
codegen-frontend/app/styles/app.css
**/.run/*
test-repos
**/__pycache__/
.pytest_cache/
.mypy_cache
*/.diffs/**
**.profiles/**
*.pyc
*.pyd
.DS_Store
*.so
*.sw[op]
.idea/*
codegen-frontend/scripts/.ipynb_checkpoints/*
.python-version
**/.vscode/settings.json
**/.vscode/launch.json
**/.ipynb_checkpoints/**
supabase/config.toml
**/.env.local
**/alembic/versions/*
**/scripts/scratch/*
**/scripts/*.md
**/scripts/Personal/*
**/infrastructure/aws_infra/.terraform/*
pyrightconfig.json
Edwards Scratchpad.ipynb

# Allowing .env files to exist in repository, but not allowing updates
.env

# Required folders
extra-repos/
pr-logs/#

# Remove local files
**/.coverage
alembic_versions_backup
.idea/
**/*.egg-info/**
**/*.c
**/build/
**/dist/
**/*.so
**/.diffs/**
**/.coverage*
**/coverage.xml
.nvmrc
**/.virtual_documents
/.nvmrc
**/build/test-results/test/TEST*.xml
src/codegen/sdk/__init__.py
src/codegen/_version.py
src/**/*.html
.ccache/
uv-*.tar.gz
.venv
graph-sitter-types/out/**
graph-sitter-types/typings/**
coverage.json
tests/integration/verified_codemods/codemod_data/repo_commits.json
.benchmarks/*

# SWE Bench results
results.*.json
codegen-examples/examples/swebench_agent_run/results/*
codegen-examples/examples/swebench_agent_run/predictions/*
codegen-examples/examples/swebench_agent_run/logs/*</file><file path=".pre-commit-config.yaml">default_language_version:
  python: python3.13
repos:
  - repo: https://github.com/ComPWA/taplo-pre-commit
    rev: v0.9.3
    hooks:
      - id: taplo-format
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.9.6
    hooks:
      # Run the linter.
      - id: ruff
        types_or: [python, jupyter, pyi]
        args: [--fix]

      # Run the formatter.
      - id: ruff-format
        types_or: [python, jupyter, pyi]

  - repo: https://github.com/biomejs/pre-commit
    rev: &quot;v0.6.1&quot;
    hooks:
      - id: biome-check
        language: node
        additional_dependencies: [&quot;@biomejs/biome@1.9.4&quot;]
        exclude: (src/codemods/eval)|(tests/unit/skills/snapshots)|(tests/unit/codegen/sdk/output)|(tests/integration/verified_codemods)|(docs/)

  - repo: https://github.com/kynan/nbstripout
    rev: 0.8.1
    hooks:
      - id: nbstripout

  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v5.0.0
    hooks:
      - id: trailing-whitespace
        exclude: tests/
        exclude_types: [mdx, pyi]
      - id: check-yaml
      - id: end-of-file-fixer
        exclude: (src/codemods/eval)|(tests/unit/skills/snapshots)|(tests/unit/codegen/sdk/output)|(tests/integration/verified_codemods)|(docs/)
      - id: check-merge-conflict

  - repo: https://github.com/python-jsonschema/check-jsonschema
    rev: 0.31.1
    hooks:
      - id: check-github-workflows
      - id: check-github-actions
        args: [&quot;--verbose&quot;]

  - repo: https://github.com/mxr/sync-pre-commit-deps
    rev: v0.0.3
    hooks:
      - id: sync-pre-commit-deps

  - repo: https://github.com/codespell-project/codespell
    rev: v2.4.1
    hooks:
      - id: codespell
        language: python
        additional_dependencies:
          - tomli
        files: &quot;docs/.*/.*.mdx&quot;

  - repo: https://github.com/fpgmaas/deptry.git
    rev: &quot;0.23.0&quot;
    hooks:
      - id: deptry
        pass_filenames: false
        always_run: true
        entry: bash -c &quot;uv run --frozen --all-extras --dev deptry src --ignore DEP001 --extend-exclude &apos;codegen-examples/.*&apos;&quot;

  - repo: https://github.com/renovatebot/pre-commit-hooks
    rev: 39.169.3
    hooks:
      - id: renovate-config-validator

  - repo: https://github.com/astral-sh/uv-pre-commit
    rev: &quot;0.5.31&quot;
    hooks:
      - id: uv-sync
        args: [&quot;--frozen&quot;, &quot;--all-packages&quot;, &quot;--all-extras&quot;]

  - repo: https://github.com/hukkin/mdformat
    rev: 0.7.22 # Use the ref you want to point at
    hooks:
      - id: mdformat
        language: python
        # Optionally add plugins
        additional_dependencies:
          - mdformat-gfm
          - mdformat-ruff
          - mdformat-config
          - mdformat-pyproject</file><file path=".watchmanconfig">{}</file><file path="CLA.md"># **Contributor License Agreement (CLA)**

**Effective Date:** 1/17/2025

**Project Name:** codegen

**Project Owner/Organization:** Codegen, Inc.

1. **Definitions**

   1. **â€œYouâ€** or **â€œContributorâ€** means the individual or entity (and its Affiliates) that Submits a Contribution.
   1. **â€œContributionâ€** means any work of authorship (including any modifications or additions) that is intentionally Submitted by You for inclusion in the Project, in any form (including but not limited to source code, documentation, or other materials).
   1. **â€œSubmitâ€** or **â€œSubmittedâ€** means any act of transferring a Contribution to Codegen, Inc. via pull request, email, or any other method of communication for the purpose of inclusion in the Project.

1. **Grant of Copyright License**

   Subject to the terms and conditions of this CLA, You hereby grant to Codegen, Inc. and to recipients of software distributed by Codegen, Inc.:

   - A perpetual, worldwide, non-exclusive, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works.

1. **Grant of Patent License**

   Subject to the terms and conditions of this CLA, You hereby grant to Codegen, Inc. and to recipients of software distributed by Codegen, Inc. a perpetual, worldwide, non-exclusive, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer Your Contribution, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contribution alone or by combination of Your Contribution with the Project to which You Submitted it.

   If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that Your Contribution, or the Project to which You have contributed, directly or indirectly infringes any patent, then any patent licenses granted to that entity under this CLA for that Contribution or Project shall terminate as of the date such litigation is filed.

1. **Representations and Warranties**

   1. **Original Work**. You represent that each of Your Contributions is an original work of authorship and that You have the necessary rights to grant the licenses under this CLA.
   1. **Third-Party Rights**. If Your employer(s) or any third party has rights to intellectual property that You create, You represent that You have received permission to make Contributions on behalf of that employer or third party (or that such employer or third party has waived those rights for Your Contributions).
   1. **No Other Agreements**. You represent that You are not aware of any other agreement or obligation that is inconsistent with the rights granted under this CLA.

1. **Disclaimer of Warranty**

   UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING, YOU PROVIDE YOUR CONTRIBUTIONS ON AN **â€œAS ISâ€** BASIS, **WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND**, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.

1. **Limitation of Liability**

   IN NO EVENT SHALL CODEGEN, INC. OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE), ARISING IN ANY WAY OUT OF OR IN CONNECTION WITH THIS AGREEMENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

1. **Subsequent Contributions and Updates**

   You agree that all current and future Contributions to the Project Submitted by You shall be subject to the terms of this CLA. Codegen, Inc. may publish updates to this CLA from time to time; in such case, You may need to agree to new terms before any subsequent Contributions.

1. **License Modification Rights**

   You agree that Codegen, Inc. may change the license(s) applicable to the open source project(s) to which Your Contributions relate at Codegen, Inc.â€™s sole discretion, including without limitation by re-licensing the project(s) and Your Contributions under any other open source or â€œfreeâ€ software license, or a commercial or proprietary license of Codegen, Inc.â€™s choosing.

1. **Governing Law**

   This CLA shall be governed by and construed in accordance with the laws of the State of Delaware, without regard to its conflicts of laws provisions.

1. **Signature / Electronic Consent**

   By signing or otherwise indicating Your acceptance of this CLA, You acknowledge that You have read and agree to be bound by its terms. If You are signing on behalf of an entity, You represent and warrant that You have the authority to do so.</file><file path="CONTRIBUTING.md"># Contributing to Codegen

Thank you for your interest in contributing to Codegen! This document outlines the process and guidelines for contributing. If you have any questions, please join our [Slack Community](https://community.codegen.com) ðŸ˜€.

## Contributor License Agreement

By contributing to Codegen, you agree that:

1. Your contributions will be licensed under the project&apos;s license.
1. You have the right to license your contribution under the project&apos;s license.
1. You grant Codegen a perpetual, worldwide, non-exclusive, royalty-free license to use your contribution.

See our [CLA](CLA.md) for more details.

## Development Setup

### Installing UV Package Manager

UV is a fast Python package installer and resolver. To install:

**macOS**:

```bash
brew install uv
```

For other platforms, see the [UV installation docs](https://github.com/astral-sh/uv).

### Setting Up the Development Environment

After installing UV, set up your development environment:

```bash
uv venv
source .venv/bin/activate
uv sync --dev
```

&gt; [!TIP]
&gt;
&gt; - If sync fails with `missing field &apos;version&apos;`, you may need to delete lockfile and rerun `rm uv.lock &amp;&amp; uv sync --dev`.
&gt; - If sync fails with failed compilation, you may need to install dependencies (see [install-deps.sh](scripts/install-deps.sh)) and rerun `uv sync --dev`.

### Running Tests

```bash
# Unit tests (tests atomic functionality)
uv run pytest tests/unit -n auto

# Codemod tests (tests larger programs)
uv run pytest tests/integration/codemod/test_codemods.py -n auto
```

&gt; [!TIP]
&gt;
&gt; - If on Linux the error `OSError: [Errno 24] Too many open files` appears then you might want to increase your _ulimit_

## Pull Request Process

1. Fork the repository and create your branch from `develop`.
1. Ensure your code passes all tests.
1. Update documentation as needed.
1. Submit a pull request to the `develop` branch.
1. Include a clear description of your changes in the PR.

## Release Process

First you must wait for all required checks to pass before releasing.
Create a git tag and push it to develop to trigger a new release:

```bash
git switch develop
git pull
git tag v0.YOUR_VERSION
git push origin v0.YOUR_VERSION
```

This will trigger a release job to build this new version.</file><file path="hatch.toml">[build.hooks.vcs]
dependencies = [&quot;hatch-vcs&gt;=0.4.0&quot;]
version-file = &quot;src/codegen/_version.py&quot;

[metadata]
allow-direct-references = true

[envs.hatch-build]
installer = &quot;uv&quot;

[[envs.hatch-build.matrix]]
tool = [&quot;uv&quot;, &quot;pip&quot;]

[envs.hatch-build.overrides]
matrix.tool.installer = { value = &quot;{matrix:tool}&quot; }
matrix.tool.scripts = [
  { key = &quot;pip&quot;, value = &quot;{env:HATCH_UV} pip {args}&quot;, if = [
    &quot;uv&quot;,
  ] },
]

[version]
source = &quot;vcs&quot;

[build]
packages = [&quot;src/codegen&quot;]

[metadata.hooks.vcs.urls]
Homepage = &quot;https://www.codegen.com/&quot;
Repository = &quot;https://github.com/codegen-sh/codegen-sdk&quot;
Download = &quot;https://github.com/codegen-sh/codegen-sdk/archive/{commit_hash}.zip&quot;
Changelog = &quot;https://docs.codegen.com/changelog/changelog&quot;
Releasenotes = &quot;https://github.com/codegen-sh/codegen-sdk/releases&quot;
Issues = &quot;https://github.com/codegen-sh/codegen-sdk/issues&quot;
Documentation = &quot;https://docs.codegen.com&quot;
Playground = &quot;https://www.codegen.sh/&quot;

[envs.default]
installer = &quot;uv&quot;</file><file path="install-hooks.sh">#!/bin/bash

# directory of this script
SCRIPT_DIR=&quot;$( cd &quot;$( dirname &quot;${BASH_SOURCE[0]}&quot; )&quot; &amp;&gt; /dev/null &amp;&amp; pwd )&quot;

# directory of the git hooks
GITHOOKS_DIR=&quot;${SCRIPT_DIR}/../githooks&quot;

# directory where the hooks should be installed
INSTALL_DIR=&quot;${SCRIPT_DIR}/../.git/hooks&quot;

# loop through the files in the githooks directory
for HOOK in $(ls &quot;${GITHOOKS_DIR}&quot;); do
    # create a symbolic link in the .git/hooks directory
    ln -sf &quot;${GITHOOKS_DIR}/${HOOK}&quot; &quot;${INSTALL_DIR}/${HOOK}&quot;

    # change permissions to make the hook executable
    chmod +x &quot;${INSTALL_DIR}/${HOOK}&quot;
done</file><file path="LICENSE">Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      &quot;License&quot; shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      &quot;Licensor&quot; shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      &quot;Legal Entity&quot; shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      &quot;control&quot; means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      &quot;You&quot; (or &quot;Your&quot;) shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      &quot;Source&quot; form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      &quot;Object&quot; form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      &quot;Work&quot; shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      &quot;Derivative Works&quot; shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      &quot;Contribution&quot; shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, &quot;submitted&quot;
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as &quot;Not a Contribution.&quot;

      &quot;Contributor&quot; shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a &quot;NOTICE&quot; text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an &quot;AS IS&quot; BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets &quot;[]&quot;
      replaced with your own identifying information. (Don&apos;t include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same &quot;printed page&quot; as the copyright notice for easier
      identification within third-party archives.

   Copyright 2025 Codegen

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.</file><file path="package.json">{
	&quot;private&quot;: true,
	&quot;release&quot;: {
		&quot;branches&quot;: [&quot;develop&quot;],
		&quot;plugins&quot;: [
			&quot;@semantic-release/commit-analyzer&quot;,
			&quot;@semantic-release/release-notes-generator&quot;,
			&quot;@semantic-release/github&quot;
		]
	}
}</file><file path="pyproject.toml">[project]
name = &quot;codegen&quot;
dynamic = [&quot;version&quot;, &quot;urls&quot;]
description = &quot;Scriptable interface to a powerful, multi-lingual language server built on top of Tree-sitter&quot;
readme = &quot;README.md&quot;
# renovate: datasource=python-version depName=python
requires-python = &quot;&gt;=3.12, &lt;3.14&quot;
dependencies = [
  &quot;codegen-api-client&quot;,
  &quot;typer&gt;=0.12.5&quot;,
  &quot;rich&gt;=13.7.1&quot;,
  &quot;textual&gt;=0.91.0&quot;,
  &quot;hatch-vcs&gt;=0.4.0&quot;,
  &quot;hatchling&gt;=1.25.0&quot;,
  # CLI and git functionality dependencies
  &quot;requests&gt;=2.32.3&quot;,
  &quot;pydantic&gt;=2.9.2&quot;,
  &quot;pydantic-settings&gt;=2.0.0&quot;,
  &quot;PyGithub==2.6.1&quot;,
  &quot;GitPython==3.1.44&quot;,
  &quot;packaging&gt;=24.2&quot;,
  &quot;python-dotenv&gt;=1.0.1&quot;,
  &quot;giturlparse&quot;,
  &quot;codeowners&gt;=0.6.0&quot;,
  &quot;unidiff&gt;=0.7.5&quot;,
  &quot;datamodel-code-generator&gt;=0.26.5&quot;,
  &quot;fastmcp&gt;=2.9.0&quot;,
  # OpenTelemetry logging dependencies
  &quot;opentelemetry-api&gt;=1.26.0&quot;,
  &quot;opentelemetry-sdk&gt;=1.26.0&quot;,
  &quot;opentelemetry-exporter-otlp&gt;=1.26.0&quot;,
  # Utility dependencies
  &quot;colorlog&gt;=6.9.0&quot;,
  &quot;psutil&gt;=5.8.0&quot;,
  &quot;sentry-sdk==2.29.1&quot;,
  &quot;humanize&gt;=4.10.0&quot;,
]

# renovate: datasource=python-version depName=python
license = { text = &quot;Apache-2.0&quot; }
classifiers = [
  &quot;Development Status :: 4 - Beta&quot;,

  &quot;Environment :: Console&quot;,
  &quot;Environment :: MacOS X&quot;,

  &quot;Intended Audience :: Developers&quot;,
  &quot;Intended Audience :: Information Technology&quot;,

  &quot;License :: OSI Approved&quot;,
  &quot;License :: OSI Approved :: Apache Software License&quot;,

  &quot;Operating System :: OS Independent&quot;,

  &quot;Programming Language :: Python&quot;,
  &quot;Programming Language :: Python :: 3&quot;,
  &quot;Programming Language :: Python :: 3.12&quot;,
  &quot;Programming Language :: Python :: 3.13&quot;,

  &quot;Topic :: Software Development&quot;,
  &quot;Topic :: Software Development :: Libraries :: Python Modules&quot;,
  &quot;Topic :: Software Development :: Code Generators&quot;,
  &quot;Topic :: Software Development :: Libraries&quot;,
]
authors = [{ name = &quot;Codegen Team&quot;, email = &quot;team@codegen.sh&quot; }]
keywords = [
  &quot;codegen&quot;,
  &quot;codebase&quot;,
  &quot;codebase manipulation&quot;,
  &quot;codebase analysis&quot;,
  &quot;codebase transformation&quot;,
  &quot;refactoring&quot;,
  &quot;code generation&quot;,
]
[project.scripts]
codegen = &quot;codegen.cli.cli:main&quot;
cg = &quot;codegen.cli.cli:main&quot;

[project.optional-dependencies]
types = []
[tool.uv]
cache-keys = [{ git = { commit = true, tags = true } }]
dev-dependencies = [
  &quot;coverage&lt;8.0.0,&gt;=7.6.1&quot;,
  &quot;filelock&lt;4.0.0,&gt;=3.15.4&quot;,
  &quot;pytest&gt;=8.3.3&quot;,
  &quot;pytest-cov&gt;=6.1.0,&lt;6.1.1&quot;,
  &quot;ruff&gt;=0.6.8&quot;,
  &quot;ty&gt;=0.0.1a10&quot;,
  &quot;pre-commit&gt;=4.0.1&quot;,
  &quot;pytest-xdist&gt;=3.6.1,&lt;4.0.0&quot;,
  &quot;pytest-mock&lt;4.0.0,&gt;=3.14.0&quot;,
  &quot;pytest-timeout&gt;=2.3.1&quot;,
  &quot;ruff-lsp&lt;1.0.0,&gt;=0.0.55&quot;,
  &quot;austin-python&gt;=1.7.1&quot;,
  &quot;autoflake&gt;=2.3.1&quot;,
  &quot;typer&gt;=0.12.5&quot;,
  &quot;pre-commit-uv&gt;=4.1.4&quot;,
  &quot;austin-dist&gt;=3.7.0&quot;,
  &quot;uv&gt;=0.4.25&quot;,
  &quot;deptry&gt;=0.22.0&quot;,
  &quot;sybil[pytest]&gt;=9.0.0&quot;,
  &quot;jsbeautifier&lt;2.0.0,&gt;=1.15.1&quot;,
  &quot;inflection&lt;1.0.0,&gt;=0.5.1&quot;,
  &quot;autoflake&gt;=2.3.1&quot;,
  &quot;black&gt;=24.8.0&quot;,
  &quot;isort&gt;=5.13.2&quot;,
  &quot;emoji&gt;=2.14.0&quot;,
  &quot;pytest-benchmark[histogram]&gt;=5.1.0&quot;,
  &quot;pytest-asyncio&gt;=0.21.1,&lt;1.0.0&quot;,
  &quot;loguru&gt;=0.7.3&quot;,
  &quot;httpx&lt;0.28.2,&gt;=0.28.1&quot;,
  &quot;jupyterlab&gt;=4.3.5&quot;,
  &quot;modal&gt;=0.73.25&quot;,
  &quot;pytest-lsp&gt;=1.0.0b1&quot;,
  &quot;codegen-api-client&gt;=1.0.0&quot;,
]

[tool.uv.workspace]
exclude = [&quot;codegen-examples&quot;]


[tool.coverage.run]
branch = true
concurrency = [&quot;multiprocessing&quot;, &quot;thread&quot;]
parallel = true
sigterm = true

[tool.coverage.report]
skip_covered = true
skip_empty = true
exclude_also = [
  &quot;if TYPE_CHECKING:&quot;,
  # Don&apos;t complain about missing debug-only code:
  &quot;def __repr__&quot;,
  # Don&apos;t complain if tests don&apos;t hit defensive assertion code:
  &quot;raise AssertionError&quot;,
  &quot;raise NotImplementedError&quot;,
  # Don&apos;t complain if non-runnable code isn&apos;t run:
  &quot;if __name__ == .__main__.:&quot;,
  # Don&apos;t complain about abstract methods, they aren&apos;t run:
  &quot;@(abc\\.)?abstractmethod&quot;,
]

[tool.coverage.html]
show_contexts = true
[tool.coverage.json]
show_contexts = true
[tool.pyright]
pythonVersion = &quot;3.12&quot;
enableExperimentalFeatures = true
[tool.pytest.ini_options]
# addopts = -v
pythonpath = &quot;.&quot;
norecursedirs = &quot;repos expected&quot;
# addopts = -v --cov=app --cov-report=term

addopts = &quot;--dist=loadgroup --junitxml=build/test-results/test/TEST.xml --strict-config --import-mode=importlib --cov-context=test --cov-config=pyproject.toml -p no:doctest&quot;
filterwarnings = &quot;&quot;&quot;
    ignore::DeprecationWarning:botocore.*:
    ignore::DeprecationWarning:sqlalchemy.*:
    ignore::DeprecationWarning:posthog.*:&quot;&quot;&quot;
log_cli = true
log_cli_level = &quot;INFO&quot;
xfail_strict = true
junit_duration_report = &quot;call&quot;
junit_logging = &quot;all&quot;
tmp_path_retention_policy = &quot;failed&quot;
asyncio_mode = &quot;auto&quot;
asyncio_default_fixture_loop_scope = &quot;function&quot;
[build-system]
requires = [&quot;hatchling&gt;=1.26.3&quot;, &quot;hatch-vcs&gt;=0.4.0&quot;, &quot;setuptools-scm&gt;=8.0.0&quot;]
build-backend = &quot;hatchling.build&quot;


[tool.deptry]
extend_exclude = [&quot;.*/eval/test_files/.*.py&quot;, &quot;.*conftest.py&quot;]
pep621_dev_dependency_groups = [&quot;types&quot;]
[tool.deptry.per_rule_ignores]
DEP002 = [
  &quot;hatch-vcs&quot;, # Used for version management during build
  &quot;hatchling&quot;, # Used for building
]
DEP003 = []
DEP004 = &quot;pytest&quot;

[tool.deptry.package_module_name_map]
PyGithub = [&quot;github&quot;]
GitPython = [&quot;git&quot;]
python-dotenv = [&quot;dotenv&quot;]
pydantic-settings = [&quot;pydantic_settings&quot;]
datamodel-code-generator = [&quot;datamodel_code_generator&quot;]
sentry-sdk = [&quot;sentry_sdk&quot;]


[tool.semantic_release]
assets = []
build_command_env = []
commit_message = &quot;{version}\n\nAutomatically generated by python-semantic-release&quot;
commit_parser = &quot;angular&quot;
logging_use_named_masks = false
major_on_zero = true
allow_zero_version = true
repo_dir = &quot;.&quot;
no_git_verify = false
tag_format = &quot;v{version}&quot;

[tool.semantic_release.branches.develop]
match = &quot;develop&quot;
prerelease_token = &quot;rc&quot;
prerelease = false</file><file path="QUICK_START_LOGGING.md"># ðŸš€ Quick Start: Using OpenTelemetry Logging in Your CLI

## âš¡ TL;DR - 3 Step Process

1. **Import the logger**: `from codegen.shared.logging.get_logger import get_logger`
2. **Add `extra={}` to your log calls**: `logger.info(&quot;message&quot;, extra={&quot;key&quot;: &quot;value&quot;})`
3. **Enable telemetry**: `codegen config telemetry enable`

**That&apos;s it!** Your logs automatically go to Grafana Cloud when telemetry is enabled.

## ðŸŽ¯ Immediate Actions You Can Take

### 1. Quick Enhancement of Existing Commands

Pick **any existing CLI command** and add 2-3 lines:

```python
# Add this import at the top
from codegen.shared.logging.get_logger import get_logger

# Add this line after imports
logger = get_logger(__name__)

# Find any existing console.print() or error handling and add:
logger.info(&quot;Operation completed&quot;, extra={
    &quot;operation&quot;: &quot;command_name&quot;,
    &quot;org_id&quot;: org_id,  # if available
    &quot;success&quot;: True
})
```

### 2. Test the Integration Right Now

```bash
# 1. Enable telemetry
codegen config telemetry enable

# 2. Run the demo
python example_enhanced_agent_command.py

# 3. Run any CLI command 
codegen agents  # or any other command

# 4. Check status
codegen config telemetry status
```

## ðŸ“ Copy-Paste Patterns

### Pattern 1: Operation Start/End
```python
logger = get_logger(__name__)

# At start of function
logger.info(&quot;Operation started&quot;, extra={
    &quot;operation&quot;: &quot;command.subcommand&quot;,
    &quot;user_input&quot;: relevant_input
})

# At end of function  
logger.info(&quot;Operation completed&quot;, extra={
    &quot;operation&quot;: &quot;command.subcommand&quot;,
    &quot;success&quot;: True
})
```

### Pattern 2: Error Handling
```python
try:
    # your existing code
    pass
except SomeSpecificError as e:
    logger.error(&quot;Specific error occurred&quot;, extra={
        &quot;operation&quot;: &quot;command.subcommand&quot;, 
        &quot;error_type&quot;: &quot;specific_error&quot;,
        &quot;error_details&quot;: str(e)
    }, exc_info=True)
    # your existing error handling
```

### Pattern 3: API Calls
```python
# Before API call
logger.info(&quot;Making API request&quot;, extra={
    &quot;operation&quot;: &quot;api.request&quot;,
    &quot;endpoint&quot;: &quot;agent/run&quot;,
    &quot;org_id&quot;: org_id
})

# After successful API call
logger.info(&quot;API request successful&quot;, extra={
    &quot;operation&quot;: &quot;api.request&quot;, 
    &quot;endpoint&quot;: &quot;agent/run&quot;,
    &quot;response_id&quot;: response.get(&quot;id&quot;),
    &quot;status_code&quot;: response.status_code
})
```

## ðŸŽ¯ What to Log (Priority Order)

### ðŸ”¥ High Priority (Add These First)
- **Operation start/end**: When commands begin/complete
- **API calls**: Requests to your backend
- **Authentication events**: Login/logout/token issues  
- **Errors**: Any exception or failure
- **User actions**: Commands run, options selected

### â­ Medium Priority
- **Performance**: Duration of operations
- **State changes**: Status updates, configuration changes
- **External tools**: Claude CLI detection, git operations

### ðŸ’¡ Low Priority (Nice to Have)
- **Debug info**: Internal state, validation steps
- **User behavior**: Which features are used most

## ðŸ”§ Minimal Changes to Existing Commands

### Example: Enhance agent/main.py

```python
# Just add these 3 lines to your existing create() function:

from codegen.shared.logging.get_logger import get_logger
logger = get_logger(__name__)

def create(prompt: str, org_id: int | None = None, ...):
    &quot;&quot;&quot;Create a new agent run with the given prompt.&quot;&quot;&quot;
    
    # ADD: Log start
    logger.info(&quot;Agent creation started&quot;, extra={
        &quot;operation&quot;: &quot;agent.create&quot;,
        &quot;org_id&quot;: org_id,
        &quot;prompt_length&quot;: len(prompt)
    })
    
    # Your existing code...
    try:
        response = requests.post(url, headers=headers, json=payload)
        agent_run_data = response.json()
        
        # ADD: Log success  
        logger.info(&quot;Agent created successfully&quot;, extra={
            &quot;operation&quot;: &quot;agent.create&quot;,
            &quot;agent_run_id&quot;: agent_run_data.get(&quot;id&quot;),
            &quot;status&quot;: agent_run_data.get(&quot;status&quot;)
        })
        
    except requests.RequestException as e:
        # ADD: Log error
        logger.error(&quot;Agent creation failed&quot;, extra={
            &quot;operation&quot;: &quot;agent.create&quot;, 
            &quot;error_type&quot;: &quot;api_error&quot;,
            &quot;error&quot;: str(e)
        })
        # Your existing error handling...
```

### Example: Enhance claude/main.py

```python
# Add to your _run_claude_interactive function:

logger = get_logger(__name__)

def _run_claude_interactive(resolved_org_id: int, no_mcp: bool | None) -&gt; None:
    session_id = generate_session_id()
    
    # ADD: Log session start
    logger.info(&quot;Claude session started&quot;, extra={
        &quot;operation&quot;: &quot;claude.session_start&quot;,
        &quot;session_id&quot;: session_id[:8],  # Short version for privacy
        &quot;org_id&quot;: resolved_org_id
    })
    
    # Your existing code...
    
    try:
        process = subprocess.Popen([claude_path, &quot;--session-id&quot;, session_id])
        returncode = process.wait()
        
        # ADD: Log session end
        logger.info(&quot;Claude session completed&quot;, extra={
            &quot;operation&quot;: &quot;claude.session_complete&quot;,
            &quot;session_id&quot;: session_id[:8],
            &quot;exit_code&quot;: returncode,
            &quot;status&quot;: &quot;COMPLETE&quot; if returncode == 0 else &quot;ERROR&quot;
        })
        
    except Exception as e:
        # ADD: Log session error
        logger.error(&quot;Claude session failed&quot;, extra={
            &quot;operation&quot;: &quot;claude.session_error&quot;,
            &quot;session_id&quot;: session_id[:8],
            &quot;error&quot;: str(e)
        })
```

## ðŸ§ª Verification

After making changes:

1. **Run the command**: Execute your enhanced CLI command
2. **Check telemetry status**: `codegen config telemetry status` 
3. **Look for logs in Grafana Cloud**: Search for your operation names
4. **Test with telemetry disabled**: `codegen config telemetry disable` - should still work normally

## ðŸš€ Progressive Enhancement

**Week 1**: Add basic operation logging to 2-3 commands
**Week 2**: Add error logging to all commands  
**Week 3**: Add performance metrics and detailed context
**Week 4**: Create Grafana dashboards using the collected data

## ðŸŽ‰ Benefits You&apos;ll See Immediately

- **Real usage data**: Which commands are used most?
- **Error tracking**: What breaks and how often?
- **Performance insights**: Which operations are slow?
- **User behavior**: How do users actually use your CLI?
- **Debugging**: Rich context when things go wrong

Start with just **one command** and **one log line** - you&apos;ll see the value immediately! ðŸŽ¯</file><file path="README.md">&lt;br /&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;a href=&quot;https://docs.codegen.com&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/6RF9W0z.jpeg&quot; /&gt;
  &lt;/a&gt;
&lt;/p&gt;

&lt;h2 align=&quot;center&quot;&gt;
  The SWE that Never Sleeps
&lt;/h2&gt;

&lt;div align=&quot;center&quot;&gt;

[![PyPI](https://img.shields.io/badge/PyPi-codegen-gray?style=flat-square&amp;color=blue)](https://pypi.org/project/codegen/)
[![Documentation](https://img.shields.io/badge/Docs-docs.codegen.com-purple?style=flat-square)](https://docs.codegen.com)
[![Slack Community](https://img.shields.io/badge/Slack-Join-4A154B?logo=slack&amp;style=flat-square)](https://community.codegen.com)
[![License](https://img.shields.io/badge/Code%20License-Apache%202.0-gray?&amp;color=gray)](https://github.com/codegen-sh/codegen-sdk/tree/develop?tab=Apache-2.0-1-ov-file)
[![Follow on X](https://img.shields.io/twitter/follow/codegen?style=social)](https://x.com/codegen)

&lt;/div&gt;

&lt;br /&gt;

The Codegen SDK provides a programmatic interface to code agents provided by [Codegen](https://codegen.com).

```python
from codegen.agents.agent import Agent

# Initialize the Agent with your organization ID and API token
agent = Agent(
    org_id=&quot;YOUR_ORG_ID&quot;,  # Find this at codegen.com/token
    token=&quot;YOUR_API_TOKEN&quot;,  # Get this from codegen.com/token
    # base_url=&quot;https://codegen-sh-rest-api.modal.run&quot;,  # Optional - defaults to production
)

# Run an agent with a prompt
task = agent.run(prompt=&quot;Implement a new feature to sort users by last login.&quot;)

# Check the initial status
print(task.status)

# Refresh the task to get updated status (tasks can take time)
task.refresh()

# Check the updated status
print(task.status)

# Once task is complete, you can access the result
if task.status == &quot;completed&quot;:
    print(task.result)  # Result often contains code, summaries, or links
```

## Installation and Usage

Install the SDK using pip, pipx, or uv:

```bash
pip install codegen
# or
pipx install codegen
# or
uv tool install codegen
```

### Keeping Up to Date

The Codegen CLI includes a built-in self-update system:

```bash
# Update to the latest version
codegen update

# Check for available updates
codegen update --check

# Update to a specific version
codegen update --version 1.2.3
```

The CLI automatically checks for updates daily and notifies you when a new version is available.

Get started at [codegen.com](https://codegen.com) and get your API token at [codegen.com/token](https://codegen.com/token).

You can interact with your AI engineer via API, or chat with it in Slack, Linear, Github, or on our website.

## Resources

- [Docs](https://docs.codegen.com)
- [Getting Started](https://docs.codegen.com/introduction/getting-started)
- [Contributing](CONTRIBUTING.md)
- [Contact Us](https://codegen.com/contact)

## Contributing

Please see our [Contributing Guide](CONTRIBUTING.md) for instructions on how to set up the development environment and submit contributions.

## Enterprise

For more information on enterprise engagements, please [contact us](https://codegen.com/contact) or [request a demo](https://codegen.com/request-demo).</file><file path="renovate.json5">{
  &quot;$schema&quot;: &quot;https://docs.renovatebot.com/renovate-schema.json&quot;,
  &quot;extends&quot;: [
    &quot;config:recommended&quot;,
    &quot;:automergeLinters&quot;,
    &quot;:automergeMinor&quot;,
    &quot;:automergePatch&quot;,
    // &quot;:enablePreCommit&quot;,
    &quot;:maintainLockFilesWeekly&quot;,
    &quot;group:githubArtifactActions&quot;,
    &quot;schedule:automergeWeekly&quot;
  ],
  lockFileMaintenance: {
    enabled: true,
    &quot;automerge&quot;: true
  },
}</file><file path="ruff.toml">line-length = 200
exclude = [
  &quot;src/codegen/shared/compilation/function_imports.py&quot;,
  &apos;docs/**&apos;,
  &quot;src/codegen/__init__.py&quot;,                            # Generated version file by hatch-vcs
  &quot;src/codegen/_version.py&quot;,                            # Generated version file by hatch-vcs
]
unsafe-fixes = true
[lint]
select = [
  &quot;F&quot;,
  &quot;E&quot;,
  &quot;W&quot;,
  &quot;I&quot;,
  &quot;UP&quot;,
  &quot;D&quot;,
  &quot;YTT&quot;,
  &quot;RUF&quot;,
  &quot;DTZ&quot;,
  &quot;TC&quot;,
  &quot;EM&quot;,
  &quot;TRY400&quot;,
]
ignore = [
  &quot;D100&quot;,
  &quot;D101&quot;,
  &quot;D102&quot;,
  &quot;D103&quot;,
  &quot;D104&quot;,
  &quot;D105&quot;,
  &quot;D106&quot;,
  &quot;D107&quot;,
  &quot;D203&quot;,
  &quot;D205&quot;,
  &quot;D213&quot;,
  &quot;D400&quot;,
  &quot;D401&quot;,
  &quot;D402&quot;,
  &quot;D404&quot;,
  &quot;D415&quot;,
  &quot;D417&quot;,
  &quot;E712&quot;,   # https://github.com/astral-sh/ruff/issues/4560
  &quot;F841&quot;,
  &quot;F842&quot;,
  &quot;RUF012&quot;,
  &quot;RUF007&quot;,
]
exclude = [
  &quot;*.ipynb&quot;,
] # disable just linting for notebooks (allow for formatting)
[lint.per-file-ignores]
[lint.pydocstyle]
convention = &quot;google&quot;
[lint.pyflakes]
extend-generics = [
  &quot;codegen.sdk.codebase.flagging.enums.MessageType&quot;,
  &quot;codegen.sdk.codebase.flagging.enums.FlagKwargs&quot;,
  &quot;codegen.sdk.codebase.span.Span&quot;,
  &quot;codegen.sdk.core.assignment.Assignment&quot;,
  &quot;codegen.sdk.core.class_definition.Class&quot;,
  &quot;codegen.sdk.core.codebase.Codebase&quot;,
  &quot;codegen.sdk.core.codeowner.CodeOwner&quot;,
  &quot;codegen.sdk.core.dataclasses.usage.Usage&quot;,
  &quot;codegen.sdk.core.dataclasses.usage.UsageType&quot;,
  &quot;codegen.sdk.core.dataclasses.usage.UsageKind&quot;,
  &quot;codegen.sdk.core.detached_symbols.argument.Argument&quot;,
  &quot;codegen.sdk.core.detached_symbols.code_block.CodeBlock&quot;,
  &quot;codegen.sdk.core.detached_symbols.decorator.Decorator&quot;,
  &quot;codegen.sdk.core.detached_symbols.function_call.FunctionCall&quot;,
  &quot;codegen.sdk.core.detached_symbols.parameter.Parameter&quot;,
  &quot;codegen.sdk.core.directory.Directory&quot;,
  &quot;codegen.sdk.core.export.Export&quot;,
  &quot;codegen.sdk.core.expressions.await_expression.AwaitExpression&quot;,
  &quot;codegen.sdk.core.expressions.binary_expression.BinaryExpression&quot;,
  &quot;codegen.sdk.core.expressions.boolean.Boolean&quot;,
  &quot;codegen.sdk.core.expressions.chained_attribute.ChainedAttribute&quot;,
  &quot;codegen.sdk.core.expressions.comparison_expression.ComparisonExpression&quot;,
  &quot;codegen.sdk.core.expressions.expression.Expression&quot;,
  &quot;codegen.sdk.core.expressions.generic_type.GenericType&quot;,
  &quot;codegen.sdk.core.expressions.multi_expression.MultiExpression&quot;,
  &quot;codegen.sdk.core.expressions.name.Name&quot;,
  &quot;codegen.sdk.core.expressions.named_type.NamedType&quot;,
  &quot;codegen.sdk.core.expressions.none_type.NoneType&quot;,
  &quot;codegen.sdk.core.expressions.number.Number&quot;,
  &quot;codegen.sdk.core.expressions.parenthesized_expression.ParenthesizedExpression&quot;,
  &quot;codegen.sdk.core.expressions.placeholder_type.PlaceholderType&quot;,
  &quot;codegen.sdk.core.expressions.string.String&quot;,
  &quot;codegen.sdk.core.expressions.subscript_expression.SubscriptExpression&quot;,
  &quot;codegen.sdk.core.expressions.ternary_expression.TernaryExpression&quot;,
  &quot;codegen.sdk.core.expressions.tuple_type.TupleType&quot;,
  &quot;codegen.sdk.core.expressions.type.Type&quot;,
  &quot;codegen.sdk.core.expressions.unary_expression.UnaryExpression&quot;,
  &quot;codegen.sdk.core.expressions.union_type.UnionType&quot;,
  &quot;codegen.sdk.core.expressions.unpack.Unpack&quot;,
  &quot;codegen.sdk.core.expressions.value.Value&quot;,
  &quot;codegen.sdk.core.external_module.ExternalModule&quot;,
  &quot;codegen.sdk.core.file.File&quot;,
  &quot;codegen.sdk.core.file.SourceFile&quot;,
  &quot;codegen.sdk.core.function.Function&quot;,
  &quot;codegen.sdk.core.import_resolution.Import&quot;,
  &quot;codegen.sdk.core.interface.Interface&quot;,
  &quot;codegen.sdk.core.interfaces.callable.Callable&quot;,
  &quot;codegen.sdk.core.interfaces.editable.Editable&quot;,
  &quot;codegen.sdk.core.interfaces.exportable.Exportable&quot;,
  &quot;codegen.sdk.core.interfaces.has_block.HasBlock&quot;,
  &quot;codegen.sdk.core.interfaces.has_name.HasName&quot;,
  &quot;codegen.sdk.core.interfaces.has_value.HasValue&quot;,
  &quot;codegen.sdk.core.interfaces.importable.Importable&quot;,
  &quot;codegen.sdk.core.interfaces.typeable.Typeable&quot;,
  &quot;codegen.sdk.core.interfaces.unwrappable.Unwrappable&quot;,
  &quot;codegen.sdk.core.interfaces.usable.Usable&quot;,
  &quot;codegen.sdk.core.placeholder.placeholder.Placeholder&quot;,
  &quot;codegen.sdk.core.placeholder.placeholder_stub.StubPlaceholder&quot;,
  &quot;codegen.sdk.core.placeholder.placeholder_type.TypePlaceholder&quot;,
  &quot;codegen.sdk.core.statements.assignment_statement.AssignmentStatement&quot;,
  &quot;codegen.sdk.core.statements.attribute.Attribute&quot;,
  &quot;codegen.sdk.core.statements.block_statement.BlockStatement&quot;,
  &quot;codegen.sdk.core.statements.catch_statement.CatchStatement&quot;,
  &quot;codegen.sdk.core.statements.comment.Comment&quot;,
  &quot;codegen.sdk.core.statements.export_statement.ExportStatement&quot;,
  &quot;codegen.sdk.core.statements.expression_statement.ExpressionStatement&quot;,
  &quot;codegen.sdk.core.statements.for_loop_statement.ForLoopStatement&quot;,
  &quot;codegen.sdk.core.statements.if_block_statement.IfBlockStatement&quot;,
  &quot;codegen.sdk.core.statements.import_statement.ImportStatement&quot;,
  &quot;codegen.sdk.core.statements.raise_statement.RaiseStatement&quot;,
  &quot;codegen.sdk.core.statements.return_statement.ReturnStatement&quot;,
  &quot;codegen.sdk.core.statements.statement.StatementType&quot;,
  &quot;codegen.sdk.core.statements.statement.Statement&quot;,
  &quot;codegen.sdk.core.statements.switch_case.SwitchCase&quot;,
  &quot;codegen.sdk.core.statements.switch_statement.SwitchStatement&quot;,
  &quot;codegen.sdk.core.statements.symbol_statement.SymbolStatement&quot;,
  &quot;codegen.sdk.core.statements.try_catch_statement.TryCatchStatement&quot;,
  &quot;codegen.sdk.core.statements.while_statement.WhileStatement&quot;,
  &quot;codegen.sdk.core.symbol.Symbol&quot;,
  &quot;codegen.sdk.core.symbol_group.SymbolGroup&quot;,
  &quot;codegen.sdk.core.symbol_groups.comment_group.CommentGroup&quot;,
  &quot;codegen.sdk.core.symbol_groups.dict.Pair&quot;,
  &quot;codegen.sdk.core.symbol_groups.dict.Dict&quot;,
  &quot;codegen.sdk.core.symbol_groups.expression_group.ExpressionGroup&quot;,
  &quot;codegen.sdk.core.symbol_groups.list.List&quot;,
  &quot;codegen.sdk.core.symbol_groups.multi_line_collection.MultiLineCollection&quot;,
  &quot;codegen.sdk.core.symbol_groups.tuple.Tuple&quot;,
  &quot;codegen.sdk.core.type_alias.TypeAlias&quot;,
  &quot;codegen.sdk.enums.ImportType&quot;,
  &quot;codegen.sdk.python.statements.if_block_statement.PyIfBlockStatement&quot;,
  &quot;codegen.sdk.python.statements.with_statement.WithStatement&quot;,
  &quot;codegen.sdk.typescript.statements.block_statement.TSBlockStatement&quot;,
  &quot;codegen.sdk.typescript.statements.catch_statement.TSCatchStatement&quot;,
  &quot;codegen.sdk.typescript.statements.if_block_statement.TSIfBlockStatement&quot;,
  &quot;codegen.sdk.typescript.symbol_groups.dict.TSDict&quot;,
  &quot;codegen.sdk.core.codebase.PyCodebaseType&quot;,
  &quot;codegen.sdk.core.codebase.TSCodebaseType&quot;,
  &quot;codegen.sdk.core.codebase.CodebaseType&quot;,
  &quot;codegen.sdk.python.assignment.PyAssignment&quot;,
  &quot;codegen.sdk.python.class_definition.PyClass&quot;,
  &quot;codegen.sdk.python.detached_symbols.code_block.PyCodeBlock&quot;,
  &quot;codegen.sdk.python.detached_symbols.decorator.PyDecorator&quot;,
  &quot;codegen.sdk.python.detached_symbols.parameter.PyParameter&quot;,
  &quot;codegen.sdk.python.expressions.chained_attribute.PyChainedAttribute&quot;,
  &quot;codegen.sdk.python.expressions.conditional_expression.PyConditionalExpression&quot;,
  &quot;codegen.sdk.python.expressions.generic_type.PyGenericType&quot;,
  &quot;codegen.sdk.python.expressions.named_type.PyNamedType&quot;,
  &quot;codegen.sdk.python.expressions.string.PyString&quot;,
  &quot;codegen.sdk.python.expressions.union_type.PyUnionType&quot;,
  &quot;codegen.sdk.python.file.PyFile&quot;,
  &quot;codegen.sdk.python.function.PyFunction&quot;,
  &quot;codegen.sdk.python.import_resolution.PyImport&quot;,
  &quot;codegen.sdk.python.interfaces.has_block.PyHasBlock&quot;,
  &quot;codegen.sdk.python.placeholder.placeholder_return_type.PyReturnTypePlaceholder&quot;,
  &quot;codegen.sdk.python.statements.assignment_statement.PyAssignmentStatement&quot;,
  &quot;codegen.sdk.python.statements.attribute.PyAttribute&quot;,
  &quot;codegen.sdk.python.statements.block_statement.PyBlockStatement&quot;,
  &quot;codegen.sdk.python.statements.break_statement.PyBreakStatement&quot;,
  &quot;codegen.sdk.python.statements.catch_statement.PyCatchStatement&quot;,
  &quot;codegen.sdk.python.statements.comment.PyCommentType&quot;,
  &quot;codegen.sdk.python.statements.comment.PyComment&quot;,
  &quot;codegen.sdk.python.statements.for_loop_statement.PyForLoopStatement&quot;,
  &quot;codegen.sdk.python.statements.import_statement.PyImportStatement&quot;,
  &quot;codegen.sdk.python.statements.match_case.PyMatchCase&quot;,
  &quot;codegen.sdk.python.statements.match_statement.PyMatchStatement&quot;,
  &quot;codegen.sdk.python.statements.pass_statement.PyPassStatement&quot;,
  &quot;codegen.sdk.python.statements.try_catch_statement.PyTryCatchStatement&quot;,
  &quot;codegen.sdk.python.statements.while_statement.PyWhileStatement&quot;,
  &quot;codegen.sdk.python.symbol.PySymbol&quot;,
  &quot;codegen.sdk.python.symbol_groups.comment_group.PyCommentGroup&quot;,
  &quot;codegen.sdk.typescript.assignment.TSAssignment&quot;,
  &quot;codegen.sdk.typescript.class_definition.TSClass&quot;,
  &quot;codegen.sdk.typescript.detached_symbols.code_block.TSCodeBlock&quot;,
  &quot;codegen.sdk.typescript.detached_symbols.decorator.TSDecorator&quot;,
  &quot;codegen.sdk.typescript.detached_symbols.jsx.element.JSXElement&quot;,
  &quot;codegen.sdk.typescript.detached_symbols.jsx.expression.JSXExpression&quot;,
  &quot;codegen.sdk.typescript.detached_symbols.jsx.prop.JSXProp&quot;,
  &quot;codegen.sdk.typescript.detached_symbols.parameter.TSParameter&quot;,
  &quot;codegen.sdk.typescript.enum_definition.TSEnum&quot;,
  &quot;codegen.sdk.typescript.export.TSExport&quot;,
  &quot;codegen.sdk.typescript.expressions.array_type.TSArrayType&quot;,
  &quot;codegen.sdk.typescript.expressions.chained_attribute.TSChainedAttribute&quot;,
  &quot;codegen.sdk.typescript.expressions.conditional_type.TSConditionalType&quot;,
  &quot;codegen.sdk.typescript.expressions.expression_type.TSExpressionType&quot;,
  &quot;codegen.sdk.typescript.expressions.function_type.TSFunctionType&quot;,
  &quot;codegen.sdk.typescript.expressions.generic_type.TSGenericType&quot;,
  &quot;codegen.sdk.typescript.expressions.lookup_type.TSLookupType&quot;,
  &quot;codegen.sdk.typescript.expressions.named_type.TSNamedType&quot;,
  &quot;codegen.sdk.typescript.expressions.object_type.TSObjectType&quot;,
  &quot;codegen.sdk.typescript.expressions.query_type.TSQueryType&quot;,
  &quot;codegen.sdk.typescript.expressions.readonly_type.TSReadonlyType&quot;,
  &quot;codegen.sdk.typescript.expressions.string.TSString&quot;,
  &quot;codegen.sdk.typescript.expressions.ternary_expression.TSTernaryExpression&quot;,
  &quot;codegen.sdk.typescript.expressions.undefined_type.TSUndefinedType&quot;,
  &quot;codegen.sdk.typescript.expressions.union_type.TSUnionType&quot;,
  &quot;codegen.sdk.typescript.file.TSFile&quot;,
  &quot;codegen.sdk.typescript.function.TSFunction&quot;,
  &quot;codegen.sdk.typescript.import_resolution.TSImport&quot;,
  &quot;codegen.sdk.typescript.interface.TSInterface&quot;,
  &quot;codegen.sdk.typescript.interfaces.has_block.TSHasBlock&quot;,
  &quot;codegen.sdk.typescript.namespace.TSNamespace&quot;,
  &quot;codegen.sdk.typescript.placeholder.placeholder_return_type.TSReturnTypePlaceholder&quot;,
  &quot;codegen.sdk.typescript.statements.assignment_statement.TSAssignmentStatement&quot;,
  &quot;codegen.sdk.typescript.statements.attribute.TSAttribute&quot;,
  &quot;codegen.sdk.typescript.statements.comment.TSCommentType&quot;,
  &quot;codegen.sdk.typescript.statements.comment.TSComment&quot;,
  &quot;codegen.sdk.typescript.statements.for_loop_statement.TSForLoopStatement&quot;,
  &quot;codegen.sdk.typescript.statements.import_statement.TSImportStatement&quot;,
  &quot;codegen.sdk.typescript.statements.labeled_statement.TSLabeledStatement&quot;,
  &quot;codegen.sdk.typescript.statements.switch_case.TSSwitchCase&quot;,
  &quot;codegen.sdk.typescript.statements.switch_statement.TSSwitchStatement&quot;,
  &quot;codegen.sdk.typescript.statements.try_catch_statement.TSTryCatchStatement&quot;,
  &quot;codegen.sdk.typescript.statements.while_statement.TSWhileStatement&quot;,
  &quot;codegen.sdk.typescript.symbol.TSSymbol&quot;,
  &quot;codegen.sdk.typescript.symbol_groups.comment_group.TSCommentGroup&quot;,
  &quot;codegen.sdk.typescript.symbol_groups.dict.TSPair&quot;,
  &quot;codegen.sdk.typescript.ts_config.TSConfig&quot;,
  &quot;codegen.sdk.typescript.type_alias.TSTypeAlias&quot;,
]
[lint.isort]
known-first-party = [&quot;codegen&quot;]
[format]
docstring-code-format = true</file><file path="ty.toml"># Ty type checker configuration
# Based on the previous mypy.ini configuration

# Basic configuration - ty is still in early development
# so configuration options are limited</file></files></repomix>